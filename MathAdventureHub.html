<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Adventure Hub</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            max-width: 1000px;
            width: 100%;
            margin-bottom: 20px;
        }

        /* Hub Styles */
        .hub-container {
            text-align: center;
        }

        .hub-header {
            margin-bottom: 40px;
        }

        .hub-title {
            font-size: 3.5em;
            color: #2c3e50;
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .hub-subtitle {
            font-size: 1.3em;
            color: #7f8c8d;
            margin: 0;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .game-card {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 25px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .game-card.castle {
            background: linear-gradient(145deg, #3498db, #e8f6f3);
            color: white;
        }

        .game-card.express {
            background: linear-gradient(145deg, #2c3e50, #7f8c8d);
            color: white;
        }

        .game-card.miner {
            background: linear-gradient(145deg, #8B4513, #D2691E);
            color: white;
        }

        .game-card.plane {
            background: linear-gradient(145deg, #4169E1, #e8f6f3);
            color: #2c3e50;
        }

        .game-card.fieldgoal {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            color: white;
        }

        .game-icon {
            font-size: 4em;
            margin-bottom: 15px;
            display: block;
        }

        .game-title {
            font-size: 1.4em;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .game-description {
            font-size: 0.9em;
            line-height: 1.4;
            opacity: 0.9;
        }

        .global-settings {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .sound-toggle {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .sound-toggle:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .sound-toggle.muted {
            background: #95a5a6;
        }

        /* Shared Game Styles */
        .game-container {
            display: none;
        }

        .game-container.active {
            display: block;
        }

        .phase-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .phase-title {
            font-size: 2.5em;
            color: #2c3e50;
            margin: 0;
        }

        .timer {
            font-size: 1.5em;
            color: #e74c3c;
            margin: 10px 0;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            z-index: 1000;
        }

        .back-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        /* Math Phase Styles */
        .math-phase {
            text-align: center;
        }

        .problem-display {
            font-size: 3em;
            color: #2c3e50;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            position: relative;
            transition: background-color 0.3s ease;
        }

        .problem-display.correct {
            background-color: #d4edda;
        }

        .problem-display.incorrect {
            background-color: #f8d7da;
        }

        .feedback-icon {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            font-size: 2em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .feedback-icon.show {
            opacity: 1;
        }

        .feedback-icon.correct {
            color: #28a745;
        }

        .feedback-icon.incorrect {
            color: #dc3545;
        }

        .input-section {
            margin: 20px 0;
        }

        .answer-input {
            font-size: 2em;
            padding: 10px 20px;
            border: 3px solid #3498db;
            border-radius: 10px;
            text-align: center;
            width: 200px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .numberpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 20px auto;
        }

        .numberpad button {
            padding: 15px 20px;
            font-size: 1.5em;
            border: none;
            border-radius: 10px;
            background: #3498db;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .numberpad button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .numberpad button.wide {
            grid-column: span 2;
        }

        .score-display {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            font-size: 1.2em;
        }

        .score-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .score-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #e74c3c;
        }

        /* Action Phase Styles */
        .action-phase {
            text-align: center;
        }

        /* Castle Game Visual Point Display */
        .cannon-point {
            width: 20px;
            height: 20px;
            background: #f1c40f;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #d4a600;
            position: relative;
        }

        .cannon-point::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #e8b800;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .cannon-point-large {
            width: 30px;
            height: 30px;
            background: #d4a600;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 2px solid #b38f00;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .cannon-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.7em;
        }

        /* Shared Point Animation */
        @keyframes pointDrop {
            from {
                transform: translateY(-20px) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* Shared Points Display Container */
        .points-display {
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            margin: 10px 0;
            min-height: 40px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 2px;
        }

        /* Gap between 5th and 6th point for grouping by 5s */
        .point-gap {
            margin-left: 12px !important;
        }

        /* Express Game Visual Point Display */
        .coal-point {
            width: 18px;
            height: 18px;
            background: #2c3e50;
            border-radius: 3px;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 1px solid #1a1a1a;
        }

        .coal-point-large {
            width: 25px;
            height: 25px;
            background: #1a1a1a;
            border-radius: 3px;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 1px solid #000;
        }

        .coal-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.6em;
        }

        /* Miner Game Visual Point Display */
        .dig-point {
            width: 20px;
            height: 20px;
            background: #8B4513;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #5D2E0C;
            position: relative;
        }

        .dig-point::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #A0522D;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .dig-point-large {
            width: 30px;
            height: 30px;
            background: #5D2E0C;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 2px solid #3E1F08;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .dig-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.7em;
        }

        /* Plane Game Visual Point Display */
        .wind-point {
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #2980b9;
            position: relative;
        }

        .wind-point::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #5dade2;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .wind-point-large {
            width: 30px;
            height: 30px;
            background: #2980b9;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 2px solid #1f618d;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .wind-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.7em;
        }

        /* Football point styles */
        .football-point {
            width: 22px;
            height: 14px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 1px solid #3d2817;
        }

        .football-point-large {
            width: 32px;
            height: 20px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #3d2817;
            position: relative;
        }

        .football-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.6em;
        }

        /* Field Goal Game Area */
        .fieldgoal-game-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        /* Direction Meter - Horizontal with color gradient */
        .direction-meter-container {
            width: 600px;
            margin: 10px auto;
        }

        .direction-meter-bar {
            height: 35px;
            border-radius: 17px;
            position: relative;
            overflow: hidden;
            border: 3px solid #2c3e50;
            background: linear-gradient(to right,
                #e74c3c 0%,
                #e67e22 15%,
                #f1c40f 30%,
                #2ecc71 45%,
                #27ae60 50%,
                #2ecc71 55%,
                #f1c40f 70%,
                #e67e22 85%,
                #e74c3c 100%
            );
        }

        .direction-meter-indicator {
            position: absolute;
            width: 8px;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: none;
        }

        .direction-meter-indicator.locked {
            background: #fff;
            box-shadow: 0 0 10px #fff, 0 0 20px #fff;
        }

        .direction-meter-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.85em;
            color: #7f8c8d;
            font-weight: bold;
        }

        /* Power Meter - Vertical thermometer style */
        .power-meter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.4;
            transition: opacity 0.3s;
        }

        .power-meter-container.active {
            opacity: 1;
        }

        .power-meter-label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
            font-size: 0.85em;
        }

        .power-meter-bar {
            width: 40px;
            height: 300px;
            background: linear-gradient(to top,
                #e74c3c 0%,
                #e67e22 20%,
                #f1c40f 40%,
                #2ecc71 60%,
                #27ae60 75%,
                #f1c40f 90%,
                #e74c3c 100%
            );
            border-radius: 20px;
            border: 3px solid #2c3e50;
            position: relative;
            overflow: hidden;
        }

        .power-meter-indicator {
            position: absolute;
            width: 100%;
            height: 6px;
            background: #2c3e50;
            bottom: 0%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            transition: none;
        }

        .power-meter-indicator.locked {
            background: #fff;
            box-shadow: 0 0 10px #fff;
        }

        /* Kick Status */
        .kick-status {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 10px;
        }

        .coal-counter {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .coal-display {
            background: #34495e;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            min-height: 35px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .game-canvas {
            border: 3px solid #34495e;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: #ecf0f1;
        }

        .action-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            font-size: 1.1em;
        }

        /* Math configuration tiles on hub */
        .math-config-hub {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px 20px;
            margin: 0 auto 20px auto;
            max-width: 600px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .config-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 8px 0;
            flex-wrap: wrap;
        }

        .config-label {
            font-size: 0.9em;
            color: #7f8c8d;
            font-weight: bold;
            min-width: 70px;
        }

        .config-tiles {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .config-tile {
            padding: 8px 12px;
            border-radius: 8px;
            background: #ecf0f1;
            border: 2px solid transparent;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
            min-width: 40px;
            text-align: center;
        }

        .config-tile:hover {
            background: #e8f4f8;
            transform: scale(1.05);
        }

        .config-tile.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
            box-shadow: 0 2px 6px rgba(52, 152, 219, 0.4);
        }

        /* Difficulty config below games */
        .difficulty-config-hub {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px 20px;
            margin: 20px auto 0 auto;
            max-width: 400px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Colored difficulty tiles */
        .config-tile.difficulty-easy {
            background: #e8f8e8;
            border-color: #27ae60;
        }

        .config-tile.difficulty-easy:hover {
            background: #d4f0d4;
        }

        .config-tile.difficulty-easy.selected {
            background: #27ae60;
            border-color: #1e8449;
            box-shadow: 0 2px 6px rgba(39, 174, 96, 0.4);
        }

        .config-tile.difficulty-medium {
            background: #fef5e7;
            border-color: #e67e22;
        }

        .config-tile.difficulty-medium:hover {
            background: #fdebd0;
        }

        .config-tile.difficulty-medium.selected {
            background: #e67e22;
            border-color: #d35400;
            box-shadow: 0 2px 6px rgba(230, 126, 34, 0.4);
        }

        .config-tile.difficulty-hard {
            background: #fdedec;
            border-color: #e74c3c;
        }

        .config-tile.difficulty-hard:hover {
            background: #fadbd8;
        }

        .config-tile.difficulty-hard.selected {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 2px 6px rgba(231, 76, 60, 0.4);
        }

        /* Coin display for math problems */
        .coin {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
            margin: 0 8px;
            border: 4px solid rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 3px 6px rgba(255, 255, 255, 0.4), 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .coin.penny {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #cd7f32, #b87333);
            color: #3d2817;
            font-size: 1.1em;
            border-color: #8b5a2b;
        }

        .coin.nickel {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, #a8a8a8, #888888);
            color: #333;
            font-size: 1.1em;
            border-color: #666;
        }

        .coin.dime {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #d0d0d0, #b0b0b0);
            color: #333;
            font-size: 1.1em;
            border-color: #888;
        }

        .coin.quarter {
            width: 100px;
            height: 100px;
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
            color: #333;
            font-size: 1.3em;
            border-color: #999;
        }

        /* Dollar bill for making change mode */
        .dollar-bill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 180px;
            height: 100px;
            background: linear-gradient(145deg, #85bb65, #6b9b4f);
            color: #1a3d1a;
            font-weight: bold;
            font-size: 1.3em;
            border-radius: 8px;
            border: 4px solid #4a7c3a;
            box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.3), 0 3px 6px rgba(0, 0, 0, 0.2);
            margin-right: 8px;
            vertical-align: middle;
        }

        .change-minus {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
            margin: 0 10px;
            vertical-align: middle;
        }

        /* Dice display for math problems */
        .dice-display {
            font-size: 3em;
            letter-spacing: 12px;
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
        }

        /* Styled equals sign for visual math problems */
        .math-equals {
            font-size: 1.8em;
            margin-left: 12px;
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
            color: #2c3e50;
        }

        /* Problem text container for visual problems */
        #problemText {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* Castle selection */
        .castle-selection {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 30px 0;
        }

        .castle-option {
            padding: 20px;
            border: 3px solid transparent;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: #ecf0f1;
        }

        .castle-option:hover {
            transform: scale(1.05);
            background: #e8f4f8;
        }

        .castle-option.selected {
            border-color: #3498db;
            background: #e8f4f8;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .castle-preview {
            width: 150px;
            height: 150px;
            border-radius: 10px;
            border: 2px solid #34495e;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 60%, #3498db 100%);
        }

        .castle-name {
            margin-top: 10px;
            font-weight: bold;
            color: #2c3e50;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes needleOscillate {
            from { transform: translateX(-50%) rotate(85deg); }
            to { transform: translateX(-50%) rotate(95deg); }
        }

        .redline {
            background: #e74c3c !important;
            animation: needleOscillate 0.1s ease-in-out infinite alternate !important;
        }

        /* Gauge needles */
        #castleAngleNeedle, #castlePowerNeedle {
            transition: transform 0.15s ease-out;
        }

        /* Hidden utility class */
        .hidden {
            display: none !important;
        }

        /* Start button styles */
        .start-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 15px 30px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            margin: 20px 10px;
        }

        .start-button:hover {
            background: linear-gradient(145deg, #229954, #27ae60);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .games-grid {
                grid-template-columns: 1fr;
            }

            .hub-title {
                font-size: 2.5em;
            }

            .problem-display {
                font-size: 2em;
            }

            .answer-input {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <!-- Game Hub -->
    <div id="gameHub" class="container hub-container">
        <div class="hub-header">
            <h1 class="hub-title">üéØ Math Adventure Hub</h1>
            <p class="hub-subtitle">Choose your mathematical adventure!</p>
        </div>

        <div class="math-config-hub">
            <div class="config-row">
                <span class="config-label">Mode:</span>
                <div class="config-tiles" id="problemTypeTiles">
                    <div class="config-tile selected" data-value="addition" onclick="selectProblemType('addition')">‚ûï</div>
                    <div class="config-tile" data-value="subtraction" onclick="selectProblemType('subtraction')">‚ûñ</div>
                    <div class="config-tile" data-value="multiplication" onclick="selectProblemType('multiplication')">‚úñÔ∏è</div>
                    <div class="config-tile" data-value="division" onclick="selectProblemType('division')">‚ûó</div>
                    <div class="config-tile" data-value="dice" onclick="selectProblemType('dice')">üé≤</div>
                    <div class="config-tile" data-value="coin" onclick="selectProblemType('coin')">ü™ô</div>
                    <div class="config-tile" data-value="change" onclick="selectProblemType('change')">üíµ</div>
                    <div class="config-tile" data-value="fractions" onclick="selectProblemType('fractions')">¬Ω</div>
                </div>
            </div>
        </div>

        <div class="difficulty-config-hub">
            <div class="config-row">
                <span class="config-label">Difficulty:</span>
                <div class="config-tiles" id="difficultyTiles">
                    <div class="config-tile difficulty-easy selected" data-value="easy" onclick="selectDifficulty('easy')">Easy</div>
                    <div class="config-tile difficulty-medium" data-value="medium" onclick="selectDifficulty('medium')">Medium</div>
                    <div class="config-tile difficulty-hard" data-value="hard" onclick="selectDifficulty('hard')">Hard</div>
                </div>
            </div>
        </div>

        <div class="games-grid">
            <div class="game-card castle" onclick="selectGame('castle')">
                <div class="game-icon">üè∞</div>
                <div class="game-title">Math Castle</div>
                <div class="game-description">Defend your castle with cannon math! Solve problems to load cannons and defeat enemies.</div>
            </div>

            <div class="game-card express" onclick="selectGame('express')">
                <div class="game-icon">üöÇ</div>
                <div class="game-title">Math Express</div>
                <div class="game-description">All aboard the math train! Collect coal and steam to power your locomotive adventure.</div>
            </div>

            <div class="game-card miner" onclick="selectGame('miner')">
                <div class="game-icon">‚õèÔ∏è</div>
                <div class="game-title">Math Miner</div>
                <div class="game-description">Dig deep for treasure! Solve equations to power your mining equipment and find gold.</div>
            </div>

            <div class="game-card plane" onclick="selectGame('plane')">
                <div class="game-icon">‚úàÔ∏è</div>
                <div class="game-title">Math Plane</div>
                <div class="game-description">Soar through the sky! Use wind power from math problems to fly your paper airplane.</div>
            </div>

            <div class="game-card fieldgoal" onclick="selectGame('fieldgoal')">
                <div class="game-icon">üèà</div>
                <div class="game-title">Math Field Goals</div>
                <div class="game-description">Kick field goals! Solve problems to earn footballs and score through the uprights.</div>
            </div>
        </div>

        <div class="global-settings">
            <button class="sound-toggle" id="globalSoundToggle" onclick="toggleGlobalSound()">üîä</button>
        </div>
    </div>

    <!-- Shared Game Container (used by all games for common screens) -->
    <div id="sharedGameContainer" class="container game-container" style="display: none;">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Shared Selection Screen -->
        <div id="gameSelectionScreen" class="phase-transition" style="text-align: center; position: relative;">
            <button id="devModeBtn" onclick="startDevMode()" style="position: absolute; top: 10px; right: 10px; padding: 5px 8px; font-size: 0.7em; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; opacity: 0.7;">DEV</button>
            <h2 class="phase-title" id="selectionTitle">üè∞ Math Castle</h2>
            <p id="selectionPrompt">Choose the castle you will defend!</p>

            <div class="castle-selection">
                <div class="castle-option selected" id="option0" onclick="selectOption(0)">
                    <canvas class="castle-preview" id="preview0" width="150" height="150"></canvas>
                    <div class="castle-name" id="optionName0">Red Kingdom</div>
                </div>
                <div class="castle-option" id="option1" onclick="selectOption(1)">
                    <canvas class="castle-preview" id="preview1" width="150" height="150"></canvas>
                    <div class="castle-name" id="optionName1">Blue Kingdom</div>
                </div>
            </div>

            <button class="start-button" id="startGameBtn" onclick="startMathPhase()">Start!</button>
        </div>

        <!-- Shared Math Phase -->
        <div id="gameMathPhase" class="math-phase hidden" style="position: relative;">
            <button id="skipTimerBtn" onclick="skipMathTimer()" style="position: absolute; top: 10px; right: 10px; padding: 5px 8px; font-size: 0.7em; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; opacity: 0.7;">SKIP</button>
            <div class="phase-header">
                <h2 class="phase-title" id="mathPhaseTitle">üßÆ Math Battle - Round <span id="mathRoundNumber">1</span></h2>
                <div class="timer" id="mathTimer">60</div>
            </div>

            <div class="problem-display" id="problemDisplay">
                <div id="problemText">5 + 3 = ?</div>
                <div class="feedback-icon" id="feedbackIcon"></div>
            </div>

            <div class="input-section">
                <input type="text" class="answer-input" id="answerInput" readonly>

                <div class="numberpad">
                    <button onclick="addNumber('1')">1</button>
                    <button onclick="addNumber('2')">2</button>
                    <button onclick="addNumber('3')">3</button>
                    <button onclick="addNumber('4')">4</button>
                    <button onclick="addNumber('5')">5</button>
                    <button onclick="addNumber('6')">6</button>
                    <button onclick="addNumber('7')">7</button>
                    <button onclick="addNumber('8')">8</button>
                    <button onclick="addNumber('9')">9</button>
                    <button onclick="clearInput()" class="wide">Clear</button>
                    <button onclick="addNumber('0')">0</button>
                </div>
            </div>

            <div class="score-display">
                <div class="score-item">
                    <div><span id="resourceIcon">üî•</span> <span id="resourceName">Cannon Points</span>: <span id="resourceCount">0</span></div>
                    <div id="resourceDisplay" class="points-display"></div>
                </div>
            </div>
        </div>

        <!-- Shared Round Complete Screen -->
        <div id="roundCompleteScreen" class="phase-transition hidden" style="text-align: center;">
            <h2 class="phase-title" id="roundCompleteTitle" style="color: #27ae60; animation: bounce 0.5s ease-in-out infinite;">‚≠ê Nice Work! ‚≠ê</h2>
            <p>Round <span id="completedRoundNumber">1</span> Complete!</p>

            <div class="score-display" id="roundStats" style="flex-direction: column; gap: 15px; font-size: 1.3em; margin: 30px 0;">
                <!-- Populated dynamically -->
            </div>

            <button class="start-button" id="nextRoundBtn" onclick="startNextRound()">Next Round!</button>
        </div>

        <!-- Shared Game Over Screen -->
        <div id="gameOverScreen" class="phase-transition hidden" style="text-align: center;">
            <h2 class="phase-title" id="gameOverTitle" style="color: #e74c3c;">üè∞ Castle Fallen! üè∞</h2>

            <div class="score-display" id="gameOverStats" style="flex-direction: column; gap: 15px; font-size: 1.3em; margin: 30px 0;">
                <!-- Populated dynamically from config -->
            </div>

            <div style="display: flex; justify-content: center; gap: 15px;">
                <button class="start-button" id="playAgainBtn" onclick="playAgain()">Battle Again!</button>
                <button class="start-button" onclick="returnToHub()" style="background: linear-gradient(145deg, #95a5a6, #7f8c8d);">Return to Hub</button>
            </div>
        </div>
    </div>

    <!-- Math Castle Game -->
    <div id="castleGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Cannon Phase (Action Phase) -->
        <div id="castleCannonPhase" class="action-phase hidden" style="position: relative;">
            <div class="phase-header">
                <h2 class="phase-title">üè∞ Defend the Castle - Round <span id="castleCannonRound">1</span></h2>
                <div style="display: flex; justify-content: center; gap: 20px; font-size: 1.1em;">
                    <span>üí£ <span id="castleCannonCount">0</span></span>
                    <span>üéØ <span id="castleTargetsDisplay">0</span> targets</span>
                </div>
            </div>

            <canvas id="castleGameCanvas" class="game-canvas" width="800" height="400"></canvas>

            <!-- Gauges Row -->
            <div style="display: flex; justify-content: center; gap: 40px; margin: 15px 0;">
                <!-- Angle Gauge -->
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 120px; height: 65px; position: relative;">
                        <svg width="120" height="65" viewBox="0 0 120 65">
                            <!-- Quarter circle arc from right (0¬∞) to top (90¬∞) -->
                            <path d="M 110 55 A 50 50 0 0 0 60 5" stroke="#3498db" stroke-width="6" fill="none"/>
                            <circle cx="60" cy="55" r="5" fill="#2c3e50"/>
                        </svg>
                        <div id="castleAngleNeedle" style="position: absolute; bottom: 10px; left: 60px; transform-origin: bottom center; width: 3px; height: 45px; background: #2c3e50; transform: translateX(-50%) rotate(-45deg); border-radius: 2px;"></div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-weight: bold; font-size: 0.8em; color: #7f8c8d;">ANGLE</div>
                        <div id="castleAngleDisplay" style="font-weight: bold; color: #2c3e50;">45¬∞</div>
                    </div>
                </div>

                <!-- Power Gauge -->
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 120px; height: 60px; position: relative;">
                        <svg width="120" height="60" viewBox="0 0 120 60">
                            <!-- Red zone (low power) -->
                            <path d="M 10 50 A 50 50 0 0 1 43.3 10.4" stroke="#e74c3c" stroke-width="6" fill="none"/>
                            <!-- Yellow zone (medium power) -->
                            <path d="M 43.3 10.4 A 50 50 0 0 1 76.7 10.4" stroke="#f39c12" stroke-width="6" fill="none"/>
                            <!-- Green zone (high power) -->
                            <path d="M 76.7 10.4 A 50 50 0 0 1 110 50" stroke="#27ae60" stroke-width="6" fill="none"/>
                            <circle cx="60" cy="50" r="5" fill="#2c3e50"/>
                        </svg>
                        <div id="castlePowerNeedle" style="position: absolute; bottom: 10px; left: 60px; transform-origin: bottom center; width: 3px; height: 40px; background: #2c3e50; transform: translateX(-50%) rotate(0deg); border-radius: 2px;"></div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-weight: bold; font-size: 0.8em; color: #7f8c8d;">POWER</div>
                        <div id="castlePowerDisplay" style="font-weight: bold; color: #2c3e50;">50%</div>
                    </div>
                </div>
            </div>

            <!-- Buttons Row -->
            <div style="display: flex; justify-content: center; gap: 8px; margin: 10px 0; flex-wrap: wrap;">
                <button class="start-button" onclick="castleGame.fireCannon()" style="padding: 12px 25px; background: linear-gradient(145deg, #e74c3c, #c0392b);">
                    üéØ FIRE!
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(Space)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustAngle(3)" style="padding: 10px 15px;">
                    ‚ñ≤ UP
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üë)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustAngle(-3)" style="padding: 10px 15px;">
                    ‚ñº DOWN
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üì)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustPower(-5)" style="padding: 10px 15px;">
                    ‚óÄ LESS
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üê)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustPower(5)" style="padding: 10px 15px;">
                    ‚ñ∂ MORE
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üí)</span>
                </button>
            </div>

            <div style="text-align: center; font-size: 0.9em; color: #7f8c8d;">
                Aim with buttons or arrow keys. Fire with button or spacebar. Hit all targets!
            </div>
        </div>
    </div>

    <!-- Math Express Game -->
    <div id="expressGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Train Phase (Action Phase) -->
        <div id="expressTrainPhase" class="action-phase hidden" style="position: relative;">
            <div class="phase-header">
                <h2 class="phase-title">üöÇ Train Run - Round <span id="expressTrainRoundNumber">1</span></h2>
                <div style="font-size: 0.9em; color: #7f8c8d;">Total Distance: <span id="expressTotalDistance">0</span></div>
                <div style="font-size: 1em; color: #27ae60; font-weight: bold;">Next Station in: <span id="expressToStation">200</span></div>
            </div>

            <canvas id="expressGameCanvas" class="game-canvas" width="800" height="300"></canvas>

            <div class="action-info" style="gap: 20px;">
                <div>üî• <span id="expressSteamDisplay">0</span> Steam</div>
                <div>üìè <span id="expressDistanceDisplay">0</span></div>
            </div>

            <div style="display: flex; justify-content: center; gap: 20px; margin: 15px 0; align-items: center;">
                <button class="start-button" id="expressBoostButton" onclick="expressGame.boost()" style="padding: 12px 20px; background: linear-gradient(145deg, #27ae60, #2ecc71); display: flex; align-items: center; gap: 8px;">
                    <span>üöÄ</span>
                    <span style="display: flex; flex-direction: column; align-items: flex-start; line-height: 1.2;">
                        <span style="font-weight: bold;">STEAM</span>
                        <span style="font-size: 0.7em; opacity: 0.8;">(Space)</span>
                    </span>
                </button>

                <!-- Speedometer -->
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 100px; height: 50px; position: relative;">
                        <svg width="100" height="50" viewBox="0 0 100 50">
                            <!-- Red zone (slow) -->
                            <path d="M 10 45 A 40 40 0 0 1 33 12" stroke="#e74c3c" stroke-width="5" fill="none"/>
                            <!-- Yellow zone (medium) -->
                            <path d="M 33 12 A 40 40 0 0 1 67 12" stroke="#f39c12" stroke-width="5" fill="none"/>
                            <!-- Green zone (fast) -->
                            <path d="M 67 12 A 40 40 0 0 1 90 45" stroke="#27ae60" stroke-width="5" fill="none"/>
                            <!-- Center dot -->
                            <circle cx="50" cy="45" r="4" fill="#2c3e50"/>
                        </svg>
                        <div id="expressSpeedNeedle" style="position: absolute; bottom: 8px; left: 50%; transform-origin: bottom center; width: 2px; height: 32px; background: #2c3e50; transform: translateX(-50%) rotate(-90deg); transition: transform 0.1s ease-out; border-radius: 1px;"></div>
                    </div>
                    <div style="font-weight: bold; font-size: 0.7em; color: #2c3e50;">SPEED: <span id="expressSpeedDisplay">0</span></div>
                </div>

                <button class="start-button" id="expressBrakeButton" onclick="expressGame.brake()" style="padding: 12px 20px; background: linear-gradient(145deg, #e74c3c, #c0392b); display: flex; align-items: center; gap: 8px;">
                    <span>üõë</span>
                    <span style="display: flex; flex-direction: column; align-items: flex-start; line-height: 1.2;">
                        <span style="font-weight: bold;">BRAKE</span>
                        <span style="font-size: 0.7em; opacity: 0.8;">(Enter)</span>
                    </span>
                </button>
            </div>
        </div>
    </div>

    <!-- Math Miner Game -->
    <div id="minerGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Mining Phase (Action Phase) -->
        <div id="minerMiningPhase" class="action-phase hidden">
            <div class="phase-header">
                <h2 class="phase-title">‚õèÔ∏è Mining Time!</h2>
            </div>

            <canvas id="minerGameCanvas" class="game-canvas" width="512" height="384"></canvas>

            <div class="action-info">
                <div>‚õèÔ∏è <span id="minerDigRemaining">0</span> Dig Points</div>
                <div>ü™ô <span id="minerCoinsDisplay">0/3</span> Coins</div>
            </div>
        </div>
    </div>

    <!-- Math Plane Game -->
    <div id="planeGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Flight Phase (Action Phase) -->
        <div id="planeFlightPhase" class="action-phase hidden">
            <div class="phase-header">
                <h2 class="phase-title">‚úàÔ∏è Paper Plane Flight - Round <span id="planeFlightRoundNumber">1</span></h2>
            </div>

            <canvas id="planeGameCanvas" class="game-canvas" width="800" height="300"></canvas>

            <div class="action-info">
                <div>üí® <span id="planeWindRemaining">0</span> Wind Points</div>
                <div>üìè <span id="planeDistanceDisplay">0</span> Distance</div>
                <div>üéØ Target: <span id="planeTargetDisplay">200</span></div>
                <div>üìê Altitude: <span id="planeAltitudeDisplay">0</span>m</div>
            </div>

            <div id="planeLaunchIndicator" style="text-align: center; margin: 10px 0; color: #27ae60; font-weight: bold; animation: pulse 1s infinite;">
                Press SPACE to launch!
            </div>

            <div style="display: flex; justify-content: center; gap: 10px; margin: 15px 0;">
                <button class="start-button" onclick="planeGame.useWind()" style="padding: 8px 15px; background: linear-gradient(145deg, #3498db, #2980b9);">üí® WIND (Space)</button>
                <button class="start-button" onclick="planeGame.airBrake()" style="padding: 8px 15px; background: linear-gradient(145deg, #e74c3c, #c0392b);">üõë BRAKE (Enter)</button>
            </div>
        </div>
    </div>

    <!-- Field Goal Game Container -->
    <div id="fieldgoalGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Kick Phase (Action Phase) -->
        <div id="fieldgoalKickPhase" class="action-phase hidden">
            <div class="fieldgoal-game-area">
                <!-- Power Meter (vertical, on left side) -->
                <div class="power-meter-container" id="powerMeterContainer">
                    <div class="power-meter-label">POWER</div>
                    <div class="power-meter-bar">
                        <div class="power-meter-indicator" id="powerIndicator"></div>
                    </div>
                </div>

                <!-- Main Canvas -->
                <canvas id="fieldgoalCanvas" class="game-canvas" width="800" height="450"></canvas>
            </div>

            <!-- Direction Meter (horizontal, below canvas) -->
            <div class="direction-meter-container">
                <div class="direction-meter-bar">
                    <div class="direction-meter-indicator" id="directionIndicator"></div>
                </div>
                <div class="direction-meter-labels">
                    <span>LEFT</span>
                    <span>CENTER</span>
                    <span>RIGHT</span>
                </div>
            </div>

            <div class="kick-status" id="kickStatus">Press SPACE to set direction</div>
        </div>
    </div>

    <script>
        // Global Audio System
        const sounds = {
            enabled: true,
            audioContext: null,

            init() {
                if (typeof AudioContext !== 'undefined') {
                    this.audioContext = new AudioContext();
                }
            },

            playCorrect() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, this.audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, this.audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.5);
            },

            playIncorrect() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            },

            playButtonClick() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime + 0.05);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            },

            playDig() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'square';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime + 0.05);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            },

            playCoin() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(880, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(1100, this.audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(1320, this.audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.4);
            },

            playMove() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'triangle';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.08);
            },

            playWhoosh() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            },

            // Field Goal Game Sounds
            playWhistle() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Whistle sweep down
                oscillator.frequency.setValueAtTime(900, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.3);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.4);
            },

            playDoink() {
                if (!this.enabled || !this.audioContext) return;

                // Metallic clang sound
                const oscillator = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'triangle';
                oscillator2.type = 'sine';
                oscillator.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // High metallic frequencies
                oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                oscillator2.frequency.setValueAtTime(2400, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

                oscillator.start(this.audioContext.currentTime);
                oscillator2.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.5);
                oscillator2.stop(this.audioContext.currentTime + 0.5);
            },

            playCrowdCheer() {
                if (!this.enabled || !this.audioContext) return;

                // Create noise for crowd
                const bufferSize = this.audioContext.sampleRate * 0.8;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.5;
                }

                const noise = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();

                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 0.5;

                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                gainNode.gain.setValueAtTime(0.01, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.15, this.audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);

                noise.start(this.audioContext.currentTime);
                noise.stop(this.audioContext.currentTime + 0.8);
            },

            playCrowdGroan() {
                if (!this.enabled || !this.audioContext) return;

                // Low rumble for groan
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sawtooth';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.5);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.6);
            },

            playKick() {
                if (!this.enabled || !this.audioContext) return;

                // Thump sound for kick
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }
        };

        // Initialize audio when page loads
        sounds.init();

        // Resume audio context on first user interaction (browser autoplay policy)
        document.addEventListener('click', () => {
            if (sounds.audioContext && sounds.audioContext.state === 'suspended') {
                sounds.audioContext.resume();
            }
        }, { once: true });

        // Global sound toggle
        function toggleGlobalSound() {
            sounds.enabled = !sounds.enabled;
            const button = document.getElementById('globalSoundToggle');
            button.textContent = sounds.enabled ? 'üîä' : 'üîá';
            button.classList.toggle('muted', !sounds.enabled);
        }

        // Global Math Problem Generator
        const mathEngine = {
            // Fixed difficulty parameters (not affected by round)
            difficultyParams: {
                easy: { addMax: 10, multMax: 5, diceCount: 2, coinCount: 3, fracMax: 10 },
                medium: { addMax: 20, multMax: 10, diceCount: 3, coinCount: 4, fracMax: 20 },
                hard: { addMax: 50, multMax: 12, diceCount: 4, coinCount: 5, fracMax: 30 }
            },

            generateProblem(type, difficulty) {
                const params = this.difficultyParams[difficulty] || this.difficultyParams.easy;
                switch(type) {
                    case 'addition': return this.generateAddition(params);
                    case 'subtraction': return this.generateSubtraction(params);
                    case 'multiplication': return this.generateMultiplication(params);
                    case 'division': return this.generateDivision(params);
                    case 'dice': return this.generateDice(params);
                    case 'coin': return this.generateCoin(params);
                    case 'change': return this.generateChange(params);
                    case 'fractions': return this.generateFractions(params);
                    default: return this.generateAddition(params);
                }
            },

            generateAddition(params) {
                const a = Math.floor(Math.random() * params.addMax) + 1;
                const b = Math.floor(Math.random() * params.addMax) + 1;
                const answer = a + b;
                return { question: `${a} + ${b}`, answer, expectedDigits: answer.toString().length };
            },

            generateSubtraction(params) {
                let a = Math.floor(Math.random() * params.addMax) + 1;
                let b = Math.floor(Math.random() * params.addMax) + 1;
                if (b > a) [a, b] = [b, a]; // ensure non-negative result
                const answer = a - b;
                return { question: `${a} - ${b}`, answer, expectedDigits: Math.max(1, answer.toString().length) };
            },

            generateMultiplication(params) {
                const a = Math.floor(Math.random() * params.multMax) + 1;
                const b = Math.floor(Math.random() * params.multMax) + 1;
                const answer = a * b;
                return { question: `${a} √ó ${b}`, answer, expectedDigits: answer.toString().length };
            },

            generateDivision(params) {
                const divisors = params.multMax <= 5 ? [2, 5] :
                                 params.multMax <= 10 ? [2, 3, 4, 5] : [2, 3, 4, 5, 6, 7, 8, 9, 10];
                const b = divisors[Math.floor(Math.random() * divisors.length)];
                const quotient = Math.floor(Math.random() * params.multMax) + 1;
                const a = b * quotient; // ensures clean division
                return { question: `${a} √∑ ${b}`, answer: quotient, expectedDigits: quotient.toString().length };
            },

            generateDice(params) {
                const dice = [];
                for (let i = 0; i < params.diceCount; i++) {
                    dice.push(Math.floor(Math.random() * 6) + 1);
                }
                const sum = dice.reduce((a, b) => a + b, 0);
                const diceEmoji = dice.map(d => ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][d-1]).join(' ');
                const diceHTML = `<span class="dice-display">${diceEmoji}</span>`;
                return { question: diceHTML, answer: sum, expectedDigits: sum.toString().length, isHTML: true };
            },

            generateCoin(params) {
                const coinValues = [1, 5, 10, 25];
                const coins = [];
                const count = Math.floor(Math.random() * 2) + params.coinCount - 1;
                for (let i = 0; i < count; i++) {
                    coins.push(coinValues[Math.floor(Math.random() * coinValues.length)]);
                }
                const sum = coins.reduce((a, b) => a + b, 0);
                // Create HTML coin display with colored circles
                const coinHTML = coins.map(c => {
                    const coinClass = c === 1 ? 'penny' : c === 5 ? 'nickel' : c === 10 ? 'dime' : 'quarter';
                    return `<span class="coin ${coinClass}">${c}</span>`;
                }).join(' ');
                return { question: coinHTML, answer: sum, expectedDigits: sum.toString().length, isHTML: true };
            },

            generateChange(params) {
                // Generate coins that sum to 15-85 cents based on difficulty
                const coinValues = params.coinCount <= 3 ? [25, 10] :
                                   params.coinCount <= 4 ? [25, 10, 5] : [25, 10, 5, 1];
                const coins = [];
                const targetMin = params.coinCount <= 3 ? 15 : params.coinCount <= 4 ? 20 : 25;
                const targetMax = params.coinCount <= 3 ? 50 : params.coinCount <= 4 ? 70 : 85;

                // Generate coins until we're in target range
                let sum = 0;
                const maxCoins = params.coinCount + 1;
                while (coins.length < maxCoins && sum < targetMin) {
                    const coin = coinValues[Math.floor(Math.random() * coinValues.length)];
                    if (sum + coin <= targetMax) {
                        coins.push(coin);
                        sum += coin;
                    }
                }

                // Ensure we have at least some coins
                if (coins.length === 0) {
                    coins.push(25);
                    sum = 25;
                }

                const change = 100 - sum;

                // Create HTML with dollar bill, minus sign, and coins
                const coinHTML = coins.map(c => {
                    const coinClass = c === 1 ? 'penny' : c === 5 ? 'nickel' : c === 10 ? 'dime' : 'quarter';
                    return `<span class="coin ${coinClass}">${c}</span>`;
                }).join(' ');

                const changeHTML = `<span class="dollar-bill">100</span><span class="change-minus">‚àí</span>${coinHTML}`;
                return { question: changeHTML, answer: change, expectedDigits: change.toString().length, isHTML: true };
            },

            generateFractions(params) {
                const fractions = params.fracMax <= 10 ? [[1,2]] :
                                  params.fracMax <= 20 ? [[1,2], [1,4], [3,4]] : [[1,2], [1,3], [2,3], [1,4], [3,4]];
                const [num, den] = fractions[Math.floor(Math.random() * fractions.length)];
                const whole = den * (Math.floor(Math.random() * Math.floor(params.fracMax / den)) + 1);
                const answer = (whole * num) / den;
                return { question: `${num}/${den} of ${whole}`, answer, expectedDigits: answer.toString().length };
            }
        };

        // Global Game State Manager
        const gameManager = {
            currentGame: null,
            mathSettings: {
                problemType: 'addition',
                difficulty: 'easy'
            },
            gameStates: {
                castle: { round: 1, score: 0, phase: 'start', resources: 0, castleFlagColor: 'red', devMode: false, totalTargetsDestroyed: 0 },
                express: { round: 1, score: 0, phase: 'start', resources: 0, trainColor: 'red', devMode: false, totalDistance: 0 },
                miner: { round: 1, score: 0, phase: 'start', resources: 0, minerColor: 'red', devMode: false, totalCoinsCollected: 0 },
                plane: { round: 1, score: 0, phase: 'start', resources: 0, airplaneType: 'red', devMode: false, totalDistance: 0 },
                fieldgoal: { round: 1, score: 0, phase: 'start', resources: 0, teamColor: 'red', devMode: false, totalFieldGoalsMade: 0 }
            }
        };

        // Game Configuration Object - defines game-specific parameters for shared templates
        const gameConfigs = {
            castle: {
                id: 'castle',
                title: 'Math Castle',
                icon: 'üè∞',
                themeColor: '#e74c3c',

                selectionPrompt: 'Choose the castle you will defend!',
                options: [
                    { id: 'red', name: 'Red Kingdom', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Kingdom', color: '#3498db' }
                ],
                selectionKey: 'castleFlagColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniCastle(ctx, 75, 85, colorId);
                },

                mathTitle: 'Math Battle',
                resourceName: 'Cannon Points',
                resourceIcon: 'üî•',
                pointClass: 'cannon-point',

                actionPhaseId: 'castleCannonPhase',
                startAction: () => castleGame.showCannonPhase(),
                gameObject: () => castleGame,

                gameOverTitle: 'Castle Fallen!',
                gameOverIcon: 'üè∞',
                playAgainText: 'Battle Again!',
                startButtonText: 'Defend Castle!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalTargetsDestroyed', label: 'Targets Destroyed', color: '#e74c3c' }
                ]
            },

            express: {
                id: 'express',
                title: 'Math Express',
                icon: 'üöÇ',
                themeColor: '#e67e22',

                selectionPrompt: 'Choose your train to conduct!',
                options: [
                    { id: 'red', name: 'Red Express', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Express', color: '#3498db' }
                ],
                selectionKey: 'trainColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniTrain(ctx, 75, 85, colorId);
                },

                mathTitle: 'Math Station',
                resourceName: 'Steam Points',
                resourceIcon: 'üî•',
                pointClass: 'coal-point',

                actionPhaseId: 'expressTrainPhase',
                startAction: () => expressGame.showTrainPhase(),
                gameObject: () => expressGame,

                gameOverTitle: 'End of the Line!',
                gameOverIcon: 'üöÇ',
                playAgainText: 'Try Again!',
                startButtonText: 'All Aboard!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalDistance', label: 'Total Distance', color: '#27ae60' }
                ]
            },

            miner: {
                id: 'miner',
                title: 'Math Miner',
                icon: '‚õèÔ∏è',
                themeColor: '#8B4513',

                selectionPrompt: 'Choose your miner!',
                options: [
                    { id: 'red', name: 'Alex', color: '#e74c3c' },
                    { id: 'blue', name: 'Sam', color: '#3498db' }
                ],
                selectionKey: 'minerColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniMiner(ctx, 75, 85, colorId);
                },

                mathTitle: 'Math Mine',
                resourceName: 'Dig Points',
                resourceIcon: '‚õèÔ∏è',
                pointClass: 'dig-point',

                actionPhaseId: 'minerMiningPhase',
                startAction: () => minerGame.showMiningPhase(),
                gameObject: () => minerGame,

                gameOverTitle: 'Mining Complete!',
                gameOverIcon: '‚õ∞Ô∏è',
                playAgainText: 'Mine Again!',
                startButtonText: 'Start Mining!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalCoinsCollected', label: 'Total Coins', color: '#f1c40f' }
                ]
            },

            plane: {
                id: 'plane',
                title: 'Math Plane',
                icon: '‚úàÔ∏è',
                themeColor: '#3498db',

                selectionPrompt: 'Choose your paper airplane!',
                options: [
                    { id: 'red', name: 'Red Glider', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Flyer', color: '#3498db' }
                ],
                selectionKey: 'airplaneType',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniPlane(ctx, 75, 75, colorId);
                },

                mathTitle: 'Math Workshop',
                resourceName: 'Wind Points',
                resourceIcon: 'üí®',
                pointClass: 'wind-point',

                actionPhaseId: 'planeFlightPhase',
                startAction: () => planeGame.showFlightPhase(),
                gameObject: () => planeGame,

                gameOverTitle: 'Flight Ended!',
                gameOverIcon: '‚úàÔ∏è',
                playAgainText: 'Fly Again!',
                startButtonText: 'Take Flight!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalDistance', label: 'Total Distance', color: '#27ae60' }
                ]
            },

            fieldgoal: {
                id: 'fieldgoal',
                title: 'Math Field Goals',
                icon: 'üèà',
                themeColor: '#27ae60',

                selectionPrompt: 'Choose your team!',
                options: [
                    { id: 'red', name: 'Red Team', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Team', color: '#3498db' }
                ],
                selectionKey: 'teamColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniKicker(ctx, 75, 85, colorId);
                },

                mathTitle: 'Kick Practice',
                resourceName: 'Footballs',
                resourceIcon: 'üèà',
                pointClass: 'football-point',

                actionPhaseId: 'fieldgoalKickPhase',
                startAction: () => fieldgoalGame.showKickPhase(),
                gameObject: () => fieldgoalGame,

                gameOverTitle: 'Game Over!',
                gameOverIcon: 'üèà',
                playAgainText: 'Play Again!',
                startButtonText: 'Kick Off!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalFieldGoalsMade', label: 'Field Goals Made', color: '#f39c12' }
                ]
            }
        };

        // Current game type being played (used by shared functions)
        let currentGameType = null;
        let mathTimer = 60;
        let mathInterval = null;

        // ===== SHARED GAME FUNCTIONS =====

        // Show selection screen for a game
        function showSelectionScreen(gameType) {
            currentGameType = gameType;
            const config = gameConfigs[gameType];
            const state = gameManager.gameStates[gameType];

            // Hide hub, show shared container
            document.getElementById('gameHub').classList.remove('active');
            document.getElementById('gameHub').style.display = 'none';
            document.getElementById('sharedGameContainer').style.display = 'block';
            document.getElementById('sharedGameContainer').classList.add('active');

            // Show selection screen, hide others
            document.getElementById('gameSelectionScreen').classList.remove('hidden');
            document.getElementById('gameMathPhase').classList.add('hidden');
            document.getElementById('roundCompleteScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');

            // Populate from config
            document.getElementById('selectionTitle').innerHTML = `${config.icon} ${config.title}`;
            document.getElementById('selectionPrompt').textContent = config.selectionPrompt;
            document.getElementById('startGameBtn').textContent = config.startButtonText;

            // Setup options
            config.options.forEach((option, i) => {
                document.getElementById(`optionName${i}`).textContent = option.name;
                const canvas = document.getElementById(`preview${i}`);
                config.drawPreview(canvas, option.id);
            });

            // Highlight current selection
            updateSelectionHighlight();
        }

        // Handle option selection
        function selectOption(index) {
            sounds.playButtonClick();
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            state[config.selectionKey] = config.options[index].id;
            updateSelectionHighlight();
        }

        // Select problem type tile
        function selectProblemType(type) {
            sounds.playButtonClick();
            gameManager.mathSettings.problemType = type;

            // Update tile selection visual
            document.querySelectorAll('#problemTypeTiles .config-tile').forEach(tile => {
                tile.classList.toggle('selected', tile.dataset.value === type);
            });
        }

        // Select difficulty tile
        function selectDifficulty(difficulty) {
            sounds.playButtonClick();
            gameManager.mathSettings.difficulty = difficulty;

            // Update tile selection visual
            document.querySelectorAll('#difficultyTiles .config-tile').forEach(tile => {
                tile.classList.toggle('selected', tile.dataset.value === difficulty);
            });
        }

        // Update selection highlight based on current state
        function updateSelectionHighlight() {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];
            const currentSelection = state[config.selectionKey];

            config.options.forEach((option, i) => {
                const optionEl = document.getElementById(`option${i}`);
                if (option.id === currentSelection) {
                    optionEl.classList.add('selected');
                } else {
                    optionEl.classList.remove('selected');
                }
            });
        }

        // Start dev mode (skip math phase)
        function startDevMode() {
            sounds.playButtonClick();
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            state.devMode = true;
            state.resources = 10;  // Give some resources for testing
            state.phase = 'action';

            // Initialize the game object
            const gameObj = config.gameObject();
            if (gameObj && gameObj.init) {
                gameObj.init();
            }

            // Hide shared container, show game-specific container
            document.getElementById('sharedGameContainer').style.display = 'none';
            document.getElementById('sharedGameContainer').classList.remove('active');

            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.add('active');
            gameElement.style.display = 'block';

            config.startAction();
        }

        // Start the math phase
        function startMathPhase() {
            sounds.playButtonClick();
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            // Initialize game object if needed
            const gameObj = config.gameObject();
            if (gameObj && gameObj.init) {
                gameObj.init();
            }

            state.phase = 'math';
            // Only reset resources on round 1; preserve bonus resources from previous rounds
            if (state.round === 1) {
                state.resources = 0;
            }

            // Hide selection, show math phase
            document.getElementById('gameSelectionScreen').classList.add('hidden');
            document.getElementById('gameMathPhase').classList.remove('hidden');

            // Populate from config
            document.getElementById('mathPhaseTitle').innerHTML =
                `üßÆ ${config.mathTitle} - Round <span id="mathRoundNumber">${state.round}</span>`;
            document.getElementById('resourceIcon').textContent = config.resourceIcon;
            document.getElementById('resourceName').textContent = config.resourceName;
            document.getElementById('answerInput').value = '';

            // Initialize timer
            mathTimer = 60;
            updateSharedTimerDisplay();

            if (mathInterval) clearInterval(mathInterval);
            mathInterval = setInterval(() => {
                mathTimer--;
                updateSharedTimerDisplay();
                if (mathTimer <= 0) {
                    endSharedMathPhase();
                }
            }, 1000);

            generateSharedProblem();
            updateResourceDisplay();
        }

        // Update timer display
        function updateSharedTimerDisplay() {
            document.getElementById('mathTimer').textContent = mathTimer;
        }

        // Skip math timer (dev mode only)
        function skipMathTimer() {
            sounds.playButtonClick();
            mathTimer = 0;
            updateSharedTimerDisplay();
        }

        // Generate new problem
        function generateSharedProblem() {
            const state = gameManager.gameStates[currentGameType];
            const { problemType, difficulty } = gameManager.mathSettings;
            state.currentProblem = mathEngine.generateProblem(problemType, difficulty);
            const problemEl = document.getElementById('problemText');
            if (state.currentProblem.isHTML) {
                problemEl.innerHTML = `${state.currentProblem.question}<span class="math-equals">= ?</span>`;
            } else {
                problemEl.textContent = `${state.currentProblem.question} = ?`;
            }
        }

        // End math phase, transition to action
        function endSharedMathPhase() {
            if (mathInterval) {
                clearInterval(mathInterval);
                mathInterval = null;
            }

            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];
            state.phase = 'action';

            // Hide shared container's math phase
            document.getElementById('gameMathPhase').classList.add('hidden');

            // Hide shared container, show game-specific container for action phase
            document.getElementById('sharedGameContainer').style.display = 'none';
            document.getElementById('sharedGameContainer').classList.remove('active');

            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.add('active');
            gameElement.style.display = 'block';

            // Start the action phase
            config.startAction();
        }

        // Shared number pad input
        function addNumber(num) {
            sounds.playButtonClick();
            const input = document.getElementById('answerInput');
            if (input.value.length < 4) {
                input.value += num;

                // Auto-submit when answer has enough digits
                const state = gameManager.gameStates[currentGameType];
                if (state && state.currentProblem && input.value.length >= state.currentProblem.expectedDigits) {
                    setTimeout(() => submitSharedAnswer(), 100);
                }
            }
        }

        // Clear input
        function clearInput() {
            sounds.playButtonClick();
            document.getElementById('answerInput').value = '';
        }

        // Submit answer
        function submitSharedAnswer() {
            const state = gameManager.gameStates[currentGameType];
            const config = gameConfigs[currentGameType];
            const input = document.getElementById('answerInput');
            const userAnswer = parseInt(input.value);

            if (isNaN(userAnswer)) return;

            if (userAnswer === state.currentProblem.answer) {
                showSharedFeedback(true);
                state.resources++;
                state.score++;
                updateResourceDisplay(true);

                setTimeout(() => {
                    generateSharedProblem();
                    input.value = '';
                    clearSharedFeedback();
                }, 800);
            } else {
                showSharedFeedback(false);
                setTimeout(() => {
                    input.value = '';
                    clearSharedFeedback();
                }, 800);
            }
        }

        // Show feedback
        function showSharedFeedback(isCorrect) {
            const problemDisplay = document.getElementById('problemDisplay');
            const feedbackIcon = document.getElementById('feedbackIcon');
            const problemText = document.getElementById('problemText');

            if (isCorrect) {
                sounds.playCorrect();
                problemDisplay.classList.add('correct');
                feedbackIcon.textContent = '‚úì';
                feedbackIcon.className = 'feedback-icon show correct';

                const state = gameManager.gameStates[currentGameType];
                if (state.currentProblem.isHTML) {
                    problemText.innerHTML = `${state.currentProblem.question}<span class="math-equals">= ${state.currentProblem.answer}</span>`;
                } else {
                    problemText.textContent = `${state.currentProblem.question} = ${state.currentProblem.answer}`;
                }
            } else {
                sounds.playIncorrect();
                problemDisplay.classList.add('incorrect');
                feedbackIcon.textContent = '‚úó';
                feedbackIcon.className = 'feedback-icon show incorrect';
            }
        }

        // Clear feedback
        function clearSharedFeedback() {
            const problemDisplay = document.getElementById('problemDisplay');
            const feedbackIcon = document.getElementById('feedbackIcon');
            problemDisplay.classList.remove('correct', 'incorrect');
            feedbackIcon.classList.remove('show');
        }

        // Update resource display
        function updateResourceDisplay(animate = false) {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            document.getElementById('resourceCount').textContent = state.resources;
            updatePointsDisplay('resourceDisplay', state.resources, config.pointClass, animate);
        }

        // Show round complete screen
        function showRoundComplete(roundStats = {}) {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            // Hide game container, show shared container
            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.remove('active');
            gameElement.style.display = 'none';

            document.getElementById('sharedGameContainer').style.display = 'block';
            document.getElementById('sharedGameContainer').classList.add('active');
            document.getElementById('roundCompleteScreen').classList.remove('hidden');

            // Populate round number
            document.getElementById('completedRoundNumber').textContent = state.round;

            // Populate round-specific stats
            const statsContainer = document.getElementById('roundStats');
            statsContainer.innerHTML = '';
            Object.entries(roundStats).forEach(([label, value]) => {
                const div = document.createElement('div');
                div.innerHTML = `${label}: <span style="color: #27ae60; font-weight: bold;">${value}</span>`;
                statsContainer.appendChild(div);
            });
        }

        // Start next round
        function startNextRound() {
            sounds.playButtonClick();
            const state = gameManager.gameStates[currentGameType];
            state.round++;

            document.getElementById('roundCompleteScreen').classList.add('hidden');
            startMathPhase();
        }

        // Show game over screen
        function showGameOver() {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            // Hide game container, show shared container
            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.remove('active');
            gameElement.style.display = 'none';

            document.getElementById('sharedGameContainer').style.display = 'block';
            document.getElementById('sharedGameContainer').classList.add('active');
            document.getElementById('gameOverScreen').classList.remove('hidden');

            // Populate title
            document.getElementById('gameOverTitle').innerHTML =
                `${config.gameOverIcon} ${config.gameOverTitle} ${config.gameOverIcon}`;
            document.getElementById('gameOverTitle').style.color = config.themeColor;

            // Populate stats
            const statsContainer = document.getElementById('gameOverStats');
            statsContainer.innerHTML = '';
            config.stats.forEach(stat => {
                const value = state[stat.key] || 0;
                const div = document.createElement('div');
                div.innerHTML = `${stat.label}: <span style="color: ${stat.color}; font-weight: bold;">${value}</span>`;
                statsContainer.appendChild(div);
            });

            // Update play again button text
            document.getElementById('playAgainBtn').textContent = config.playAgainText;
        }

        // Play again - reset and go to selection
        function playAgain() {
            sounds.playButtonClick();
            resetSharedGameState();

            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('gameSelectionScreen').classList.remove('hidden');

            // Redraw previews
            const config = gameConfigs[currentGameType];
            config.options.forEach((option, i) => {
                const canvas = document.getElementById(`preview${i}`);
                config.drawPreview(canvas, option.id);
            });
            updateSelectionHighlight();
        }

        // Reset game state for current game
        function resetSharedGameState() {
            const state = gameManager.gameStates[currentGameType];
            const config = gameConfigs[currentGameType];

            state.round = 1;
            state.score = 0;
            state.resources = 0;
            state.phase = 'start';
            state.devMode = false;

            // Reset game-specific stats
            if (currentGameType === 'castle') state.totalTargetsDestroyed = 0;
            if (currentGameType === 'express') state.totalDistance = 0;
            if (currentGameType === 'miner') state.totalCoinsCollected = 0;
            if (currentGameType === 'plane') state.totalDistance = 0;
        }

        // ===== END SHARED GAME FUNCTIONS =====

        // Hub Navigation - now uses shared selection screen
        function selectGame(gameType) {
            gameManager.currentGame = gameType;
            showSelectionScreen(gameType);
        }

        function returnToHub() {
            sounds.playButtonClick();

            // Clear any running timer
            if (mathInterval) {
                clearInterval(mathInterval);
                mathInterval = null;
            }

            // Stop all game loops
            castleGame.gameRunning = false;
            expressGame.gameRunning = false;
            minerGame.miningRunning = false;
            planeGame.flightRunning = false;
            fieldgoalGame.gameRunning = false;

            // Hide shared container
            document.getElementById('sharedGameContainer').classList.remove('active');
            document.getElementById('sharedGameContainer').style.display = 'none';

            // Hide current game container
            if (gameManager.currentGame) {
                const gameElement = document.getElementById(gameManager.currentGame + 'Game');
                if (gameElement) {
                    gameElement.classList.remove('active');
                    gameElement.style.display = 'none';
                }

                // Reset game state
                resetSharedGameState();
            }

            // Show hub
            document.getElementById('gameHub').style.display = 'block';
            document.getElementById('gameHub').classList.add('active');
            gameManager.currentGame = null;
            currentGameType = null;
        }

        // Shared function for visual point displays with gap for grouping by 5s
        function updatePointsDisplay(displayId, points, pointClass, animate = false) {
            const display = document.getElementById(displayId);
            if (!display) return;

            display.innerHTML = '';

            const large = Math.floor(points / 10);
            const small = points % 10;

            // Add large (10-point) blocks
            for (let i = 0; i < large; i++) {
                const block = document.createElement('div');
                block.className = `${pointClass}-large`;
                if (!animate) block.style.animation = 'none';
                display.appendChild(block);
            }

            // Add small (1-point) blocks with gap after 5th
            for (let i = 0; i < small; i++) {
                const block = document.createElement('div');
                block.className = pointClass;
                if (i === 5) block.classList.add('point-gap');  // Gap after 5th point
                if (!animate) block.style.animation = 'none';
                display.appendChild(block);
            }
        }

        function updateScore(gameType) {
            const state = gameManager.gameStates[gameType];

            // Update visual displays
            switch(gameType) {
                case 'castle':
                    castleGame.updateCannonDisplay();
                    break;
                case 'express':
                    expressGame.updateCoalDisplay();
                    break;
                case 'miner':
                    minerGame.updateDigDisplay();
                    break;
                case 'plane':
                    planeGame.updateWindDisplay();
                    break;
            }
        }

        // Mini Drawing Functions (used by gameConfigs)
        function drawMiniCastle(ctx, x, y, flagColor) {
            const scale = 0.6;

            // Castle base
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(x - 30 * scale, y - 20 * scale, 60 * scale, 40 * scale);

            // Towers
            ctx.fillRect(x - 35 * scale, y - 40 * scale, 20 * scale, 60 * scale);
            ctx.fillRect(x + 15 * scale, y - 40 * scale, 20 * scale, 60 * scale);
            ctx.fillRect(x - 10 * scale, y - 50 * scale, 20 * scale, 70 * scale);

            // Tower tops
            ctx.fillStyle = '#34495e';
            ctx.beginPath();
            ctx.moveTo(x - 40 * scale, y - 40 * scale);
            ctx.lineTo(x - 25 * scale, y - 55 * scale);
            ctx.lineTo(x - 10 * scale, y - 40 * scale);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x + 10 * scale, y - 40 * scale);
            ctx.lineTo(x + 25 * scale, y - 55 * scale);
            ctx.lineTo(x + 40 * scale, y - 40 * scale);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x - 15 * scale, y - 50 * scale);
            ctx.lineTo(x, y - 65 * scale);
            ctx.lineTo(x + 15 * scale, y - 50 * scale);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = '#f39c12';
            ctx.fillRect(x - 25 * scale, y - 10 * scale, 5 * scale, 8 * scale);
            ctx.fillRect(x + 20 * scale, y - 10 * scale, 5 * scale, 8 * scale);
            ctx.fillRect(x - 3 * scale, y - 20 * scale, 6 * scale, 8 * scale);

            // Gate
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 8 * scale, y + 5 * scale, 16 * scale, 15 * scale);
            ctx.beginPath();
            ctx.arc(x, y + 5 * scale, 8 * scale, 0, Math.PI, true);
            ctx.fill();

            // Flag
            drawMiniFlag(ctx, x, y - 65 * scale, flagColor, scale);
        }

        function drawMiniFlag(ctx, x, y, color, scale) {
            // Flag pole
            ctx.fillStyle = '#34495e';
            ctx.fillRect(x - 1, y - 20 * scale, 2, 25 * scale);

            // Flag ball on top
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y - 22 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Flag
            ctx.fillStyle = color === 'red' ? '#e74c3c' : '#3498db';
            ctx.beginPath();
            ctx.moveTo(x + 1, y - 20 * scale);
            ctx.lineTo(x + 20 * scale, y - 17 * scale);
            ctx.lineTo(x + 20 * scale, y - 7 * scale);
            ctx.lineTo(x + 1, y - 10 * scale);
            ctx.closePath();
            ctx.fill();
        }

        function drawMiniTrain(ctx, x, y, color) {
            const trainColor = color === 'red' ? '#e74c3c' : '#3498db';
            const scale = 1.2;

            // Engine body
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 25 * scale, y - 15 * scale, 50 * scale, 22 * scale);

            // Cab
            ctx.fillStyle = trainColor;
            ctx.fillRect(x - 30 * scale, y - 25 * scale, 25 * scale, 25 * scale);

            // Smokestack
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 10 * scale, y - 30 * scale, 8 * scale, 15 * scale);
            ctx.fillRect(x + 7 * scale, y - 33 * scale, 14 * scale, 6 * scale);

            // Windows
            ctx.fillStyle = '#5dade2';
            ctx.fillRect(x - 26 * scale, y - 20 * scale, 8 * scale, 8 * scale);
            ctx.fillRect(x - 16 * scale, y - 20 * scale, 8 * scale, 8 * scale);

            // Cow catcher
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.moveTo(x + 25 * scale, y + 5 * scale);
            ctx.lineTo(x + 33 * scale, y + 12 * scale);
            ctx.lineTo(x + 25 * scale, y + 12 * scale);
            ctx.closePath();
            ctx.fill();

            // Wheels
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(x - 15 * scale, y + 12 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5 * scale, y + 12 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 20 * scale, y + 12 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Wheel highlights
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.arc(x - 15 * scale, y + 12 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5 * scale, y + 12 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 20 * scale, y + 12 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Smoke puffs
            ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.beginPath();
            ctx.arc(x + 14 * scale, y - 40 * scale, 6 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8 * scale, y - 50 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 18 * scale, y - 55 * scale, 5 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMiniPlane(ctx, x, y, color) {
            const planeColor = color === 'red' ? '#e74c3c' : '#3498db';
            const accentColor = color === 'red' ? '#c0392b' : '#2980b9';
            const scale = 3;

            ctx.save();
            ctx.translate(x, y);

            // Main body (fuselage)
            ctx.fillStyle = planeColor;
            ctx.beginPath();
            ctx.moveTo(20 * scale, 0);
            ctx.lineTo(-15 * scale, -3 * scale);
            ctx.lineTo(-20 * scale, 0);
            ctx.lineTo(-15 * scale, 3 * scale);
            ctx.closePath();
            ctx.fill();

            // Nose cone
            ctx.fillStyle = accentColor;
            ctx.beginPath();
            ctx.moveTo(20 * scale, 0);
            ctx.lineTo(15 * scale, -2 * scale);
            ctx.lineTo(15 * scale, 2 * scale);
            ctx.closePath();
            ctx.fill();

            // Main wing
            ctx.fillStyle = planeColor;
            ctx.beginPath();
            ctx.moveTo(5 * scale, 0);
            ctx.lineTo(-5 * scale, -15 * scale);
            ctx.lineTo(-10 * scale, -15 * scale);
            ctx.lineTo(-5 * scale, 0);
            ctx.lineTo(-10 * scale, 15 * scale);
            ctx.lineTo(-5 * scale, 15 * scale);
            ctx.closePath();
            ctx.fill();

            // Wing stripe
            ctx.fillStyle = accentColor;
            ctx.fillRect(-8 * scale, -12 * scale, 2 * scale, 24 * scale);

            // Tail fin (vertical)
            ctx.fillStyle = planeColor;
            ctx.beginPath();
            ctx.moveTo(-15 * scale, 0);
            ctx.lineTo(-20 * scale, -8 * scale);
            ctx.lineTo(-22 * scale, -8 * scale);
            ctx.lineTo(-20 * scale, 0);
            ctx.closePath();
            ctx.fill();

            // Tail fin (horizontal)
            ctx.beginPath();
            ctx.moveTo(-15 * scale, 0);
            ctx.lineTo(-20 * scale, -4 * scale);
            ctx.lineTo(-22 * scale, -4 * scale);
            ctx.lineTo(-22 * scale, 4 * scale);
            ctx.lineTo(-20 * scale, 4 * scale);
            ctx.closePath();
            ctx.fill();

            // Cockpit window
            ctx.fillStyle = '#5dade2';
            ctx.beginPath();
            ctx.ellipse(10 * scale, 0, 4 * scale, 2 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            // Window shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.ellipse(11 * scale, -0.5 * scale, 2 * scale, 1 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Motion lines
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x - 25 * scale - i * 8, y - 5 + i * 5);
                ctx.lineTo(x - 35 * scale - i * 8, y - 5 + i * 5);
                ctx.stroke();
            }
        }

        function drawMiniMiner(ctx, x, y, color) {
            const bodyColor = color === 'red' ? '#e74c3c' : '#3498db';
            const scale = 2.5;

            // Hard hat
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.ellipse(x, y - 20 * scale, 10 * scale, 6 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(x - 8 * scale, y - 22 * scale, 16 * scale, 8 * scale);

            // Hat light
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath();
            ctx.arc(x, y - 24 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Face
            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(x, y - 10 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(x - 3 * scale, y - 12 * scale, 1.5 * scale, 0, Math.PI * 2);
            ctx.arc(x + 3 * scale, y - 12 * scale, 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x, y - 8 * scale, 3 * scale, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Body (colored)
            ctx.fillStyle = bodyColor;
            ctx.fillRect(x - 8 * scale, y - 2 * scale, 16 * scale, 18 * scale);

            // Arms
            ctx.fillRect(x - 12 * scale, y, 4 * scale, 12 * scale);
            ctx.fillRect(x + 8 * scale, y, 4 * scale, 12 * scale);

            // Hands
            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(x - 10 * scale, y + 14 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.arc(x + 10 * scale, y + 14 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#5d4e37';
            ctx.fillRect(x - 6 * scale, y + 16 * scale, 5 * scale, 10 * scale);
            ctx.fillRect(x + 1 * scale, y + 16 * scale, 5 * scale, 10 * scale);

            // Boots
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 7 * scale, y + 24 * scale, 6 * scale, 4 * scale);
            ctx.fillRect(x + 1 * scale, y + 24 * scale, 6 * scale, 4 * scale);

            // Pickaxe
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 15 * scale, y - 5 * scale);
            ctx.lineTo(x + 25 * scale, y + 15 * scale);
            ctx.stroke();

            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.moveTo(x + 13 * scale, y - 8 * scale);
            ctx.lineTo(x + 20 * scale, y - 2 * scale);
            ctx.lineTo(x + 17 * scale, y - 5 * scale);
            ctx.lineTo(x + 10 * scale, y - 5 * scale);
            ctx.closePath();
            ctx.fill();
        }

        function drawMiniKicker(ctx, x, y, color) {
            const kickerColor = color === 'red' ? '#e74c3c' : '#3498db';
            const scale = 2;

            // Draw mini field
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(x - 50, y + 20, 100, 35);

            // Draw goal posts
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 3;
            ctx.beginPath();
            // Left post
            ctx.moveTo(x + 25, y + 20);
            ctx.lineTo(x + 25, y - 20);
            // Right post
            ctx.moveTo(x + 45, y + 20);
            ctx.lineTo(x + 45, y - 20);
            // Crossbar
            ctx.moveTo(x + 25, y - 20);
            ctx.lineTo(x + 45, y - 20);
            ctx.stroke();

            // Upper extensions
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 25, y - 20);
            ctx.lineTo(x + 25, y - 30);
            ctx.moveTo(x + 45, y - 20);
            ctx.lineTo(x + 45, y - 30);
            ctx.stroke();

            // Draw kicker
            // Body
            ctx.fillStyle = kickerColor;
            ctx.fillRect(x - 30, y - 5, 15, 25);

            // Head
            ctx.fillStyle = '#fdbf6f';
            ctx.beginPath();
            ctx.arc(x - 22, y - 12, 8, 0, Math.PI * 2);
            ctx.fill();

            // Helmet
            ctx.fillStyle = kickerColor;
            ctx.beginPath();
            ctx.arc(x - 22, y - 14, 9, Math.PI, 0);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 28, y + 20, 5, 12);
            // Kicking leg
            ctx.save();
            ctx.translate(x - 20, y + 20);
            ctx.rotate(-0.6);
            ctx.fillRect(0, 0, 5, 15);
            ctx.restore();

            // Draw football in flight
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(x + 5, y - 5, 10, 6, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Laces on football
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x + 2, y - 5);
            ctx.lineTo(x + 8, y - 5);
            ctx.stroke();
        }


        // Global keyboard handler
        function handleGlobalKeyPress(e) {
            // Handle Enter key for action buttons (green buttons like Next Round, Play Again, Start)
            if (e.key === 'Enter') {
                // Check for visible action buttons in priority order
                const actionButtons = [
                    document.getElementById('nextRoundBtn'),      // Next Round
                    document.getElementById('playAgainBtn'),      // Play Again
                    document.getElementById('startGameBtn'),      // Start Game
                    document.getElementById('submitAnswer')       // Submit Math Answer
                ];

                for (const btn of actionButtons) {
                    if (btn && btn.offsetParent !== null && !btn.closest('.hidden')) {
                        e.preventDefault();
                        btn.click();
                        return;
                    }
                }
            }

            if (!gameManager.currentGame && !currentGameType) return;

            const currentGame = currentGameType || gameManager.currentGame;
            const state = gameManager.gameStates[currentGame];

            if (state.phase === 'math') {
                if (e.key >= '0' && e.key <= '9') {
                    // Use shared input system (addNumber handles sound and auto-submit)
                    addNumber(e.key);
                } else if (e.key === 'Backspace' || e.key === 'Delete') {
                    clearInput();
                }
            } else if (currentGame === 'castle' && state.phase === 'cannon') {
                castleGame.handleCannonKeyPress(e);
            } else if (currentGame === 'express' && state.phase === 'train') {
                expressGame.handleTrainKeyPress(e);
            } else if (currentGame === 'miner' && state.phase === 'mining') {
                minerGame.handleMiningKeyPress(e);
            } else if (currentGame === 'plane' && state.phase === 'flight') {
                planeGame.handleFlightKeyPress(e);
            }
        }

        // Add keyboard listener
        document.addEventListener('keydown', handleGlobalKeyPress);

        // === MINER GAME MODULE ===
        const minerGame = {
            canvas: null,
            ctx: null,
            GRID_WIDTH: 16,
            GRID_HEIGHT: 12,
            BLOCK_SIZE: 32,
            TERRAIN_TYPES: { AIR: 0, GRASS: 1, DIRT: 2, COIN: 3 },
            terrain: [],
            coinPositions: [],
            particles: [],
            playerPosition: { x: 8, y: 3 },
            miningRunning: false,
            mathTimer: 60,
            mathInterval: null,
            roundCoinsCollected: 0,
            totalCoins: 3,

            init() {
                this.canvas = document.getElementById('minerGameCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                    this.ctx.imageSmoothingEnabled = false;
                }
            },

            updateDigDisplay(animate = false) {
                const state = gameManager.gameStates.miner;
                const pointsEl = document.getElementById('minerDigPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('minerDigDisplay', state.resources, 'dig-point', animate);
            },

            addDigPoint() {
                this.updateDigDisplay(true);
            },

            showMiningPhase() {
                const state = gameManager.gameStates.miner;
                state.phase = 'mining';

                // Show mining phase (container switching is handled by shared system)
                document.getElementById('minerMiningPhase').classList.remove('hidden');

                this.startMining();
            },

            startMining() {
                const state = gameManager.gameStates.miner;
                this.roundCoinsCollected = 0;
                this.totalCoins = Math.min(3 + state.round - 1, 8);
                this.playerPosition = { x: 8, y: 3 };
                this.particles = [];

                this.generateTerrain(state.round);
                this.updateMiningDisplay();
                this.miningRunning = true;
                this.gameLoop();
            },

            generateTerrain(round) {
                this.terrain = [];
                this.coinPositions = [];

                // Initialize grid
                for (let y = 0; y < this.GRID_HEIGHT; y++) {
                    this.terrain[y] = [];
                    for (let x = 0; x < this.GRID_WIDTH; x++) {
                        if (y < 4) {
                            this.terrain[y][x] = this.TERRAIN_TYPES.AIR;
                        } else if (y === 4) {
                            this.terrain[y][x] = this.TERRAIN_TYPES.GRASS;
                        } else {
                            this.terrain[y][x] = this.TERRAIN_TYPES.DIRT;
                        }
                    }
                }

                // Place coins based on round
                if (round === 1) {
                    this.placeCoin(8, 6);
                    this.placeCoin(8, 8);
                    this.placeCoin(8, 10);
                } else if (round === 2) {
                    this.placeCoin(8, 6);
                    this.placeCoin(8, 8);
                    this.placeCoin(10, 8);
                    this.placeCoin(12, 8);
                } else if (round === 3) {
                    this.placeCoin(4, 7);
                    this.placeCoin(8, 9);
                    this.placeCoin(12, 7);
                    this.placeCoin(6, 11);
                    this.placeCoin(10, 11);
                } else {
                    // Random placement for later rounds
                    const numCoins = Math.min(5 + (round - 3), 8);
                    let placed = 0;
                    while (placed < numCoins) {
                        const x = 2 + Math.floor(Math.random() * 10);
                        const y = 6 + Math.floor(Math.random() * 5);
                        if (this.terrain[y][x] === this.TERRAIN_TYPES.DIRT) {
                            this.placeCoin(x, y);
                            placed++;
                        }
                    }
                }
            },

            placeCoin(x, y) {
                this.terrain[y][x] = this.TERRAIN_TYPES.COIN;
                this.coinPositions.push({ x, y });
            },

            movePlayer(dx, dy) {
                const state = gameManager.gameStates.miner;
                const newX = this.playerPosition.x + dx;
                const newY = this.playerPosition.y + dy;

                // Bounds check
                if (newX < 0 || newX >= this.GRID_WIDTH || newY < 0 || newY >= this.GRID_HEIGHT) {
                    return;
                }

                const targetTerrain = this.terrain[newY][newX];

                if (targetTerrain === this.TERRAIN_TYPES.AIR) {
                    // Free movement
                    this.playerPosition.x = newX;
                    this.playerPosition.y = newY;
                    sounds.playMove();
                } else if (targetTerrain === this.TERRAIN_TYPES.GRASS || targetTerrain === this.TERRAIN_TYPES.DIRT) {
                    // Need to dig
                    if (state.resources > 0) {
                        state.resources--;
                        this.digBlock(newX, newY);
                        this.playerPosition.x = newX;
                        this.playerPosition.y = newY;
                        sounds.playDig();
                        this.updateMiningDisplay();
                    } else {
                        sounds.playIncorrect();
                    }
                } else if (targetTerrain === this.TERRAIN_TYPES.COIN) {
                    // Collect coin
                    this.collectCoin(newX, newY);
                    this.playerPosition.x = newX;
                    this.playerPosition.y = newY;
                }
            },

            digBlock(x, y) {
                this.terrain[y][x] = this.TERRAIN_TYPES.AIR;

                // Create particles
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x * this.BLOCK_SIZE + this.BLOCK_SIZE / 2,
                        y: y * this.BLOCK_SIZE + this.BLOCK_SIZE / 2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3 - 1,
                        life: 30,
                        color: y === 4 ? '#27ae60' : '#8B4513'
                    });
                }
            },

            collectCoin(x, y) {
                this.terrain[y][x] = this.TERRAIN_TYPES.AIR;
                this.roundCoinsCollected++;
                gameManager.gameStates.miner.totalCoinsCollected++;
                sounds.playCoin();
                this.updateMiningDisplay();

                // Check if all coins collected
                if (this.roundCoinsCollected >= this.totalCoins) {
                    setTimeout(() => this.endRound(true), 500);
                }
            },

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3; // Gravity
                    p.life--;
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },

            updateMiningDisplay() {
                const state = gameManager.gameStates.miner;
                document.getElementById('minerDigRemaining').textContent = state.resources;
                document.getElementById('minerCoinsDisplay').textContent = `${this.roundCoinsCollected}/${this.totalCoins}`;
            },

            endRound(success) {
                this.miningRunning = false;
                const state = gameManager.gameStates.miner;

                if (success) {
                    // Use shared round complete screen
                    showRoundComplete({
                        'Coins Collected': this.roundCoinsCollected,
                        'Total Coins': state.totalCoinsCollected
                    });
                } else {
                    showGameOver();
                }
            },

            render() {
                if (!this.ctx) return;
                const ctx = this.ctx;

                // Clear canvas
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw terrain
                for (let y = 0; y < this.GRID_HEIGHT; y++) {
                    for (let x = 0; x < this.GRID_WIDTH; x++) {
                        const terrain = this.terrain[y][x];
                        const px = x * this.BLOCK_SIZE;
                        const py = y * this.BLOCK_SIZE;

                        if (terrain === this.TERRAIN_TYPES.GRASS) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(px, py, this.BLOCK_SIZE, this.BLOCK_SIZE);
                            ctx.fillStyle = '#27ae60';
                            ctx.fillRect(px, py, this.BLOCK_SIZE, 8);
                        } else if (terrain === this.TERRAIN_TYPES.DIRT) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(px, py, this.BLOCK_SIZE, this.BLOCK_SIZE);
                            // Add texture
                            ctx.fillStyle = '#654321';
                            for (let i = 0; i < 3; i++) {
                                const tx = px + ((x * 7 + i * 11) % 28) + 2;
                                const ty = py + ((y * 13 + i * 17) % 28) + 2;
                                ctx.fillRect(tx, ty, 2, 2);
                            }
                        } else if (terrain === this.TERRAIN_TYPES.COIN) {
                            // Draw coin
                            const coinX = px + this.BLOCK_SIZE / 2;
                            const coinY = py + this.BLOCK_SIZE / 2;
                            const scale = 0.8 + Math.sin(Date.now() * 0.005) * 0.1;

                            ctx.fillStyle = '#f1c40f';
                            ctx.beginPath();
                            ctx.arc(coinX, coinY, 10 * scale, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = '#f39c12';
                            ctx.beginPath();
                            ctx.arc(coinX, coinY, 7 * scale, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = '#2c3e50';
                            ctx.font = 'bold 10px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('$', coinX, coinY);
                        }
                    }
                }

                // Draw particles
                for (const p of this.particles) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 30;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                }
                ctx.globalAlpha = 1;

                // Draw player
                this.drawMiner(this.playerPosition.x * this.BLOCK_SIZE, this.playerPosition.y * this.BLOCK_SIZE);
            },

            checkGameOver() {
                // Check for game over (no dig points and unreachable coins)
                const state = gameManager.gameStates.miner;
                if (state.resources <= 0 && this.roundCoinsCollected < this.totalCoins) {
                    // Check if any coins are in AIR (reachable)
                    let hasReachableCoins = false;
                    for (const coin of this.coinPositions) {
                        if (this.terrain[coin.y][coin.x] === this.TERRAIN_TYPES.COIN) {
                            // Check if adjacent cells have air
                            const adjacent = [
                                [coin.x - 1, coin.y], [coin.x + 1, coin.y],
                                [coin.x, coin.y - 1], [coin.x, coin.y + 1]
                            ];
                            for (const [ax, ay] of adjacent) {
                                if (ax >= 0 && ax < this.GRID_WIDTH && ay >= 0 && ay < this.GRID_HEIGHT) {
                                    if (this.terrain[ay][ax] === this.TERRAIN_TYPES.AIR) {
                                        hasReachableCoins = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (hasReachableCoins) break;
                    }
                    if (!hasReachableCoins && this.roundCoinsCollected < this.totalCoins) {
                        this.endRound(false);
                        return true;
                    }
                }
                return false;
            },

            drawMiner(x, y) {
                const ctx = this.ctx;
                const minerColor = gameManager.gameStates.miner.minerColor;
                const bodyColor = minerColor === 'red' ? '#e74c3c' : '#3498db';

                // Body (uses selected color)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(x + 8, y + 12, 16, 16);

                // Head
                ctx.fillStyle = '#FDBCB4';
                ctx.fillRect(x + 10, y + 4, 12, 10);

                // Hair (same color for both, just different character names)
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(x + 8, y + 2, 16, 6);

                // Helmet
                ctx.fillStyle = '#f1c40f';
                ctx.strokeStyle = '#e67e22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x + 16, y + 6, 10, Math.PI, 0);
                ctx.stroke();

                // Arms
                ctx.fillStyle = '#FDBCB4';
                ctx.fillRect(x + 4, y + 14, 4, 8);
                ctx.fillRect(x + 24, y + 14, 4, 8);

                // Legs
                ctx.fillStyle = '#654321';
                ctx.fillRect(x + 10, y + 24, 6, 8);
                ctx.fillRect(x + 16, y + 24, 6, 8);
            },

            gameLoop() {
                if (!this.miningRunning) return;

                this.updateParticles();
                this.render();

                // Check for game over after rendering
                if (this.checkGameOver()) return;

                requestAnimationFrame(() => this.gameLoop());
            },

            handleMiningKeyPress(e) {
                if (!this.miningRunning) return;

                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        this.movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        this.movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        this.movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        this.movePlayer(1, 0);
                        break;
                    case '=':
                    case '+':
                        // Dev mode: add dig points
                        if (gameManager.gameStates.miner.devMode) {
                            gameManager.gameStates.miner.resources += 5;
                            this.updateMiningDisplay();
                        }
                        break;
                }
            }
        };

        // === PLANE GAME MODULE ===
        const planeGame = {
            canvas: null,
            ctx: null,
            airplane: {
                x: 50,
                y: 180,
                velocityX: 0,
                velocityY: 0,
                speed: 0,
                altitude: 120,
                onGround: false,
                width: 40,
                height: 20,
                angle: 0
            },
            background: { clouds: [], trees: [] },
            flightRunning: false,
            launched: false,
            mathTimer: 60,
            mathInterval: null,
            distance: 0,
            targetDistance: 200,

            init() {
                this.canvas = document.getElementById('planeGameCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                    this.ctx.imageSmoothingEnabled = false;
                }
                this.initializeBackground();
            },

            initializeBackground() {
                this.background.clouds = [];
                this.background.trees = [];

                // Create clouds
                for (let i = 0; i < 8; i++) {
                    this.background.clouds.push({
                        x: Math.random() * 1500,
                        y: 20 + Math.random() * 60,
                        width: 40 + Math.random() * 40,
                        height: 20 + Math.random() * 15
                    });
                }

                // Create trees
                for (let i = 0; i < 10; i++) {
                    this.background.trees.push({
                        x: 100 + i * 150 + Math.random() * 50,
                        height: 30 + Math.random() * 20
                    });
                }
            },

            updateWindDisplay(animate = false) {
                const state = gameManager.gameStates.plane;
                const pointsEl = document.getElementById('planeWindPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('planeWindDisplay', state.resources, 'wind-point', animate);
            },

            addWindPoint() {
                this.updateWindDisplay(true);
            },

            showFlightPhase() {
                const state = gameManager.gameStates.plane;
                state.phase = 'flight';

                // Show flight phase (container switching is handled by shared system)
                document.getElementById('planeFlightPhase').classList.remove('hidden');

                this.startFlight();
            },

            startFlight() {
                const state = gameManager.gameStates.plane;

                // Reset airplane
                this.airplane.x = 50;
                this.airplane.y = 180;
                this.airplane.velocityX = 0;
                this.airplane.velocityY = 0;
                this.airplane.speed = 0;
                this.airplane.altitude = 120;
                this.airplane.onGround = true;
                this.airplane.angle = 0;

                this.distance = 0;
                this.targetDistance = state.round * 200;
                this.launched = false;
                this.flightRunning = true;

                // Update UI
                document.getElementById('planeFlightRoundNumber').textContent = state.round;
                document.getElementById('planeTargetDisplay').textContent = this.targetDistance;
                document.getElementById('planeLaunchIndicator').style.display = 'block';

                this.updateFlightDisplay();
                this.gameLoop();
            },

            useWind() {
                const state = gameManager.gameStates.plane;
                if (state.resources <= 0) {
                    sounds.playIncorrect();
                    return;
                }

                state.resources--;
                sounds.playWhoosh();

                if (!this.launched) {
                    // First use: launch
                    this.launched = true;
                    this.airplane.velocityX = 7;
                    this.airplane.velocityY = -2;
                    this.airplane.onGround = false;
                    document.getElementById('planeLaunchIndicator').style.display = 'none';
                } else {
                    // Subsequent: boost
                    const speedFactor = Math.max(0.5, 1 - (this.airplane.speed / 15));
                    this.airplane.velocityX += 3.5 * speedFactor;
                    this.airplane.velocityY -= 0.3;
                }

                this.updateFlightDisplay();
            },

            airBrake() {
                if (!this.launched) return;

                this.airplane.velocityX *= 0.7;
                this.airplane.velocityY *= 0.7;
                sounds.playButtonClick();
            },

            updateFlightDisplay() {
                const state = gameManager.gameStates.plane;
                document.getElementById('planeWindRemaining').textContent = state.resources;
                document.getElementById('planeDistanceDisplay').textContent = Math.floor(this.distance);
                document.getElementById('planeAltitudeDisplay').textContent = Math.floor(this.airplane.altitude);

                // Hide launch indicator if out of wind or already launched
                const indicator = document.getElementById('planeLaunchIndicator');
                if (indicator) {
                    indicator.style.display = (!this.launched && state.resources > 0) ? 'block' : 'none';
                }
            },

            updateAirplanePhysics() {
                if (!this.launched) return;

                const gravity = 0.21;
                this.airplane.velocityY += gravity;

                // Calculate lift based on velocity
                const totalVelocity = Math.sqrt(
                    this.airplane.velocityX * this.airplane.velocityX +
                    this.airplane.velocityY * this.airplane.velocityY
                );

                const angleOfAttack = Math.atan2(-this.airplane.velocityY, this.airplane.velocityX);
                const liftCoefficient = 0.030;
                const lift = totalVelocity * liftCoefficient * Math.cos(angleOfAttack) + 0.03;

                this.airplane.velocityY -= lift;

                // Air resistance
                this.airplane.velocityX *= 0.997;
                this.airplane.velocityY *= 0.985;

                // Clamp velocities
                this.airplane.velocityX = Math.min(12, Math.max(-2, this.airplane.velocityX));
                this.airplane.velocityY = Math.min(10, Math.max(-10, this.airplane.velocityY));

                // Update position
                this.airplane.x += this.airplane.velocityX;
                this.airplane.y += this.airplane.velocityY;

                // Calculate altitude (ground is at y=250)
                this.airplane.altitude = Math.max(0, 250 - this.airplane.y);

                // Ground collision
                if (this.airplane.y >= 250) {
                    this.airplane.y = 250;
                    this.airplane.onGround = true;
                    this.airplane.velocityX *= 0.93; // Ground friction
                    this.airplane.velocityY = 0;
                    this.airplane.altitude = 0;
                } else {
                    this.airplane.onGround = false;
                }

                // Update speed and angle
                this.airplane.speed = totalVelocity;
                this.airplane.angle = Math.atan2(this.airplane.velocityY, this.airplane.velocityX);

                // Update distance
                this.distance = Math.floor(this.airplane.x / 4);

                // Check for landing at target
                if (this.distance >= this.targetDistance && this.airplane.onGround) {
                    this.landAtTarget();
                    return;
                }

                // Check for game over (stopped on ground)
                const state = gameManager.gameStates.plane;
                if (this.airplane.onGround && this.airplane.speed < 0.5 && state.resources <= 0 && this.launched) {
                    this.endFlightPhase();
                }
            },

            landAtTarget() {
                this.flightRunning = false;
                const state = gameManager.gameStates.plane;

                state.totalDistance += this.distance;

                // Use shared round complete screen
                setTimeout(() => {
                    showRoundComplete({
                        'Distance Flown': Math.round(this.distance) + 'm',
                        'Total Distance': Math.floor(state.totalDistance) + 'm'
                    });
                }, 1000);
            },

            endFlightPhase() {
                this.flightRunning = false;
                const state = gameManager.gameStates.plane;
                state.totalDistance += this.distance;

                showGameOver();
            },

            render() {
                if (!this.ctx) return;
                const ctx = this.ctx;

                // Camera follows plane
                const cameraX = Math.max(0, this.airplane.x - this.canvas.width / 3);

                // Clear and draw sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#98FB98');
                gradient.addColorStop(1, '#8B4513');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw clouds (parallax)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (const cloud of this.background.clouds) {
                    const cloudX = cloud.x - cameraX * 0.3;
                    if (cloudX > -100 && cloudX < this.canvas.width + 100) {
                        ctx.beginPath();
                        ctx.arc(cloudX, cloud.y, cloud.width / 2, 0, Math.PI * 2);
                        ctx.arc(cloudX + cloud.width / 3, cloud.y - 5, cloud.width / 3, 0, Math.PI * 2);
                        ctx.arc(cloudX - cloud.width / 4, cloud.y, cloud.width / 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw trees (parallax)
                for (const tree of this.background.trees) {
                    const treeX = tree.x - cameraX * 0.7;
                    if (treeX > -50 && treeX < this.canvas.width + 50) {
                        // Trunk
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(treeX - 5, 250 - tree.height, 10, tree.height);
                        // Leaves
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.arc(treeX, 250 - tree.height - 15, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw ground
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 250, this.canvas.width, 50);
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, 250, this.canvas.width, 5);

                // Draw target (trash can)
                const targetX = this.targetDistance * 4 - cameraX;
                if (targetX > -50 && targetX < this.canvas.width + 50) {
                    this.drawTarget(ctx, targetX, 235);
                }

                // Draw airplane
                this.drawAirplane(ctx, this.airplane.x - cameraX, this.airplane.y);

                // Draw wind effect at high speed
                if (this.airplane.speed > 7 && this.launched) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        const startX = this.airplane.x - cameraX - 20 - i * 10;
                        const startY = this.airplane.y + (Math.random() - 0.5) * 10;
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(startX - 15, startY);
                        ctx.stroke();
                    }
                }
            },

            drawTarget(ctx, x, y) {
                // Trash can / landing zone
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(x, y + 15, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(x - 15, y, 30, 30);

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(x - 18, y - 5, 36, 8);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GOAL', x, y + 20);
            },

            drawAirplane(ctx, x, y) {
                const state = gameManager.gameStates.plane;
                const color = state.airplaneType === 'red' ? '#e74c3c' : '#3498db';

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.airplane.angle);

                // Paper airplane shape
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(20, 0);      // Nose
                ctx.lineTo(-15, -10);   // Top wing
                ctx.lineTo(-10, 0);     // Body notch
                ctx.lineTo(-15, 10);    // Bottom wing
                ctx.closePath();
                ctx.fill();

                // Center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, 0);
                ctx.stroke();

                ctx.restore();
            },

            gameLoop() {
                if (!this.flightRunning) return;

                this.updateAirplanePhysics();
                this.updateFlightDisplay();
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            },

            handleFlightKeyPress(e) {
                if (!this.flightRunning) return;

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        this.useWind();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        this.airBrake();
                        break;
                    case '=':
                    case '+':
                        // Dev mode: add wind points
                        if (gameManager.gameStates.plane.devMode) {
                            gameManager.gameStates.plane.resources += 5;
                            this.updateFlightDisplay();
                        }
                        break;
                }
            }
        };

        // === CASTLE GAME MODULE ===
        const castleGame = {
            canvas: null,
            ctx: null,
            cannon: {
                x: 120,
                y: 300,
                angle: 45,
                power: 50,
                minAngle: 0,
                maxAngle: 90,
                minPower: 10,
                maxPower: 100
            },
            projectiles: [],
            targets: [],
            particles: [],
            waterWaves: [],
            background: { clouds: [] },
            gameRunning: false,
            mathTimer: 60,
            mathInterval: null,
            roundTargetsDestroyed: 0,

            init() {
                this.canvas = document.getElementById('castleGameCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                }

                // Initialize clouds
                this.background.clouds = [];
                for (let i = 0; i < 5; i++) {
                    this.background.clouds.push({
                        x: Math.random() * 1000 - 200,
                        y: 30 + Math.random() * 80,
                        width: 60 + Math.random() * 40,
                        height: 30 + Math.random() * 20,
                        speed: 0.2 + Math.random() * 0.4
                    });
                }

                // Initialize water waves
                this.waterWaves = [];
                for (let i = 0; i < 8; i++) {
                    this.waterWaves.push({
                        x: 200 + i * 80,
                        phase: Math.random() * Math.PI * 2,
                        amplitude: 2 + Math.random() * 2,
                        speed: 0.03 + Math.random() * 0.02
                    });
                }
            },

            showCannonPhase() {
                const state = gameManager.gameStates.castle;
                state.phase = 'cannon';

                // Show cannon phase (container switching is handled by shared system)
                document.getElementById('castleCannonPhase').classList.remove('hidden');

                // Show countdown
                const cannonPhase = document.getElementById('castleCannonPhase');
                const countdownDiv = document.createElement('div');
                countdownDiv.style.cssText = `
                    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    font-size: 3em; font-weight: bold; color: #e74c3c;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3); z-index: 100;
                `;
                countdownDiv.textContent = 'DEFEND! üè∞';
                cannonPhase.appendChild(countdownDiv);

                setTimeout(() => {
                    countdownDiv.textContent = 'Ready...';
                    setTimeout(() => {
                        countdownDiv.textContent = 'FIRE!';
                        setTimeout(() => {
                            countdownDiv.remove();
                            this.startCannon();
                        }, 500);
                    }, 600);
                }, 800);
            },

            startCannon() {
                this.gameRunning = true;
                const state = gameManager.gameStates.castle;

                // Reset for new round
                this.projectiles = [];
                this.particles = [];
                this.roundTargetsDestroyed = 0;
                this.cannon.angle = 45;
                this.cannon.power = 50;

                // Generate targets based on round
                const numTargets = Math.min(state.round + 2, 8);
                this.generateTargets(numTargets);

                document.getElementById('castleCannonRound').textContent = state.round;
                this.updateCannonControls();
                this.gameLoop();
            },

            generateTargets(numTargets) {
                this.targets = [];
                const minX = 350, maxX = 750;
                const minY = 80, maxY = 260;

                for (let i = 0; i < numTargets; i++) {
                    let x, y, validPosition = false, attempts = 0;

                    while (!validPosition && attempts < 100) {
                        x = minX + Math.random() * (maxX - minX);
                        y = minY + Math.random() * (maxY - minY);
                        validPosition = true;

                        for (const target of this.targets) {
                            const dist = Math.sqrt((x - target.x) ** 2 + (y - target.y) ** 2);
                            if (dist < 70) { validPosition = false; break; }
                        }
                        attempts++;
                    }

                    this.targets.push({
                        x, y, radius: 22 + Math.random() * 6,
                        hit: false, bobOffset: Math.random() * Math.PI * 2
                    });
                }
            },

            adjustAngle(delta) {
                this.cannon.angle = Math.max(0, Math.min(90, this.cannon.angle + delta));
                this.updateCannonControls();
            },

            adjustPower(delta) {
                this.cannon.power = Math.max(10, Math.min(100, this.cannon.power + delta));
                this.updateCannonControls();
            },

            fireCannon() {
                const state = gameManager.gameStates.castle;
                if (state.resources <= 0) {
                    sounds.playIncorrect();
                    return;
                }

                state.resources--;
                updateScore('castle');
                sounds.playButtonClick();

                const angleRad = (this.cannon.angle * Math.PI) / 180;
                const velocity = (this.cannon.power / 100) * 16;
                const barrelLength = 45;

                this.projectiles.push({
                    x: this.cannon.x + Math.cos(angleRad) * barrelLength,
                    y: this.cannon.y - Math.sin(angleRad) * barrelLength,
                    vx: Math.cos(angleRad) * velocity,
                    vy: -Math.sin(angleRad) * velocity,
                    radius: 8,
                    gravity: 0.22,
                    trail: []
                });

                // Cannon recoil particles
                for (let i = 0; i < 6; i++) {
                    this.particles.push({
                        x: this.cannon.x + Math.cos(angleRad) * 30,
                        y: this.cannon.y - Math.sin(angleRad) * 30,
                        vx: -Math.cos(angleRad) * (2 + Math.random() * 3),
                        vy: -Math.sin(angleRad) * (2 + Math.random() * 3) + (Math.random() - 0.5) * 2,
                        life: 15 + Math.random() * 10,
                        color: '#f39c12'
                    });
                }

                this.updateCannonDisplay();
            },

            updateCannonControls() {
                const state = gameManager.gameStates.castle;
                const angleEl = document.getElementById('castleAngleDisplay');
                const powerEl = document.getElementById('castlePowerDisplay');
                const cannonEl = document.getElementById('castleCannonCount');
                const targetsEl = document.getElementById('castleTargetsDisplay');
                const angleNeedle = document.getElementById('castleAngleNeedle');
                const powerNeedle = document.getElementById('castlePowerNeedle');

                if (angleEl) angleEl.textContent = `${Math.round(this.cannon.angle)}¬∞`;
                if (powerEl) powerEl.textContent = `${this.cannon.power}%`;
                if (cannonEl) cannonEl.textContent = state.resources;
                if (targetsEl) targetsEl.textContent = this.targets.filter(t => !t.hit).length;

                // Update angle needle (0¬∞ = horizontal right, 90¬∞ = vertical up)
                // Needle rotation: 0¬∞ angle = 0deg rotation, 90¬∞ angle = -90deg rotation
                if (angleNeedle) {
                    const angleRotation = -this.cannon.angle;
                    angleNeedle.style.transform = `translateX(-50%) rotate(${angleRotation}deg)`;
                }

                // Update power needle (10-100% maps to -90deg to +90deg)
                // 10% = -90deg (left), 55% = 0deg (center), 100% = +90deg (right)
                if (powerNeedle) {
                    const powerRotation = ((this.cannon.power - 10) / 90) * 180 - 90;
                    powerNeedle.style.transform = `translateX(-50%) rotate(${powerRotation}deg)`;
                }
            },

            addCannonPoint() {
                this.updateCannonDisplay(true);
            },

            updateCannonDisplay(animate = false) {
                const state = gameManager.gameStates.castle;
                const pointsEl = document.getElementById('castleCannonPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('castleCannonDisplay', state.resources, 'cannon-point', animate);
            },

            handleCannonKeyPress(e) {
                if (!this.gameRunning) return;
                switch(e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        e.preventDefault(); this.adjustAngle(3); break;
                    case 'ArrowDown': case 's': case 'S':
                        e.preventDefault(); this.adjustAngle(-3); break;
                    case 'ArrowLeft': case 'a': case 'A':
                        e.preventDefault(); this.adjustPower(-5); break;
                    case 'ArrowRight': case 'd': case 'D':
                        e.preventDefault(); this.adjustPower(5); break;
                    case ' ': case 'Enter':
                        e.preventDefault(); this.fireCannon(); break;
                    case '=': case '+':
                        if (gameManager.gameStates.castle.devMode) {
                            gameManager.gameStates.castle.resources += 5;
                            this.updateCannonDisplay(); this.updateCannonControls();
                        }
                        break;
                }
            },

            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];

                    proj.trail.push({ x: proj.x, y: proj.y });
                    if (proj.trail.length > 10) proj.trail.shift();

                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    proj.vy += proj.gravity;

                    // Check target collisions
                    for (const target of this.targets) {
                        if (!target.hit) {
                            const dist = Math.sqrt((proj.x - target.x) ** 2 + (proj.y - target.y) ** 2);
                            if (dist < proj.radius + target.radius) {
                                target.hit = true;
                                this.roundTargetsDestroyed++;
                                sounds.playCorrect();

                                // Explosion particles
                                for (let k = 0; k < 15; k++) {
                                    const angle = (k / 15) * Math.PI * 2;
                                    const speed = 3 + Math.random() * 5;
                                    this.particles.push({
                                        x: target.x, y: target.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        life: 25 + Math.random() * 15,
                                        color: ['#e74c3c', '#f39c12', '#ecf0f1'][Math.floor(Math.random() * 3)]
                                    });
                                }
                                this.projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }

                    // Water splash
                    if (proj.y > 315 && proj.x > 180) {
                        for (let k = 0; k < 8; k++) {
                            this.particles.push({
                                x: proj.x, y: 315,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -Math.random() * 5 - 2,
                                life: 20,
                                color: '#3498db'
                            });
                        }
                        this.projectiles.splice(i, 1);
                        continue;
                    }

                    // Remove if out of bounds
                    if (proj.x > 850 || proj.y > 420 || proj.x < -50) {
                        this.projectiles.splice(i, 1);
                    }
                }
            },

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.25;
                    p.life--;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.updateProjectiles();
                this.updateParticles();
                this.updateCannonControls();
                this.render();

                const remaining = this.targets.filter(t => !t.hit).length;
                const state = gameManager.gameStates.castle;

                if (remaining === 0) {
                    this.endRound(true);
                    return;
                }

                if (state.resources <= 0 && this.projectiles.length === 0) {
                    setTimeout(() => this.endRound(false), 500);
                    return;
                }

                requestAnimationFrame(() => this.gameLoop());
            },

            endRound(success) {
                this.gameRunning = false;
                const state = gameManager.gameStates.castle;
                state.totalTargetsDestroyed += this.roundTargetsDestroyed;

                if (success) {
                    // Add bonus resources for next round
                    state.resources += 5;

                    // Use shared round complete screen
                    showRoundComplete({
                        'Targets Destroyed': this.roundTargetsDestroyed,
                        'Bonus Cannonballs': '+5'
                    });
                } else {
                    showGameOver();
                }
            },

            render() {
                if (!this.ctx) return;
                const ctx = this.ctx;
                const time = Date.now() * 0.001;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.6, '#b8e6f7');
                gradient.addColorStop(0.75, '#98FB98');
                gradient.addColorStop(1, '#3498db');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                for (const cloud of this.background.clouds) {
                    cloud.x += cloud.speed;
                    if (cloud.x > this.canvas.width + cloud.width) cloud.x = -cloud.width;

                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.height/2, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.3, cloud.y - cloud.height * 0.25, cloud.height/2.2, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.6, cloud.y, cloud.height/2.5, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width, cloud.y + cloud.height * 0.1, cloud.height/2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Water with waves
                ctx.fillStyle = '#2980b9';
                ctx.beginPath();
                ctx.moveTo(180, 320);
                for (const wave of this.waterWaves) {
                    wave.phase += wave.speed;
                    const waveY = 320 + Math.sin(wave.phase) * wave.amplitude;
                    ctx.lineTo(wave.x, waveY);
                }
                ctx.lineTo(this.canvas.width, 320);
                ctx.lineTo(this.canvas.width, this.canvas.height);
                ctx.lineTo(180, this.canvas.height);
                ctx.closePath();
                ctx.fill();

                // Water highlights
                ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                for (let i = 0; i < 5; i++) {
                    const wx = 220 + i * 120 + Math.sin(time + i) * 10;
                    const wy = 335 + Math.sin(time * 1.5 + i) * 3;
                    ctx.beginPath();
                    ctx.ellipse(wx, wy, 30, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Castle
                this.drawCastle(ctx, time);

                // Targets (with bobbing)
                for (const target of this.targets) {
                    if (!target.hit) {
                        const bobY = target.y + Math.sin(time * 2 + target.bobOffset) * 3;
                        this.drawTarget(ctx, target.x, bobY, target.radius);
                    }
                }

                // Projectiles with trails
                for (const proj of this.projectiles) {
                    // Trail
                    if (proj.trail.length > 1) {
                        ctx.strokeStyle = 'rgba(44, 62, 80, 0.4)';
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(proj.trail[0].x, proj.trail[0].y);
                        for (let i = 1; i < proj.trail.length; i++) {
                            ctx.lineTo(proj.trail[i].x, proj.trail[i].y);
                        }
                        ctx.stroke();
                    }

                    // Cannonball
                    ctx.fillStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Shine
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(proj.x - 2, proj.y - 2, proj.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Particles
                for (const p of this.particles) {
                    const alpha = Math.min(1, p.life / 20);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3 + (1 - alpha) * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            },

            drawCastle(ctx, time) {
                const state = gameManager.gameStates.castle;
                const flagColor = state.castleFlagColor === 'blue' ? '#3498db' : '#e74c3c';

                // Island
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(90, 345, 85, 45, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(90, 332, 80, 38, 0, 0, Math.PI * 2);
                ctx.fill();

                // Castle walls
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(25, 275, 130, 65);

                // Towers
                ctx.fillRect(15, 240, 35, 100);
                ctx.fillRect(130, 240, 35, 100);
                ctx.fillRect(65, 225, 50, 115);

                // Tower tops
                ctx.fillStyle = '#34495e';
                const towers = [[32, 240], [147, 240], [90, 225]];
                const widths = [40, 40, 55];
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(towers[i][0] - widths[i]/2, towers[i][1]);
                    ctx.lineTo(towers[i][0], towers[i][1] - 25);
                    ctx.lineTo(towers[i][0] + widths[i]/2, towers[i][1]);
                    ctx.closePath();
                    ctx.fill();
                }

                // Flag on center tower
                const flagWave = Math.sin(time * 3) * 0.15;
                ctx.fillStyle = '#34495e';
                ctx.fillRect(88, 175, 4, 50);

                ctx.fillStyle = flagColor;
                ctx.beginPath();
                ctx.moveTo(92, 180);
                ctx.quadraticCurveTo(115 + flagWave * 20, 188, 125, 195);
                ctx.quadraticCurveTo(115 + flagWave * 15, 202, 92, 210);
                ctx.closePath();
                ctx.fill();

                // Windows
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(28, 260, 10, 15);
                ctx.fillRect(143, 260, 10, 15);
                ctx.fillRect(80, 250, 15, 18);
                ctx.fillRect(40, 295, 12, 15);
                ctx.fillRect(128, 295, 12, 15);

                // Gate
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(75, 305, 30, 35);
                ctx.beginPath();
                ctx.arc(90, 305, 15, 0, Math.PI, true);
                ctx.fill();

                // Cannon
                const angleRad = (this.cannon.angle * Math.PI) / 180;

                // Cannon base
                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.arc(this.cannon.x, this.cannon.y + 5, 15, 0, Math.PI, true);
                ctx.fill();

                // Cannon pivot
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(this.cannon.x, this.cannon.y, 14, 0, Math.PI * 2);
                ctx.fill();

                // Cannon barrel
                ctx.save();
                ctx.translate(this.cannon.x, this.cannon.y);
                ctx.rotate(-angleRad);

                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.moveTo(0, -7);
                ctx.lineTo(45, -5);
                ctx.lineTo(48, -3);
                ctx.lineTo(48, 3);
                ctx.lineTo(45, 5);
                ctx.lineTo(0, 7);
                ctx.closePath();
                ctx.fill();

                // Barrel details
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(10, -5, 4, 10);
                ctx.fillRect(25, -5, 4, 10);

                ctx.restore();
            },

            drawTarget(ctx, x, y, radius) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(x + 3, y + 3, radius, radius * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // White ring
                ctx.fillStyle = '#ecf0f1';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
                ctx.fill();

                // Red center
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Bullseye
                ctx.fillStyle = '#ecf0f1';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
                ctx.fill();
            }
        };

        // === EXPRESS GAME MODULE ===
        // Rebuilt from scratch based on MathExpress20250603.html
        const expressGame = {
            canvas: null,
            ctx: null,

            // Engine (lead train car)
            train: {
                x: 50,
                y: 200,
                velocityX: 0,
                velocityY: 0,
                speed: 0,
                onGround: true,
                width: 60,
                height: 30,
                momentum: 0,
                wasAirborne: false,
                airTime: 0,
                brakingBeforeLanding: false
            },

            // Multiple train cars
            trainCars: [
                { x: 50, y: 200, angle: 0, type: 'engine', wheelRotation: 0 },
                { x: -15, y: 200, angle: 0, type: 'boxcar1', wheelRotation: 0 },
                { x: -80, y: 200, angle: 0, type: 'boxcar2', wheelRotation: 0 },
                { x: -145, y: 200, angle: 0, type: 'caboose', wheelRotation: 0 }
            ],

            // Path history for car following
            pathHistory: [],
            pathHistorySize: 200,

            carPhysics: {
                spacing: 65,
                carLength: 60,
                mass: 1,
                wheelRadius: 8
            },

            // Terrain with gentle hills
            terrain: {
                segments: [],
                segmentWidth: 30,
                lookAhead: 40,
                baseHeight: 250,
                lastX: 0,
                lastHeight: 250,
                hillState: {
                    currentPhase: 0,
                    hillLength: 800,
                    amplitude: 60,
                    nextHillDistance: 800
                },
                constraints: {
                    maxUphillChange: 4,
                    minHeight: 200,
                    maxHeight: 300
                }
            },

            // Parallax background
            background: {
                clouds: [],
                mountains: [],
                trees: []
            },

            // Station system
            currentRoundDistance: 0,
            roundTargetDistance: 0,
            startingSteamPoints: 0,

            gameRunning: false,
            mathTimer: 60,
            mathInterval: null,

            init() {
                this.canvas = document.getElementById('expressGameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.initializeBackground();
                this.initializeTerrain();
            },

            initializeBackground() {
                // Clouds
                this.background.clouds = [];
                for (let i = 0; i < 8; i++) {
                    this.background.clouds.push({
                        x: Math.random() * 1600,
                        y: 20 + Math.random() * 80,
                        width: 60 + Math.random() * 40,
                        height: 30 + Math.random() * 20,
                        speed: 0.2 + Math.random() * 0.3
                    });
                }

                // Mountains
                this.background.mountains = [];
                for (let i = 0; i < 5; i++) {
                    this.background.mountains.push({
                        x: i * 300,
                        width: 200 + Math.random() * 100,
                        height: 80 + Math.random() * 40
                    });
                }

                // Trees
                this.background.trees = [];
                for (let i = 0; i < 20; i++) {
                    this.background.trees.push({
                        x: i * 100 + Math.random() * 50,
                        height: 40 + Math.random() * 30,
                        width: 30 + Math.random() * 20
                    });
                }
            },

            initializeTerrain() {
                this.terrain.segments = [];
                this.terrain.lastX = 0;
                this.terrain.lastHeight = this.terrain.baseHeight;
                this.terrain.hillState.currentPhase = 0;
                this.terrain.hillState.nextHillDistance = 600 + Math.random() * 400;

                for (let i = 0; i < this.terrain.lookAhead; i++) {
                    this.generateNextTerrainSegment();
                }
            },

            generateNextTerrainSegment() {
                const x = this.terrain.lastX + this.terrain.segmentWidth;
                let targetHeight = this.terrain.baseHeight;

                // Check for new hill
                if (x >= this.terrain.hillState.nextHillDistance) {
                    this.terrain.hillState.currentPhase = 0;
                    this.terrain.hillState.amplitude = 40 + Math.random() * 80;
                    this.terrain.hillState.hillLength = 600 + Math.random() * 800;
                    this.terrain.hillState.nextHillDistance = x + this.terrain.hillState.hillLength + 400 + Math.random() * 600;
                }

                // Generate hill curve
                if (x >= this.terrain.hillState.nextHillDistance - this.terrain.hillState.hillLength &&
                    x < this.terrain.hillState.nextHillDistance) {
                    const hillProgress = (x - (this.terrain.hillState.nextHillDistance - this.terrain.hillState.hillLength)) / this.terrain.hillState.hillLength;
                    const hillHeight = Math.cos(hillProgress * Math.PI * 2) * this.terrain.hillState.amplitude;
                    targetHeight = this.terrain.baseHeight - hillHeight;
                }

                // Apply slope constraints
                const heightDifference = targetHeight - this.terrain.lastHeight;
                let actualHeight;

                if (heightDifference > 0) {
                    const maxUphillChange = this.terrain.constraints.maxUphillChange;
                    actualHeight = heightDifference > maxUphillChange ?
                        this.terrain.lastHeight + maxUphillChange : targetHeight;
                } else {
                    actualHeight = targetHeight;
                }

                actualHeight = Math.max(this.terrain.constraints.minHeight,
                              Math.min(this.terrain.constraints.maxHeight, actualHeight));

                this.terrain.segments.push({ x: x, y: actualHeight });
                this.terrain.lastX = x;
                this.terrain.lastHeight = actualHeight;
            },

            showTrainPhase() {
                const state = gameManager.gameStates.express;
                state.phase = 'train';

                // Remove any lingering station arrival overlay from previous round
                const existingArrival = document.getElementById('expressStationArrival');
                if (existingArrival) existingArrival.remove();

                // Calculate target distance for this round
                this.roundTargetDistance = state.round * 200;
                this.currentRoundDistance = 0;

                // Show train phase (container switching is handled by shared system)
                document.getElementById('expressTrainPhase').classList.remove('hidden');

                sounds.playButtonClick();

                // Show countdown
                const trainPhase = document.getElementById('expressTrainPhase');
                const countdownDiv = document.createElement('div');
                countdownDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 3em;
                    font-weight: bold;
                    color: #e74c3c;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                    z-index: 100;
                    pointer-events: none;
                `;
                countdownDiv.textContent = 'ALL ABOARD!';
                trainPhase.appendChild(countdownDiv);

                setTimeout(() => {
                    countdownDiv.textContent = 'Ready...';
                    setTimeout(() => {
                        countdownDiv.textContent = 'GO!';
                        setTimeout(() => {
                            countdownDiv.remove();
                            this.startTrain();
                        }, 500);
                    }, 800);
                }, 1000);
            },

            startTrain() {
                this.gameRunning = true;
                const state = gameManager.gameStates.express;
                this.startingSteamPoints = state.resources;
                this.currentRoundDistance = 0;
                this.distanceAdded = false;

                // Reset train
                this.train.x = 50;
                this.train.y = 200;
                this.train.velocityX = 0;
                this.train.velocityY = 0;
                this.train.speed = 0;
                this.train.momentum = 0;
                this.train.onGround = true;
                this.train.wasAirborne = false;
                this.train.airTime = 0;
                this.train.brakingBeforeLanding = false;

                // Reset terrain
                this.initializeTerrain();

                // Clear path history
                this.pathHistory = [];

                // Reset train cars
                this.trainCars[0] = { x: this.train.x, y: this.train.y, angle: 0, type: 'engine', wheelRotation: 0 };
                for (let i = 1; i < this.trainCars.length; i++) {
                    this.trainCars[i].x = this.train.x - (i * this.carPhysics.spacing);
                    this.trainCars[i].y = this.getTerrainHeightAt(this.trainCars[i].x) - this.train.height;
                    this.trainCars[i].angle = 0;
                    this.trainCars[i].wheelRotation = 0;
                    this.pathHistory.push({ x: this.trainCars[i].x, y: this.trainCars[i].y });
                }

                this.updateDisplays();
                this.gameLoop();
            },

            boost() {
                const state = gameManager.gameStates.express;
                if (state.resources > 0 && this.gameRunning) {
                    state.resources--;
                    updateScore('express');

                    if (Math.abs(this.train.velocityX) < 0.1) {
                        this.train.velocityX = 1.5;
                    }

                    // Strategic boost bonus - check for incline ahead
                    let boostMultiplier = 1.0;
                    const lookAheadDistance = 100;
                    const currentHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2);
                    const aheadHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2 + lookAheadDistance);

                    if (aheadHeight < currentHeight - 10) {
                        boostMultiplier = 1.5;
                    }

                    const baseBoostPower = 3.5;
                    this.train.momentum += baseBoostPower * boostMultiplier;

                    const maxMomentum = 4.5;
                    if (this.train.momentum > maxMomentum) {
                        this.train.momentum = maxMomentum;
                    }

                    sounds.playButtonClick();
                    this.updateDisplays();
                }
            },

            brake() {
                if (this.gameRunning) {
                    // Strategic braking check
                    if (!this.train.onGround && this.train.velocityY > 0 && Math.abs(this.train.velocityX) > 9) {
                        const futureY = this.train.y + this.train.velocityY * 10;
                        const terrainHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2);

                        if (futureY + this.train.height >= terrainHeight - 20) {
                            this.train.brakingBeforeLanding = true;
                        }
                    }

                    if (!this.train.onGround) {
                        this.train.velocityY += 2.5;
                        if (!this.train.brakingBeforeLanding) {
                            this.train.velocityX *= 0.98;
                        }
                    } else {
                        this.train.momentum *= 0.4;
                        this.train.velocityX *= 0.85;
                    }
                    sounds.playButtonClick();
                }
            },

            updateTrainPhysics() {
                const state = gameManager.gameStates.express;
                const totalMass = 1 + (this.trainCars.length - 1) * 0.3;

                // Apply momentum
                if (Math.abs(this.train.momentum) > 0) {
                    this.train.velocityX += (this.train.momentum / totalMass) * 0.2;

                    const maxVelocity = this.train.brakingBeforeLanding ? 13 : 11;
                    if (Math.abs(this.train.velocityX) > maxVelocity) {
                        this.train.velocityX = Math.sign(this.train.velocityX) * maxVelocity;
                    }

                    const distanceFactor = Math.min(state.totalDistance / 5000, 0.5);
                    this.train.momentum *= (0.96 - distanceFactor * 0.02);

                    if (Math.abs(this.train.momentum) < 0.01) {
                        this.train.momentum = 0;
                    }
                }

                // Update position
                this.train.x += this.train.velocityX;
                this.train.y += this.train.velocityY;

                // Get terrain info
                const terrainHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2);
                const terrainSlope = this.getTerrainSlopeAt(this.train.x + this.train.width/2);

                // Ground collision
                if (this.train.y + this.train.height >= terrainHeight) {
                    this.train.y = terrainHeight - this.train.height;

                    if (!this.train.onGround && this.train.wasAirborne) {
                        this.train.momentum += 0.3;
                        this.train.wasAirborne = false;
                    }

                    this.train.onGround = true;

                    // Moon-like launch on hill crests
                    if (Math.abs(this.train.velocityX) > 3 && terrainSlope > 1.0) {
                        const launchPower = Math.min(this.train.velocityX * 0.6, 7);
                        this.train.velocityY = -launchPower;
                        this.train.onGround = false;
                        this.train.wasAirborne = true;
                        this.train.brakingBeforeLanding = false;
                        this.train.momentum += 0.3;
                    } else {
                        this.train.velocityY = 0;

                        if (Math.abs(this.train.velocityX) > 0.5) {
                            const slopeEffect = terrainSlope * 0.15 / totalMass;

                            if (terrainSlope > 0) {
                                this.train.momentum += slopeEffect * 0.1;
                                if (this.train.momentum > 4.5) this.train.momentum = 4.5;
                            } else {
                                const distanceFactor = Math.min(state.totalDistance / 5000, 0.5);
                                this.train.velocityX += slopeEffect * (3 + distanceFactor * 2);
                                this.train.velocityX *= (0.99 - distanceFactor * 0.01);
                                this.train.momentum *= (0.94 - distanceFactor * 0.02);
                            }
                        }
                    }
                } else {
                    this.train.onGround = false;
                    this.train.wasAirborne = true;
                    this.train.airTime++;
                    // Moon-like gravity
                    this.train.velocityY += 0.16;
                }

                // Friction
                if (Math.abs(this.train.velocityX) > 0.1) {
                    const distanceFactor = Math.min(state.totalDistance / 5000, 0.5);
                    const baseFriction = this.train.onGround ?
                        (0.997 - distanceFactor * 0.005) :
                        (1.0 - distanceFactor * 0.004);
                    const massFriction = 1 - ((1 - baseFriction) / totalMass);
                    this.train.velocityX *= massFriction;
                } else if (Math.abs(this.train.momentum) <= 0.1) {
                    this.train.velocityX = 0;
                }

                // Velocity cap
                const maxVelocity = this.train.brakingBeforeLanding ? 13 : 11;
                if (Math.abs(this.train.velocityX) > maxVelocity) {
                    this.train.velocityX = Math.sign(this.train.velocityX) * maxVelocity;
                }

                if (Math.abs(this.train.velocityX) < 0.3 && Math.abs(this.train.momentum) < 0.1) {
                    this.train.velocityX = 0;
                    this.train.momentum = 0;
                }

                this.train.speed = Math.abs(this.train.velocityX);

                // Update wheel rotations
                const wheelCircumference = 2 * Math.PI * this.carPhysics.wheelRadius;
                const rotationDelta = (this.train.velocityX / wheelCircumference) * Math.PI * 2;

                // Update engine car
                this.trainCars[0].x = this.train.x;
                this.trainCars[0].y = this.train.y;
                this.trainCars[0].angle = Math.atan(this.getTerrainSlopeAt(this.train.x + this.train.width/2)) * 0.5;
                this.trainCars[0].wheelRotation += rotationDelta;

                // Add to path history
                this.pathHistory.push({ x: this.train.x, y: this.train.y });
                if (this.pathHistory.length > this.pathHistorySize) {
                    this.pathHistory.shift();
                }

                // Update other cars to follow
                for (let i = 1; i < this.trainCars.length; i++) {
                    const car = this.trainCars[i];
                    const pathOffset = i * this.carPhysics.spacing;
                    const targetDistance = this.train.x - pathOffset;

                    let foundPosition = false;
                    for (let j = this.pathHistory.length - 1; j >= 0; j--) {
                        const pathPoint = this.pathHistory[j];
                        if (pathPoint.x <= targetDistance) {
                            car.x = pathPoint.x;
                            car.y = pathPoint.y;
                            foundPosition = true;

                            if (j > 0) {
                                const prevPoint = this.pathHistory[j - 1];
                                const dx = pathPoint.x - prevPoint.x;
                                const dy = pathPoint.y - prevPoint.y;
                                car.angle = Math.atan2(dy, dx);
                            }
                            break;
                        }
                    }

                    if (!foundPosition) {
                        const prevCar = this.trainCars[i - 1];
                        car.x = prevCar.x - this.carPhysics.spacing;
                        car.y = prevCar.y;
                        car.angle = prevCar.angle;
                    }

                    car.wheelRotation += rotationDelta;
                }

                // Update distance
                this.currentRoundDistance = Math.floor(this.train.x / 20);

                // Check if reached station
                if (this.currentRoundDistance >= this.roundTargetDistance) {
                    this.arriveAtStation();
                    return;
                }
            },

            getTerrainHeightAt(x) {
                const segmentIndex = Math.floor(x / this.terrain.segmentWidth);

                if (segmentIndex >= this.terrain.segments.length - 1 || segmentIndex < 0) {
                    return this.terrain.baseHeight;
                }

                const segment1 = this.terrain.segments[segmentIndex];
                const segment2 = this.terrain.segments[segmentIndex + 1];

                if (!segment1 || !segment2) return this.terrain.baseHeight;

                const localX = x - segment1.x;
                const t = localX / this.terrain.segmentWidth;

                return segment1.y + (segment2.y - segment1.y) * t;
            },

            getTerrainSlopeAt(x) {
                const h1 = this.getTerrainHeightAt(x - 10);
                const h2 = this.getTerrainHeightAt(x + 10);
                return (h1 - h2) / 20;
            },

            updateTerrain() {
                const trainProgress = this.train.x;
                const neededSegments = Math.floor(trainProgress / this.terrain.segmentWidth) + this.terrain.lookAhead;

                while (this.terrain.segments.length < neededSegments) {
                    this.generateNextTerrainSegment();
                }

                const minSegmentsToKeep = Math.max(0, Math.floor(trainProgress / this.terrain.segmentWidth) - 20);
                if (this.terrain.segments.length > minSegmentsToKeep + this.terrain.lookAhead + 20) {
                    this.terrain.segments.splice(0, this.terrain.segments.length - (this.terrain.lookAhead + 40));
                }
            },

            updateDisplays() {
                const state = gameManager.gameStates.express;

                const steamDisplay = document.getElementById('expressSteamDisplay');
                const distanceDisplay = document.getElementById('expressDistanceDisplay');
                const speedDisplay = document.getElementById('expressSpeedDisplay');
                const roundDisplay = document.getElementById('expressTrainRoundNumber');
                const steamPoints = document.getElementById('expressSteamPoints');
                const toStationDisplay = document.getElementById('expressToStation');
                const totalDistDisplay = document.getElementById('expressTotalDistance');

                if (steamDisplay) steamDisplay.textContent = state.resources;
                if (steamPoints) steamPoints.textContent = state.resources;
                if (distanceDisplay) distanceDisplay.textContent = this.currentRoundDistance;
                // Speed display scaled by 10x for more readable numbers (velocity units to display units)
                if (speedDisplay) speedDisplay.textContent = Math.floor(Math.abs(this.train.velocityX) * 10);
                if (roundDisplay) roundDisplay.textContent = state.round;
                if (toStationDisplay) toStationDisplay.textContent = Math.max(0, this.roundTargetDistance - this.currentRoundDistance);
                if (totalDistDisplay) totalDistDisplay.textContent = state.totalDistance + this.currentRoundDistance;

                // Update speedometer needle
                this.updateSpeedometer();
            },

            updateSpeedometer() {
                const needle = document.getElementById('expressSpeedNeedle');
                if (!needle) return;

                const currentSpeed = Math.abs(this.train.velocityX);

                if (currentSpeed > 10) {
                    needle.classList.add('redline');
                } else {
                    needle.classList.remove('redline');
                    const maxDisplaySpeed = 10;
                    const clampedSpeed = Math.min(currentSpeed, maxDisplaySpeed);
                    const rotation = -90 + (clampedSpeed / maxDisplaySpeed) * 180;
                    needle.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
                }
            },

            addCoalPoint() {
                this.updateCoalDisplay(true);
            },

            updateCoalDisplay(animate = false) {
                const state = gameManager.gameStates.express;
                const pointsEl = document.getElementById('expressSteamPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('expressCoalDisplay', state.resources, 'coal-point', animate);
            },

            handleTrainKeyPress(e) {
                if (!this.gameRunning) return;

                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        this.boost();
                        break;
                    case 'Enter':
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        e.preventDefault();
                        this.brake();
                        break;
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.updateTerrain();
                this.updateTrainPhysics();
                this.updateDisplays();
                this.render();

                // Check if train stopped
                const state = gameManager.gameStates.express;
                if (Math.abs(this.train.velocityX) <= 0.1 && Math.abs(this.train.momentum) <= 0.1 &&
                    this.train.onGround && state.resources <= 0) {
                    this.endRound(false);
                    return;
                }

                requestAnimationFrame(() => this.gameLoop());
            },

            arriveAtStation() {
                this.gameRunning = false;
                const state = gameManager.gameStates.express;

                // Only add distance once
                if (!this.distanceAdded) {
                    state.totalDistance += this.currentRoundDistance;
                    this.distanceAdded = true;
                }

                // Show arrival overlay
                const trainPhase = document.getElementById('expressTrainPhase');
                const arrivalDiv = document.createElement('div');
                arrivalDiv.id = 'expressStationArrival';
                arrivalDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255,255,255,0.95);
                    padding: 30px;
                    border-radius: 15px;
                    text-align: center;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                    z-index: 100;
                `;
                arrivalDiv.innerHTML = `
                    <h2 style="color: #27ae60; font-size: 2em; margin: 0;">üöâ Station Reached! üöâ</h2>
                    <p style="font-size: 1.3em; color: #2c3e50; margin: 15px 0;">Round ${state.round} Complete!</p>
                    <p style="font-size: 1em; color: #7f8c8d;">Distance This Round: ${this.currentRoundDistance}</p>
                    <p style="font-size: 1em; color: #7f8c8d;">Total Distance: ${state.totalDistance}</p>
                    <p style="font-size: 1em; color: #7f8c8d;">Steam Remaining: ${state.resources}</p>
                    <button onclick="expressGame.startNextRound()" style="margin-top: 15px; padding: 10px 25px; font-size: 1.1em; background: #27ae60; color: white; border: none; border-radius: 8px; cursor: pointer;">Next Round</button>
                `;
                trainPhase.appendChild(arrivalDiv);

                sounds.playButtonClick();
            },

            endRound(reachedStation) {
                this.gameRunning = false;
                const state = gameManager.gameStates.express;

                // Only add distance once
                if (!this.distanceAdded) {
                    state.totalDistance += this.currentRoundDistance;
                    this.distanceAdded = true;
                }

                setTimeout(() => {
                    if (this.currentRoundDistance > 50) {
                        // Use shared round complete screen
                        showRoundComplete({
                            'Distance Traveled': Math.round(this.currentRoundDistance) + 'm',
                            'Total Distance': state.totalDistance + 'm'
                        });
                    } else {
                        showGameOver();
                    }
                }, 1000);
            },

            startNextRound() {
                sounds.playButtonClick();
                const arrivalDiv = document.getElementById('expressStationArrival');
                if (arrivalDiv) arrivalDiv.remove();

                const state = gameManager.gameStates.express;
                state.round++;

                // Hide express game container, show shared container
                document.getElementById('expressGame').classList.remove('active');
                document.getElementById('expressGame').style.display = 'none';
                document.getElementById('sharedGameContainer').style.display = 'block';
                document.getElementById('sharedGameContainer').classList.add('active');

                startMathPhase();
            },

            render() {
                if (!this.ctx) return;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const cameraX = Math.max(0, this.train.x - this.canvas.width / 3);

                // Draw background
                this.drawBackground(cameraX);

                // Draw station if approaching
                const state = gameManager.gameStates.express;
                const stationX = this.roundTargetDistance * 20;
                if (stationX > 0 && stationX >= cameraX - 100 && stationX <= cameraX + this.canvas.width + 100) {
                    this.drawStation(stationX - cameraX, state.round);
                }

                // Draw terrain
                this.drawTerrain(cameraX);

                // Draw all train cars
                this.drawAllTrainCars(cameraX);

                // Draw speed trail
                if ((!this.train.onGround && Math.abs(this.train.velocityX) > 3) || Math.abs(this.train.velocityX) > 8) {
                    this.drawSpeedTrail(cameraX);
                }
            },

            drawBackground(cameraX) {
                // Sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#98FB98');
                gradient.addColorStop(1, '#8B4513');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Clouds (slow parallax)
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.background.clouds.forEach(cloud => {
                    cloud.x -= cloud.speed;
                    if (cloud.x + cloud.width < 0) cloud.x = 1600;

                    const x = cloud.x - cameraX * 0.1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, cloud.y, cloud.height/2, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width * 0.25, cloud.y - cloud.height * 0.2, cloud.height/2.5, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width * 0.5, cloud.y, cloud.height/2.2, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width * 0.75, cloud.y - cloud.height * 0.1, cloud.height/2.5, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width, cloud.y, cloud.height/2, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Mountains (medium parallax)
                this.background.mountains.forEach(mountain => {
                    const x = mountain.x - cameraX * 0.3;

                    this.ctx.fillStyle = '#8B7355';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 200);
                    this.ctx.lineTo(x + mountain.width/2, 200 - mountain.height);
                    this.ctx.lineTo(x + mountain.width, 200);
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Snow cap
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + mountain.width/2 - 20, 200 - mountain.height + 20);
                    this.ctx.lineTo(x + mountain.width/2, 200 - mountain.height);
                    this.ctx.lineTo(x + mountain.width/2 + 20, 200 - mountain.height + 20);
                    this.ctx.closePath();
                    this.ctx.fill();
                });

                // Trees (fast parallax)
                this.background.trees.forEach(tree => {
                    const x = tree.x - cameraX * 0.5;

                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(x, 220 - tree.height, tree.width * 0.3, tree.height);

                    this.ctx.fillStyle = '#228B22';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - tree.width/2, 220 - tree.height * 0.6);
                    this.ctx.lineTo(x + tree.width * 0.15, 220 - tree.height - 10);
                    this.ctx.lineTo(x + tree.width/2 + tree.width * 0.3, 220 - tree.height * 0.6);
                    this.ctx.closePath();
                    this.ctx.fill();
                });
            },

            drawStation(screenX, round) {
                const stationY = this.getTerrainHeightAt(screenX + this.train.x - this.canvas.width/3);

                // Station building
                this.ctx.fillStyle = '#c0392b';
                this.ctx.fillRect(screenX - 60, stationY - 80, 120, 80);

                // Roof
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.beginPath();
                this.ctx.moveTo(screenX - 70, stationY - 80);
                this.ctx.lineTo(screenX, stationY - 110);
                this.ctx.lineTo(screenX + 70, stationY - 80);
                this.ctx.closePath();
                this.ctx.fill();

                // Windows
                this.ctx.fillStyle = '#f39c12';
                this.ctx.fillRect(screenX - 40, stationY - 60, 20, 20);
                this.ctx.fillRect(screenX - 10, stationY - 60, 20, 20);
                this.ctx.fillRect(screenX + 20, stationY - 60, 20, 20);

                // Door
                this.ctx.fillStyle = '#34495e';
                this.ctx.fillRect(screenX - 15, stationY - 40, 30, 40);

                // Sign
                this.ctx.fillStyle = '#ecf0f1';
                this.ctx.fillRect(screenX - 50, stationY - 100, 100, 20);
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`STATION ${round}`, screenX, stationY - 85);

                // Platform
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.fillRect(screenX - 80, stationY - 5, 160, 5);
            },

            drawTerrain(cameraX) {
                // Brown dirt
                this.ctx.fillStyle = '#8B4513';
                this.ctx.strokeStyle = '#654321';
                this.ctx.lineWidth = 2;

                this.ctx.beginPath();
                this.ctx.moveTo(-cameraX, this.canvas.height);

                const startSegment = Math.max(0, Math.floor(cameraX / this.terrain.segmentWidth) - 2);
                const endSegment = Math.min(this.terrain.segments.length - 1,
                    Math.floor((cameraX + this.canvas.width) / this.terrain.segmentWidth) + 2);

                for (let i = startSegment; i <= endSegment; i++) {
                    if (this.terrain.segments[i]) {
                        const segment = this.terrain.segments[i];
                        if (i === startSegment) {
                            this.ctx.lineTo(segment.x - cameraX, segment.y);
                        } else {
                            const prevSegment = this.terrain.segments[i - 1];
                            const controlX1 = prevSegment.x + this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY1 = prevSegment.y;
                            const controlX2 = segment.x - this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY2 = segment.y;
                            this.ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, segment.x - cameraX, segment.y);
                        }
                    }
                }

                this.ctx.lineTo(this.canvas.width + 100, this.canvas.height);
                this.ctx.lineTo(-cameraX, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                // Green grass on top
                this.ctx.fillStyle = '#228B22';
                this.ctx.beginPath();

                for (let i = startSegment; i <= endSegment; i++) {
                    if (this.terrain.segments[i]) {
                        const segment = this.terrain.segments[i];
                        if (i === startSegment) {
                            this.ctx.moveTo(segment.x - cameraX, segment.y - 5);
                        } else {
                            const prevSegment = this.terrain.segments[i - 1];
                            const controlX1 = prevSegment.x + this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY1 = prevSegment.y - 5;
                            const controlX2 = segment.x - this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY2 = segment.y - 5;
                            this.ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, segment.x - cameraX, segment.y - 5);
                        }
                    }
                }

                for (let i = endSegment; i >= startSegment; i--) {
                    if (this.terrain.segments[i]) {
                        const segment = this.terrain.segments[i];
                        this.ctx.lineTo(segment.x - cameraX, segment.y);
                    }
                }

                this.ctx.closePath();
                this.ctx.fill();
            },

            drawAllTrainCars(cameraX) {
                // Draw cars from back to front
                for (let i = this.trainCars.length - 1; i >= 0; i--) {
                    const car = this.trainCars[i];
                    const carX = car.x - cameraX;
                    const carY = car.y;

                    this.ctx.save();
                    this.ctx.translate(carX + this.train.width/2, carY + this.train.height/2);
                    this.ctx.rotate(car.angle);
                    this.ctx.translate(-(carX + this.train.width/2), -(carY + this.train.height/2));

                    switch(car.type) {
                        case 'engine':
                            this.drawSteamEngine(carX, carY, car.wheelRotation);
                            break;
                        case 'boxcar1':
                            this.drawBoxCar(carX, carY, '#3498db', car.wheelRotation);
                            break;
                        case 'boxcar2':
                            this.drawBoxCar(carX, carY, '#e74c3c', car.wheelRotation);
                            break;
                        case 'caboose':
                            this.drawCaboose(carX, carY, car.wheelRotation);
                            break;
                    }

                    this.ctx.restore();

                    // Draw coupler to next car
                    if (i > 0) {
                        const nextCar = this.trainCars[i - 1];
                        const nextCarX = nextCar.x - cameraX;
                        const nextCarY = nextCar.y;
                        this.drawCoupler(nextCarX - 5, nextCarY + this.train.height - 8,
                                        carX + this.train.width + 5, carY + this.train.height - 8);
                    }
                }

                // Draw smoke
                if (this.train.velocityX > 2) {
                    this.drawSmoke(this.train.x - cameraX, this.train.y);
                }
            },

            drawSteamEngine(x, y, wheelRotation) {
                const state = gameManager.gameStates.express;
                const cabColor = state.trainColor === 'blue' ? '#3498db' : '#e74c3c';

                // Main boiler
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(x + 10, y + 8, 50, 22);

                // Cab (uses selected color)
                this.ctx.fillStyle = cabColor;
                this.ctx.fillRect(x, y, 25, 25);

                // Smokestack
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(x + 44, y, 8, 15);
                this.ctx.fillRect(x + 42, y - 3, 12, 6);

                // Cow catcher
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.beginPath();
                this.ctx.moveTo(x + 60, y + 25);
                this.ctx.lineTo(x + 68, y + 32);
                this.ctx.lineTo(x + 60, y + 32);
                this.ctx.closePath();
                this.ctx.fill();

                // Windows
                this.ctx.fillStyle = '#5dade2';
                this.ctx.fillRect(x + 4, y + 5, 8, 8);
                this.ctx.fillRect(x + 14, y + 5, 8, 8);

                // Details
                this.ctx.fillStyle = '#f39c12';
                this.ctx.fillRect(x + 28, y + 12, 12, 3);
                this.ctx.fillRect(x + 15, y + 20, 30, 2);

                // Wheels
                this.drawWheel(x + 12, y + this.train.height + 5, 8, wheelRotation);
                this.drawWheel(x + 30, y + this.train.height + 5, 8, wheelRotation);
                this.drawWheel(x + 48, y + this.train.height + 5, 8, wheelRotation);
            },

            drawBoxCar(x, y, color, wheelRotation) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x + 5, y + 5, 50, 25);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(x + 3, y + 2, 54, 5);

                this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 30, y + 8);
                this.ctx.lineTo(x + 30, y + 28);
                this.ctx.stroke();

                this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                this.ctx.fillRect(x + 10, y + 12, 8, 8);
                this.ctx.fillRect(x + 42, y + 12, 8, 8);

                this.drawWheel(x + 15, y + this.train.height + 5, 7, wheelRotation);
                this.drawWheel(x + 45, y + this.train.height + 5, 7, wheelRotation);
            },

            drawCaboose(x, y, wheelRotation) {
                this.ctx.fillStyle = '#c0392b';
                this.ctx.fillRect(x + 10, y + 8, 40, 22);

                // Cupola
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillRect(x + 20, y, 20, 12);

                // Windows
                this.ctx.fillStyle = '#f39c12';
                this.ctx.fillRect(x + 23, y + 3, 6, 6);
                this.ctx.fillRect(x + 31, y + 3, 6, 6);
                this.ctx.fillRect(x + 15, y + 14, 6, 8);
                this.ctx.fillRect(x + 39, y + 14, 6, 8);

                // Platform
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.fillRect(x + 5, y + 28, 50, 3);

                this.drawWheel(x + 18, y + this.train.height + 5, 7, wheelRotation);
                this.drawWheel(x + 42, y + this.train.height + 5, 7, wheelRotation);
            },

            drawWheel(x, y, radius, rotation) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(rotation);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = '#7f8c8d';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI) / 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(Math.cos(angle) * radius * 0.8, Math.sin(angle) * radius * 0.8);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            },

            drawCoupler(x1, y1, x2, y2) {
                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.beginPath();
                this.ctx.arc(x1, y1, 4, 0, Math.PI * 2);
                this.ctx.arc(x2, y2, 4, 0, Math.PI * 2);
                this.ctx.fill();

                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                this.ctx.beginPath();
                this.ctx.arc(midX, midY, 3, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawSmoke(x, y) {
                const time = Date.now() * 0.001;
                const isBoostActive = this.train.momentum > 4;

                for (let i = 0; i < 8; i++) {
                    const age = i * 0.2;
                    const smokeX = x + 48 - (this.train.velocityX * age * 8) + Math.sin(time + i) * 5;
                    const smokeY = y - 5 - (age * 20) + Math.cos(time + i) * 3;
                    const size = 6 + age * 4;
                    const alpha = 0.6 - age * 0.15;

                    if (isBoostActive) {
                        this.ctx.fillStyle = `rgba(255,200,100,${alpha})`;
                    } else {
                        this.ctx.fillStyle = `rgba(200,200,200,${alpha})`;
                    }

                    this.ctx.beginPath();
                    this.ctx.arc(smokeX, smokeY, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            },

            drawSpeedTrail(cameraX) {
                const trailX = this.train.x - cameraX;
                const trailY = this.train.y + this.train.height;

                const trailIntensity = Math.min(Math.abs(this.train.velocityX) / 10, 1);
                const particleCount = Math.floor(5 + trailIntensity * 5);

                for (let i = 0; i < particleCount; i++) {
                    const offset = i * 10;
                    const alpha = (0.6 - (i * 0.1)) * trailIntensity;

                    if (this.train.onGround) {
                        this.ctx.strokeStyle = `rgba(255,255,100,${Math.max(0, alpha)})`;
                        this.ctx.lineWidth = Math.max(0.5, 2 - i * 0.3);
                        this.ctx.beginPath();
                        this.ctx.moveTo(trailX - offset, trailY);
                        this.ctx.lineTo(trailX - offset - 20, trailY);
                        this.ctx.stroke();
                    } else {
                        const radius = Math.max(0.5, 3 - i * 0.5);
                        if (alpha > 0) {
                            this.ctx.fillStyle = `rgba(255,255,100,${Math.max(0, alpha)})`;
                            this.ctx.beginPath();
                            this.ctx.arc(trailX - offset, trailY + offset * 0.5, radius, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }
        };

        // ===== FIELD GOAL GAME (Behind-View Perspective) =====
        const fieldgoalGame = {
            canvas: null,
            ctx: null,
            animationId: null,
            gameRunning: false,

            // Meter state
            meters: {
                direction: {
                    value: 50,
                    speed: 2,
                    increasing: true,
                    locked: false,
                    lockedValue: null
                },
                power: {
                    value: 0,
                    speed: 2.5,
                    increasing: true,
                    locked: false,
                    lockedValue: null
                }
            },

            // Game state
            kickPhase: 'waiting',
            roundGoalsMade: 0,
            requiredGoals: 3,
            resultMessage: '',
            resultColor: '',
            showingResult: false,

            // Ball physics (3D-like for behind view)
            ball: {
                x: 400,      // Left-right on screen
                y: 400,      // Near (bottom) to far (top)
                z: 0,        // Height above ground
                vx: 0,
                vy: 0,
                vz: 0,
                scale: 1.0,
                rotation: 0,
                visible: false
            },

            // Field setup
            field: {
                distance: 20,
                goalPostWidth: 100,
                wind: 0,
                goalPostOffset: 0,
                movingGoalPosts: false,
                movingSpeed: 0
            },

            // Crowd system
            crowd: {
                rows: 5,
                dotsPerRow: 50,
                state: 'neutral',
                animOffset: 0
            },

            // Referee system
            referees: {
                left: { armState: 'down' },
                right: { armState: 'down' },
                waveFrame: 0
            },

            // Visual elements
            particles: [],
            ballRotation: 0,

            init() {
                this.canvas = document.getElementById('fieldgoalCanvas');
                this.ctx = this.canvas.getContext('2d');
            },

            showKickPhase() {
                if (!this.canvas) this.init();

                const state = gameManager.gameStates.fieldgoal;
                state.phase = 'action';
                this.roundGoalsMade = 0;
                this.resultMessage = '';
                this.showingResult = false;

                // Reset referees
                this.referees.left.armState = 'down';
                this.referees.right.armState = 'down';
                this.crowd.state = 'neutral';

                // Set difficulty based on round
                const settings = this.getDifficultySettings(state.round);
                this.field.distance = settings.distance;
                this.field.wind = settings.wind;
                this.field.goalPostWidth = settings.goalWidth;
                this.field.movingGoalPosts = settings.movingGoalPosts;
                this.field.movingSpeed = settings.movingSpeed;
                this.field.goalPostOffset = 0;
                this.meters.direction.speed = settings.meterSpeed;
                this.meters.power.speed = settings.meterSpeed * 1.0;

                // Show kick phase
                document.getElementById('fieldgoalKickPhase').classList.remove('hidden');

                // Show power meter as inactive initially
                document.getElementById('powerMeterContainer').classList.remove('active');

                // Start game after countdown
                this.showCountdown(() => {
                    this.gameRunning = true;
                    sounds.playWhistle();
                    this.startKick();
                    this.gameLoop();
                });
            },

            showCountdown(callback) {
                let count = 3;
                this.render(); // Initial render

                const countdownDiv = document.createElement('div');
                countdownDiv.id = 'fieldgoalCountdown';
                countdownDiv.style.cssText = 'position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 5em; color: #fff; font-weight: bold; z-index: 100; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);';
                countdownDiv.textContent = count;
                document.getElementById('fieldgoalKickPhase').style.position = 'relative';
                document.getElementById('fieldgoalKickPhase').appendChild(countdownDiv);

                const interval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        countdownDiv.textContent = count;
                        sounds.playButtonClick();
                    } else {
                        countdownDiv.remove();
                        callback();
                        clearInterval(interval);
                    }
                }, 700);
            },

            startKick() {
                // Reset meters
                this.meters.direction.locked = false;
                this.meters.direction.lockedValue = null;
                this.meters.direction.value = 50;
                this.meters.direction.increasing = Math.random() > 0.5;

                this.meters.power.locked = false;
                this.meters.power.lockedValue = null;
                this.meters.power.value = 0;
                this.meters.power.increasing = true;

                this.kickPhase = 'direction';
                this.ball.visible = false;
                this.resultMessage = '';
                this.showingResult = false;

                // Reset referees
                this.referees.left.armState = 'down';
                this.referees.right.armState = 'down';
                this.crowd.state = 'neutral';

                // Update status
                document.getElementById('kickStatus').textContent = 'Press SPACE to set direction';
                document.getElementById('powerMeterContainer').classList.remove('active');
                document.getElementById('directionIndicator').classList.remove('locked');
                document.getElementById('powerIndicator').classList.remove('locked');
            },

            handleKick() {
                if (!this.gameRunning || this.showingResult) return;

                if (this.kickPhase === 'direction') {
                    this.lockDirection();
                } else if (this.kickPhase === 'power') {
                    this.lockPower();
                }
            },

            lockDirection() {
                this.meters.direction.locked = true;
                this.meters.direction.lockedValue = this.meters.direction.value;
                this.kickPhase = 'power';

                document.getElementById('directionIndicator').classList.add('locked');
                document.getElementById('powerMeterContainer').classList.add('active');
                document.getElementById('kickStatus').textContent = 'Press SPACE to set power';

                sounds.playButtonClick();
            },

            lockPower() {
                this.meters.power.locked = true;
                this.meters.power.lockedValue = this.meters.power.value;
                document.getElementById('powerIndicator').classList.add('locked');
                this.kickBall();
            },

            kickBall() {
                this.kickPhase = 'flying';
                const state = gameManager.gameStates.fieldgoal;
                state.resources--;

                document.getElementById('kickStatus').textContent = '';

                // Calculate trajectory from locked values
                const directionOffset = (this.meters.direction.lockedValue - 50) / 50; // -1 to 1
                const power = this.meters.power.lockedValue / 100; // 0 to 1

                // Set ball initial position and velocity (behind view)
                this.ball = {
                    x: 400,                          // Center of screen
                    y: 420,                          // Near bottom (close to viewer)
                    z: 0,                            // On ground
                    vx: directionOffset * 4,         // Lateral movement based on direction
                    vy: -(6 + power * 4),            // Forward velocity (toward goal)
                    vz: 8 + power * 6,               // Upward velocity
                    scale: 1.0,
                    rotation: 0,
                    visible: true
                };

                this.particles = [];
                sounds.playKick();
            },

            updateBall() {
                if (this.kickPhase !== 'flying' || !this.ball.visible) return;

                // Apply physics
                this.ball.x += this.ball.vx;
                this.ball.y += this.ball.vy;
                this.ball.z += this.ball.vz;
                this.ball.vz -= 0.4; // Gravity

                // Apply wind (affects x position)
                this.ball.vx += this.field.wind * 0.03;

                // Scale ball smaller as it gets further away
                const progress = (420 - this.ball.y) / 320;
                this.ball.scale = Math.max(0.2, 1.0 - progress * 0.7);

                // Rotation for visual spin
                this.ball.rotation += 0.15;

                // Add trail particles
                if (Math.random() > 0.6) {
                    this.particles.push({
                        x: this.ball.x,
                        y: this.ball.y,
                        alpha: 0.6,
                        size: 4 * this.ball.scale
                    });
                }

                // Check if ball reached goal area (y <= 130)
                if (this.ball.y <= 130) {
                    this.checkResult();
                }

                // Check if ball hit ground before reaching goal
                if (this.ball.z < 0 && this.ball.y > 130) {
                    this.showResult('SHORT!', false);
                }
            },

            calculateDoink(directionValue) {
                const distanceFromCenter = Math.abs(directionValue - 50);
                // Yellow zone: 10-25 from center
                if (distanceFromCenter >= 10 && distanceFromCenter <= 25) {
                    const doinkChance = (distanceFromCenter - 10) / 15;
                    if (Math.random() < doinkChance * 0.5) {
                        const goesIn = Math.random() < 0.2; // 20% chance doinks in
                        return { doink: true, goesIn };
                    }
                }
                return { doink: false };
            },

            checkResult() {
                const direction = this.meters.direction.lockedValue;
                const power = this.meters.power.lockedValue;

                // Check power first
                if (power < 45) {
                    this.showResult('SHORT!', false);
                    return;
                }

                // Check direction
                const dirOffset = Math.abs(direction - 50);

                // Account for moving goal posts
                let effectiveOffset = dirOffset;
                if (this.field.movingGoalPosts) {
                    const goalShift = this.field.goalPostOffset / 3;
                    if ((direction < 50 && goalShift > 0) || (direction > 50 && goalShift < 0)) {
                        effectiveOffset += Math.abs(goalShift);
                    } else {
                        effectiveOffset -= Math.abs(goalShift);
                    }
                }

                // Account for wind
                const windEffect = this.field.wind * 3;
                if ((direction < 50 && windEffect > 0) || (direction > 50 && windEffect < 0)) {
                    effectiveOffset += Math.abs(windEffect);
                } else {
                    effectiveOffset -= Math.abs(windEffect);
                }

                effectiveOffset = Math.max(0, effectiveOffset);

                if (effectiveOffset <= 10) {
                    // Clean make
                    this.showResult('THE KICK IS GOOD!', true);
                } else if (effectiveOffset <= 25) {
                    // Check for doink
                    const doinkResult = this.calculateDoink(direction);
                    if (doinkResult.doink) {
                        sounds.playDoink();
                        this.crowd.state = 'gasping';
                        if (doinkResult.goesIn) {
                            setTimeout(() => this.showResult('DOINK... GOOD!', true), 500);
                        } else {
                            setTimeout(() => this.showResult('DOINK... NO GOOD!', false), 500);
                        }
                        return;
                    }
                    // Close miss
                    if (direction < 50) {
                        this.showResult('WIDE LEFT!', false);
                    } else {
                        this.showResult('WIDE RIGHT!', false);
                    }
                } else {
                    // Clear miss
                    if (direction < 50) {
                        this.showResult('WIDE LEFT!', false);
                    } else {
                        this.showResult('WIDE RIGHT!', false);
                    }
                }
            },

            showResult(message, isGood) {
                this.kickPhase = 'result';
                this.resultMessage = message;
                this.resultColor = isGood ? '#27ae60' : '#e74c3c';
                this.showingResult = true;
                this.ball.visible = false;

                if (isGood) {
                    this.roundGoalsMade++;
                    gameManager.gameStates.fieldgoal.totalFieldGoalsMade++;
                    this.referees.left.armState = 'up';
                    this.referees.right.armState = 'up';
                    this.crowd.state = 'cheering';
                    sounds.playCrowdCheer();
                    this.createCelebrationParticles();
                } else {
                    this.referees.left.armState = 'waving';
                    this.referees.right.armState = 'waving';
                    this.crowd.state = 'groaning';
                    sounds.playCrowdGroan();
                }

                setTimeout(() => this.resetForNextKick(), 2000);
            },

            createCelebrationParticles() {
                for (let i = 0; i < 40; i++) {
                    this.particles.push({
                        x: 400 + (Math.random() - 0.5) * 100,
                        y: 130,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 4,
                        alpha: 1,
                        size: 6 + Math.random() * 6,
                        color: ['#27ae60', '#f1c40f', '#fff', '#3498db'][Math.floor(Math.random() * 4)]
                    });
                }
            },

            resetForNextKick() {
                const state = gameManager.gameStates.fieldgoal;
                this.showingResult = false;

                if (this.roundGoalsMade >= this.requiredGoals) {
                    this.endRound(true);
                    return;
                }

                if (state.resources <= 0) {
                    this.endRound(false);
                    return;
                }

                this.startKick();
            },

            updateMeters() {
                // Direction meter oscillates during direction phase
                if (this.kickPhase === 'direction' && !this.meters.direction.locked) {
                    if (this.meters.direction.increasing) {
                        this.meters.direction.value += this.meters.direction.speed;
                        if (this.meters.direction.value >= 100) {
                            this.meters.direction.increasing = false;
                        }
                    } else {
                        this.meters.direction.value -= this.meters.direction.speed;
                        if (this.meters.direction.value <= 0) {
                            this.meters.direction.increasing = true;
                        }
                    }
                }

                // Power meter oscillates during power phase
                if (this.kickPhase === 'power' && !this.meters.power.locked) {
                    if (this.meters.power.increasing) {
                        this.meters.power.value += this.meters.power.speed;
                        if (this.meters.power.value >= 100) {
                            this.meters.power.increasing = false;
                        }
                    } else {
                        this.meters.power.value -= this.meters.power.speed;
                        if (this.meters.power.value <= 0) {
                            this.meters.power.increasing = true;
                        }
                    }
                }

                this.updateMeterDisplay();
            },

            updateMeterDisplay() {
                const dirIndicator = document.getElementById('directionIndicator');
                const powerIndicator = document.getElementById('powerIndicator');

                if (dirIndicator) {
                    dirIndicator.style.left = this.meters.direction.value + '%';
                }
                if (powerIndicator) {
                    powerIndicator.style.bottom = this.meters.power.value + '%';
                }
            },

            updateGoalPosts() {
                if (this.field.movingGoalPosts) {
                    this.field.goalPostOffset = Math.sin(Date.now() / 1000 * this.field.movingSpeed) * 40;
                }
            },

            getDifficultySettings(round) {
                return {
                    distance: 20 + (round - 1) * 10,
                    meterSpeed: 1.5 + (round - 1) * 0.35,
                    wind: round >= 4 ? (Math.random() - 0.5) * (round - 2) * 1.5 : 0,
                    goalWidth: Math.max(50, 110 - (round - 1) * 10),
                    movingGoalPosts: round >= 6,
                    movingSpeed: round >= 6 ? 0.8 + (round - 6) * 0.3 : 0
                };
            },

            endRound(success) {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }

                const state = gameManager.gameStates.fieldgoal;

                if (success) {
                    showRoundComplete({
                        'Field Goals': `${this.roundGoalsMade}/${this.requiredGoals}`,
                        'Distance': `${this.field.distance} yards`,
                        'Total Goals': state.totalFieldGoalsMade
                    });
                } else {
                    showGameOver();
                }
            },

            updateParticles() {
                this.particles = this.particles.filter(p => {
                    p.alpha -= 0.02;
                    if (p.vx !== undefined) {
                        p.x += p.vx;
                        p.y += p.vy;
                        if (p.vy !== undefined) p.vy += 0.1;
                    }
                    return p.alpha > 0;
                });

                // Update crowd animation
                if (this.crowd.state === 'cheering') {
                    this.crowd.animOffset += 0.3;
                }

                // Update referee wave animation
                if (this.referees.left.armState === 'waving') {
                    this.referees.waveFrame += 0.2;
                }
            },

            // ===== RENDERING =====
            render() {
                const ctx = this.ctx;
                const state = gameManager.gameStates.fieldgoal;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawSky(ctx);
                this.drawCrowd(ctx, state.teamColor);
                this.drawScoreboard(ctx, state);
                this.drawField(ctx);
                this.drawEndzone(ctx, state.teamColor);
                this.drawGoalPosts(ctx);
                this.drawReferees(ctx);
                this.drawBallOnTee(ctx);
                this.drawFlyingBall(ctx);
                this.drawParticles(ctx);
                this.drawWindIndicator(ctx, state);
                this.drawResultMessage(ctx);
            },

            drawSky(ctx) {
                const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.5, '#16213e');
                gradient.addColorStop(1, '#0f3460');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, 200);
            },

            drawCrowd(ctx, teamColor) {
                const color = teamColor === 'blue' ? '#3498db' : '#e74c3c';
                const darkColor = teamColor === 'blue' ? '#2980b9' : '#c0392b';

                for (let row = 0; row < this.crowd.rows; row++) {
                    const y = 30 + row * 18;
                    const rowWidth = 700 - row * 40;
                    const startX = (this.canvas.width - rowWidth) / 2;
                    const dotCount = Math.floor(rowWidth / 14);

                    for (let i = 0; i < dotCount; i++) {
                        const x = startX + i * 14 + (row % 2) * 7;
                        let bounceY = 0;

                        if (this.crowd.state === 'cheering') {
                            bounceY = Math.sin((i + this.crowd.animOffset) * 0.5) * 4;
                        } else if (this.crowd.state === 'groaning') {
                            bounceY = 3;
                        }

                        ctx.fillStyle = (i + row) % 3 === 0 ? darkColor : color;
                        ctx.beginPath();
                        ctx.arc(x, y + bounceY, 5 - row * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            },

            drawScoreboard(ctx, state) {
                // Scoreboard background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(200, 5, 400, 50);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 2;
                ctx.strokeRect(200, 5, 400, 50);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';

                // Stats line
                ctx.fillText(`${this.field.distance} YARDS`, 280, 25);
                ctx.fillText(`${this.roundGoalsMade}/3 GOALS`, 400, 25);
                ctx.fillText(`${state.resources} BALLS`, 520, 25);

                // Round
                ctx.fillStyle = '#f1c40f';
                ctx.fillText(`ROUND ${state.round}`, 400, 45);
            },

            drawField(ctx) {
                // Field with perspective (trapezoid)
                ctx.fillStyle = '#1e7d32';
                ctx.beginPath();
                ctx.moveTo(50, 450);   // Bottom left
                ctx.lineTo(750, 450);  // Bottom right
                ctx.lineTo(550, 180);  // Top right
                ctx.lineTo(250, 180);  // Top left
                ctx.closePath();
                ctx.fill();

                // Yard lines with perspective
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const progress = i / 8;
                    const y = 450 - progress * 270;
                    const leftX = 50 + progress * 200;
                    const rightX = 750 - progress * 200;

                    ctx.beginPath();
                    ctx.moveTo(leftX, y);
                    ctx.lineTo(rightX, y);
                    ctx.stroke();
                }
            },

            drawEndzone(ctx, teamColor) {
                const color = teamColor === 'blue' ? '#2980b9' : '#c0392b';

                // Endzone (behind goal posts)
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(250, 180);
                ctx.lineTo(550, 180);
                ctx.lineTo(530, 140);
                ctx.lineTo(270, 140);
                ctx.closePath();
                ctx.fill();

                // Endzone text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('END ZONE', 400, 168);
            },

            drawGoalPosts(ctx) {
                const centerX = 400 + this.field.goalPostOffset;
                const width = this.field.goalPostWidth;
                const crossbarY = 130;

                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';

                // Left post
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, 180);
                ctx.lineTo(centerX - width/2, crossbarY);
                ctx.stroke();

                // Right post
                ctx.beginPath();
                ctx.moveTo(centerX + width/2, 180);
                ctx.lineTo(centerX + width/2, crossbarY);
                ctx.stroke();

                // Crossbar
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, crossbarY);
                ctx.lineTo(centerX + width/2, crossbarY);
                ctx.stroke();

                // Upper extensions
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, crossbarY);
                ctx.lineTo(centerX - width/2 - 5, crossbarY - 50);
                ctx.moveTo(centerX + width/2, crossbarY);
                ctx.lineTo(centerX + width/2 + 5, crossbarY - 50);
                ctx.stroke();
            },

            drawReferees(ctx) {
                this.drawReferee(ctx, 200, 175, this.referees.left);
                this.drawReferee(ctx, 600, 175, this.referees.right);
            },

            drawReferee(ctx, x, y, ref) {
                // Body (black and white stripes)
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(x - 6, y, 12, 20);

                // Head
                ctx.fillStyle = '#fdbf6f';
                ctx.beginPath();
                ctx.arc(x, y - 6, 6, 0, Math.PI * 2);
                ctx.fill();

                // Arms based on state
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;

                if (ref.armState === 'up') {
                    // Arms raised (touchdown/good signal)
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 5);
                    ctx.lineTo(x - 15, y - 15);
                    ctx.moveTo(x + 6, y + 5);
                    ctx.lineTo(x + 15, y - 15);
                    ctx.stroke();
                } else if (ref.armState === 'waving') {
                    // Arms waving (no good signal)
                    const wave = Math.sin(this.referees.waveFrame) * 10;
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 5);
                    ctx.lineTo(x - 18 + wave, y);
                    ctx.moveTo(x + 6, y + 5);
                    ctx.lineTo(x + 18 - wave, y);
                    ctx.stroke();
                } else {
                    // Arms down
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 5);
                    ctx.lineTo(x - 10, y + 15);
                    ctx.moveTo(x + 6, y + 5);
                    ctx.lineTo(x + 10, y + 15);
                    ctx.stroke();
                }
            },

            drawBallOnTee(ctx) {
                if (this.kickPhase === 'direction' || this.kickPhase === 'power') {
                    // Tee
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.moveTo(390, 415);
                    ctx.lineTo(410, 415);
                    ctx.lineTo(405, 405);
                    ctx.lineTo(395, 405);
                    ctx.closePath();
                    ctx.fill();

                    // Ball on tee
                    this.drawFootball(ctx, 400, 395, 1.0, 0);
                }
            },

            drawFlyingBall(ctx) {
                if (this.ball.visible) {
                    // Calculate screen position based on 3D coords
                    const screenY = this.ball.y - this.ball.z * 0.5;
                    this.drawFootball(ctx, this.ball.x, screenY, this.ball.scale, this.ball.rotation);
                }
            },

            drawFootball(ctx, x, y, scale, rotation) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                // Football shape
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = '#5d3a1a';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Laces
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, 0);
                ctx.lineTo(6, 0);
                ctx.stroke();

                // Cross laces
                for (let i = -4; i <= 4; i += 4) {
                    ctx.beginPath();
                    ctx.moveTo(i, -4);
                    ctx.lineTo(i, 4);
                    ctx.stroke();
                }

                ctx.restore();
            },

            drawParticles(ctx) {
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color || '#8B4513';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            },

            drawWindIndicator(ctx, state) {
                if (state.round >= 4 && this.field.wind !== 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(650, 60, 140, 35);

                    ctx.fillStyle = '#87CEEB';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('WIND', 720, 75);

                    const windDir = this.field.wind > 0 ? '‚Üí' : '‚Üê';
                    const windStrength = Math.abs(this.field.wind).toFixed(1);
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(`${windDir.repeat(Math.min(3, Math.ceil(Math.abs(this.field.wind))))} ${windStrength}`, 720, 92);
                }
            },

            drawResultMessage(ctx) {
                if (this.showingResult && this.resultMessage) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(150, 200, 500, 80);

                    ctx.fillStyle = this.resultColor;
                    ctx.font = 'bold 40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.resultMessage, 400, 255);
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.updateMeters();
                this.updateGoalPosts();
                this.updateBall();
                this.updateParticles();
                this.render();

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            handleKeyPress(e) {
                if (!this.gameRunning) return;

                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    this.handleKick();
                }

                // Dev mode
                if (e.key === '=' || e.key === '+') {
                    if (gameManager.gameStates.fieldgoal.devMode) {
                        gameManager.gameStates.fieldgoal.resources += 5;
                    }
                }
            }
        };

        // Add keyboard listener for fieldgoal game
        document.addEventListener('keydown', (e) => {
            if (currentGameType === 'fieldgoal') {
                fieldgoalGame.handleKeyPress(e);
            }
        });

        // Initialize the hub as active when page loads
        document.getElementById('gameHub').classList.add('active');
    </script>
</body>
</html>