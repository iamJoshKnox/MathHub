<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Adventure Hub</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        body {
            padding: 10px 20px;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 20px 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            max-width: 1000px;
            width: 100%;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }

        /* Hub Styles */
        .hub-container {
            text-align: center;
            position: relative;
        }

        .hub-header {
            margin-bottom: 40px;
        }

        .hub-title {
            font-size: 3.5em;
            color: #2c3e50;
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .hub-subtitle {
            font-size: 1.3em;
            color: #7f8c8d;
            margin: 0;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .game-card {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 25px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .game-card.castle {
            background: linear-gradient(145deg, #3498db, #e8f6f3);
            color: white;
        }

        .game-card.express {
            background: linear-gradient(145deg, #2c3e50, #7f8c8d);
            color: white;
        }

        .game-card.miner {
            background: linear-gradient(145deg, #8B4513, #D2691E);
            color: white;
        }

        .game-card.plane {
            background: linear-gradient(145deg, #002244, #B3D4FC);
            color: white;
        }

        .game-card.fieldgoal {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            color: white;
        }

        .game-card.minigolf {
            background: linear-gradient(145deg, #2d5016, #e8f6f3);
            color: white;
        }

        .game-card.motorcycle {
            background: linear-gradient(145deg, #c0392b, #e8f6f3);
            color: white;
        }

        .game-card.snowball {
            background: linear-gradient(145deg, #74b9ff, #dfe6e9);
            color: #2d3436;
        }

        .game-icon {
            font-size: 4em;
            margin-bottom: 15px;
            display: block;
        }

        .game-title {
            font-size: 1.4em;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .game-description {
            font-size: 0.9em;
            line-height: 1.4;
            opacity: 0.9;
        }

        .global-settings {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .sound-toggle {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .sound-toggle:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .sound-toggle.muted {
            background: #95a5a6;
        }

        /* Shared Game Styles */
        .game-container {
            display: none;
        }

        .game-container.active {
            display: block;
        }

        .phase-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .phase-title {
            font-size: 2.5em;
            color: #2c3e50;
            margin: 0;
        }

        .timer {
            font-size: 1.5em;
            color: #e74c3c;
            margin: 10px 0;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            z-index: 1000;
        }

        .back-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        /* Math Phase Styles */
        .math-phase {
            text-align: center;
        }

        .problem-display {
            font-size: 3em;
            color: #2c3e50;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            position: relative;
            transition: background-color 0.3s ease;
        }

        .problem-display.correct {
            background-color: #d4edda;
        }

        .problem-display.incorrect {
            background-color: #f8d7da;
        }

        .feedback-icon {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            font-size: 2em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .feedback-icon.show {
            opacity: 1;
        }

        .feedback-icon.correct {
            color: #28a745;
        }

        .feedback-icon.incorrect {
            color: #dc3545;
        }

        .input-section {
            margin: 20px 0;
        }

        .answer-input {
            font-size: 2em;
            padding: 10px 20px;
            border: 3px solid #3498db;
            border-radius: 10px;
            text-align: center;
            width: 200px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .numberpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 20px auto;
        }

        .numberpad button {
            padding: 15px 20px;
            font-size: 1.5em;
            border: none;
            border-radius: 10px;
            background: #3498db;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .numberpad button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .numberpad button.wide {
            grid-column: span 2;
        }

        .score-display {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            font-size: 1.2em;
        }

        .score-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .score-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #e74c3c;
        }

        /* Action Phase Styles */
        .action-phase {
            text-align: center;
        }

        /* Castle Game Visual Point Display */
        .cannon-point {
            width: 20px;
            height: 20px;
            background: #f1c40f;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #d4a600;
            position: relative;
        }

        .cannon-point::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #e8b800;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .cannon-point-large {
            width: 30px;
            height: 30px;
            background: #d4a600;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 2px solid #b38f00;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .cannon-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.7em;
        }

        /* Shared Point Animation */
        @keyframes pointDrop {
            from {
                transform: translateY(-20px) scale(0.5);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* Shared Points Display Container */
        .points-display {
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            margin: 10px 0;
            min-height: 40px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 2px;
        }

        /* Gap between 5th and 6th point for grouping by 5s */
        .point-gap {
            margin-left: 12px !important;
        }

        /* Express Game Visual Point Display */
        .coal-point {
            width: 18px;
            height: 18px;
            background: #2c3e50;
            border-radius: 3px;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 1px solid #1a1a1a;
        }

        .coal-point-large {
            width: 25px;
            height: 25px;
            background: #1a1a1a;
            border-radius: 3px;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 1px solid #000;
        }

        .coal-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.6em;
        }

        /* Miner Game Visual Point Display */
        .dig-point {
            width: 20px;
            height: 20px;
            background: #8B4513;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #5D2E0C;
            position: relative;
        }

        .dig-point::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #A0522D;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .dig-point-large {
            width: 30px;
            height: 30px;
            background: #5D2E0C;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 2px solid #3E1F08;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .dig-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.7em;
        }

        /* Plane Game Visual Point Display */
        .wind-point {
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #2980b9;
            position: relative;
        }

        .wind-point::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #5dade2;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .wind-point-large {
            width: 30px;
            height: 30px;
            background: #2980b9;
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            position: relative;
            border: 2px solid #1f618d;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .wind-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.7em;
        }

        /* Football point styles */
        .football-point {
            width: 22px;
            height: 14px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 1px solid #3d2817;
        }

        .football-point-large {
            width: 32px;
            height: 20px;
            background: linear-gradient(145deg, #8B4513, #654321);
            border-radius: 50%;
            display: inline-block;
            margin: 2px;
            animation: pointDrop 0.5s ease-out;
            border: 2px solid #3d2817;
            position: relative;
        }

        .football-point-large::after {
            content: '10';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 0.6em;
        }

        /* Field Goal Game Area */
        .fieldgoal-game-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        /* Direction Meter - Horizontal with color gradient */
        .direction-meter-container {
            width: 600px;
            margin: 10px auto;
        }

        .direction-meter-bar {
            height: 35px;
            border-radius: 17px;
            position: relative;
            overflow: hidden;
            border: 3px solid #2c3e50;
            background: linear-gradient(to right,
                #e74c3c 0%,
                #e67e22 15%,
                #f1c40f 30%,
                #2ecc71 45%,
                #27ae60 50%,
                #2ecc71 55%,
                #f1c40f 70%,
                #e67e22 85%,
                #e74c3c 100%
            );
        }

        .direction-meter-indicator {
            position: absolute;
            width: 8px;
            height: 100%;
            background: #2c3e50;
            border-radius: 4px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: none;
        }

        .direction-meter-indicator.locked {
            background: #fff;
            box-shadow: 0 0 10px #fff, 0 0 20px #fff;
        }

        .direction-meter-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.85em;
            color: #7f8c8d;
            font-weight: bold;
        }

        /* Power Meter - Vertical thermometer style */
        .power-meter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.4;
            transition: opacity 0.3s;
        }

        .power-meter-container.active {
            opacity: 1;
        }

        .power-meter-label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
            font-size: 0.85em;
        }

        .power-meter-bar {
            width: 40px;
            height: 300px;
            background: linear-gradient(to top,
                #e74c3c 0%,
                #e67e22 20%,
                #f1c40f 40%,
                #2ecc71 60%,
                #27ae60 75%,
                #f1c40f 90%,
                #e74c3c 100%
            );
            border-radius: 20px;
            border: 3px solid #2c3e50;
            position: relative;
            overflow: hidden;
        }

        .power-meter-indicator {
            position: absolute;
            width: 100%;
            height: 6px;
            background: #2c3e50;
            bottom: 0%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            transition: none;
        }

        .power-meter-indicator.locked {
            background: #fff;
            box-shadow: 0 0 10px #fff;
        }

        /* Kick Status */
        .kick-status {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 10px;
        }

        /* Mini Golf Styles */
        .minigolf-game-area {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            position: relative;
        }

        .minigolf-power-meter {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .minigolf-power-bar {
            width: 35px;
            height: 250px;
            background: linear-gradient(to top,
                #27ae60 0%,
                #2ecc71 30%,
                #f1c40f 60%,
                #e67e22 80%,
                #e74c3c 100%
            );
            border-radius: 18px;
            border: 3px solid #2c3e50;
            position: relative;
            overflow: hidden;
        }

        .minigolf-power-fill {
            position: absolute;
            top: 0;
            width: 100%;
            height: 0%;
            background: rgba(0,0,0,0.6);
            transition: none;
        }

        .putt-status {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 15px;
        }

        .race-status {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 15px;
        }

        .coal-counter {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .coal-display {
            background: #34495e;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            min-height: 35px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .game-canvas {
            border: 3px solid #34495e;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: #ecf0f1;
        }

        .action-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            font-size: 1.1em;
        }

        /* Math configuration tiles on hub */
        .math-config-hub {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px 20px;
            margin: 0 auto 20px auto;
            max-width: 800px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .config-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 8px 0;
            flex-wrap: nowrap;
        }

        .config-label {
            font-size: 0.9em;
            color: #7f8c8d;
            font-weight: bold;
            min-width: 50px;
        }

        .config-tiles {
            display: flex;
            gap: 6px;
            flex-wrap: nowrap;
            justify-content: center;
        }

        .config-tile {
            padding: 8px 12px;
            border-radius: 8px;
            background: #ecf0f1;
            border: 2px solid transparent;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
            min-width: 40px;
            text-align: center;
        }

        .config-tile:hover {
            background: #e8f4f8;
            transform: scale(1.05);
        }

        .config-tile.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
            box-shadow: 0 2px 6px rgba(52, 152, 219, 0.4);
        }

        /* Difficulty config below games */
        .difficulty-config-hub {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px 20px;
            margin: 20px auto 0 auto;
            max-width: 400px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Colored difficulty tiles */
        .config-tile.difficulty-easy {
            background: #e8f8e8;
            border-color: #27ae60;
        }

        .config-tile.difficulty-easy:hover {
            background: #d4f0d4;
        }

        .config-tile.difficulty-easy.selected {
            background: #27ae60;
            border-color: #1e8449;
            box-shadow: 0 2px 6px rgba(39, 174, 96, 0.4);
        }

        .config-tile.difficulty-medium {
            background: #fef5e7;
            border-color: #e67e22;
        }

        .config-tile.difficulty-medium:hover {
            background: #fdebd0;
        }

        .config-tile.difficulty-medium.selected {
            background: #e67e22;
            border-color: #d35400;
            box-shadow: 0 2px 6px rgba(230, 126, 34, 0.4);
        }

        .config-tile.difficulty-hard {
            background: #fdedec;
            border-color: #e74c3c;
        }

        .config-tile.difficulty-hard:hover {
            background: #fadbd8;
        }

        .config-tile.difficulty-hard.selected {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 2px 6px rgba(231, 76, 60, 0.4);
        }

        /* Coin display for math problems */
        .coin {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
            margin: 0 8px;
            border: 4px solid rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 3px 6px rgba(255, 255, 255, 0.4), 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .coin.penny {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #cd7f32, #b87333);
            color: #3d2817;
            font-size: 1.1em;
            border-color: #8b5a2b;
        }

        .coin.nickel {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, #a8a8a8, #888888);
            color: #333;
            font-size: 1.1em;
            border-color: #666;
        }

        .coin.dime {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #d0d0d0, #b0b0b0);
            color: #333;
            font-size: 1.1em;
            border-color: #888;
        }

        .coin.quarter {
            width: 100px;
            height: 100px;
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
            color: #333;
            font-size: 1.3em;
            border-color: #999;
        }

        /* Dollar bill for making change mode */
        .dollar-bill {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 180px;
            height: 100px;
            background: linear-gradient(145deg, #85bb65, #6b9b4f);
            color: #1a3d1a;
            font-weight: bold;
            font-size: 1.3em;
            border-radius: 8px;
            border: 4px solid #4a7c3a;
            box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.3), 0 3px 6px rgba(0, 0, 0, 0.2);
            margin-right: 8px;
            vertical-align: middle;
        }

        .change-minus {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
            margin: 0 10px;
            vertical-align: middle;
        }

        /* Dice display for math problems */
        .dice-display {
            font-size: 3em;
            letter-spacing: 12px;
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
        }

        /* Styled equals sign for visual math problems */
        .math-equals {
            font-size: 1.8em;
            margin-left: 12px;
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
            color: #2c3e50;
        }

        /* Problem text container for visual problems */
        #problemText {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* Castle selection */
        .castle-selection {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 30px 0;
        }

        .castle-option {
            padding: 20px;
            border: 3px solid transparent;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background: #ecf0f1;
        }

        .castle-option:hover {
            transform: scale(1.05);
            background: #e8f4f8;
        }

        .castle-option.selected {
            border-color: #3498db;
            background: #e8f4f8;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .castle-preview {
            width: 150px;
            height: 150px;
            border-radius: 10px;
            border: 2px solid #34495e;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 60%, #3498db 100%);
        }

        .castle-name {
            margin-top: 10px;
            font-weight: bold;
            color: #2c3e50;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes needleOscillate {
            from { transform: translateX(-50%) rotate(85deg); }
            to { transform: translateX(-50%) rotate(95deg); }
        }

        .redline {
            background: #e74c3c !important;
            animation: needleOscillate 0.1s ease-in-out infinite alternate !important;
        }

        /* Gauge needles */
        #castleAngleNeedle, #castlePowerNeedle {
            transition: transform 0.15s ease-out;
        }

        /* Hidden utility class */
        .hidden {
            display: none !important;
        }

        /* Start button styles */
        .start-button {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 15px 30px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            margin: 20px 10px;
        }

        .start-button:hover {
            background: linear-gradient(145deg, #229954, #27ae60);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .games-grid {
                grid-template-columns: 1fr;
            }

            .hub-title {
                font-size: 2.5em;
            }

            .problem-display {
                font-size: 2em;
            }

            .answer-input {
                font-size: 1.5em;
            }
        }

        /* My Adventure Styles */
        .adventure-button {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .adventure-button:hover {
            background: linear-gradient(145deg, #8e44ad, #7d3c98);
            transform: translateY(-2px);
        }

        .adventure-title {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .adventure-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .adventure-tab {
            background: #ecf0f1;
            border: none;
            padding: 12px 24px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .adventure-tab:hover {
            background: #d5dbdb;
        }

        .adventure-tab.active {
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
        }

        .adventure-content {
            margin-top: 20px;
        }

        .stats-filter {
            margin-bottom: 15px;
            text-align: center;
        }

        .stats-filter select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: 2px solid #3498db;
            font-family: inherit;
            cursor: pointer;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .stats-table th,
        .stats-table td {
            padding: 12px 8px;
            text-align: center;
            border-bottom: 1px solid #ecf0f1;
        }

        .stats-table th {
            background: #2c3e50;
            color: white;
            font-weight: bold;
        }

        .stats-table th:first-child {
            border-radius: 8px 0 0 0;
        }

        .stats-table th:last-child {
            border-radius: 0 8px 0 0;
        }

        .stats-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .stats-table tr:hover {
            background: #e8f4f8;
        }

        .stats-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .stats-cell-row {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .stats-value {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stats-label {
            font-size: 0.75em;
            color: #7f8c8d;
        }

        .stats-number {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
        }

        .stats-stars {
            color: #f1c40f;
            font-size: 0.9em;
            min-height: 1.2em;
        }

        .stats-empty {
            color: #bdc3c7;
        }

        .mode-icon {
            font-size: 1.8em;
            display: block;
            margin-bottom: 4px;
        }

        .game-icon {
            font-size: 1.8em;
            display: block;
            margin-bottom: 4px;
        }

        /* ===== PROFILE SELECTOR ===== */
        .profile-selector-topleft {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        /* Profile display for game screens */
        .profile-display-game {
            position: absolute;
            top: 18px;
            right: 20px;
            z-index: 100;
        }

        .profile-display-game .profile-button {
            padding: 8px 14px;
            font-size: 0.95em;
            position: relative;
        }

        .profile-display-game .profile-button #gameProfileAvatar {
            font-size: 1.3em;
        }

        .profile-display-game.playing .profile-button {
            pointer-events: none;
            opacity: 0.8;
        }

        .profile-display-game.playing .dropdown-arrow {
            display: none;
        }

        /* DEV mode indicator */
        .dev-indicator {
            display: none;
            position: absolute;
            top: -5px;
            right: -5px;
            background: #e74c3c;
            color: white;
            font-size: 0.6em;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            z-index: 10;
        }

        .dev-indicator.active {
            display: block;
        }

        .profile-button {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .profile-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .profile-button #currentProfileAvatar {
            font-size: 1.5em;
        }

        .dropdown-arrow {
            font-size: 0.8em;
            margin-left: 5px;
        }

        .profile-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 220px;
            z-index: 1000;
            overflow: hidden;
            margin-top: 8px;
        }

        .profile-dropdown.show {
            display: block;
        }

        .profile-dropdown-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid #eee;
        }

        .profile-dropdown-item:hover {
            background: #f5f5f5;
        }

        .profile-dropdown-item.active {
            background: #e8f4fd;
        }

        .profile-dropdown-item .profile-avatar {
            font-size: 1.5em;
        }

        .profile-dropdown-item .profile-name {
            flex: 1;
            font-weight: 500;
            color: #333;
        }

        .profile-dropdown-item .check-mark {
            color: #27ae60;
            font-weight: bold;
        }

        .profile-dropdown-divider {
            height: 1px;
            background: #ddd;
            margin: 0;
        }

        .profile-dropdown-manage {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            color: #666;
            transition: background 0.2s;
        }

        .profile-dropdown-manage:hover {
            background: #f5f5f5;
        }

        /* ===== MODALS ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-content-small {
            max-width: 320px;
            text-align: center;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.3em;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: #333;
        }

        .modal-action-button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 16px;
            transition: transform 0.2s;
        }

        .modal-action-button:hover {
            transform: scale(1.02);
        }

        /* Profile List in Manager */
        .profile-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .profile-list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .profile-list-item .profile-avatar {
            font-size: 2em;
        }

        .profile-list-item .profile-avatar.clickable {
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: background 0.2s, transform 0.2s;
        }

        .profile-list-item .profile-avatar.clickable:hover {
            background: #e8f4fd;
            transform: scale(1.1);
        }

        .profile-list-item .profile-name {
            flex: 1;
            font-weight: 500;
            font-size: 1.1em;
        }

        .delete-profile-btn {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            color: #e74c3c;
            padding: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .delete-profile-btn:hover {
            opacity: 1;
        }

        /* Create Profile Form */
        .profile-form {
            margin-bottom: 10px;
        }

        .profile-form label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        .profile-form input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 16px;
            box-sizing: border-box;
        }

        .profile-form input[type="text"]:focus {
            border-color: #667eea;
            outline: none;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .avatar-option {
            font-size: 1.8em;
            padding: 8px;
            border: 3px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .avatar-option:hover {
            background: #f0f0f0;
        }

        .avatar-option.selected {
            border-color: #667eea;
            background: #e8f4fd;
        }

        /* Delete Confirm Modal */
        .delete-warning {
            color: #e74c3c;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .modal-button-danger {
            flex: 1;
            padding: 12px;
            background: #e74c3c;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1em;
            cursor: pointer;
        }

        .modal-button-danger:hover {
            background: #c0392b;
        }

        .modal-button-cancel {
            flex: 1;
            padding: 12px;
            background: #bdc3c7;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1em;
            cursor: pointer;
        }

        .modal-button-cancel:hover {
            background: #95a5a6;
        }
    </style>
</head>
<body>
    <!-- Game Hub -->
    <div id="gameHub" class="container hub-container">
        <!-- Profile Selector (Top Left) -->
        <div class="profile-selector-topleft">
            <button class="profile-button" onclick="toggleProfileDropdown()">
                <span id="currentProfileAvatar">ü¶ä</span>
                <span id="currentProfileName">Player 1</span>
                <span class="dropdown-arrow">‚ñº</span>
            </button>
            <div id="profileDropdown" class="profile-dropdown">
                <!-- Populated dynamically -->
            </div>
        </div>

        <div class="hub-header">
            <h1 class="hub-title">Math Adventure Hub</h1>
            <p class="hub-subtitle">Choose your mathematical adventure!</p>
        </div>

        <div class="math-config-hub">
            <div class="config-row">
                <span class="config-label">Mode:</span>
                <div class="config-tiles" id="problemTypeTiles">
                    <div class="config-tile selected" data-value="addition" onclick="selectProblemType('addition')">‚ûï</div>
                    <div class="config-tile" data-value="subtraction" onclick="selectProblemType('subtraction')">‚ûñ</div>
                    <div class="config-tile" data-value="multiplication" onclick="selectProblemType('multiplication')">‚úñÔ∏è</div>
                    <div class="config-tile" data-value="division" onclick="selectProblemType('division')">‚ûó</div>
                    <div class="config-tile" data-value="dice" onclick="selectProblemType('dice')">üé≤</div>
                    <div class="config-tile" data-value="coin" onclick="selectProblemType('coin')">ü™ô</div>
                    <div class="config-tile" data-value="change" onclick="selectProblemType('change')">üíµ</div>
                    <div class="config-tile" data-value="fractions" onclick="selectProblemType('fractions')">¬Ω</div>
                    <div class="config-tile" data-value="hundred" onclick="selectProblemType('hundred')">üíØ</div>
                </div>
            </div>
        </div>

        <div class="difficulty-config-hub">
            <div class="config-row">
                <span class="config-label">Difficulty:</span>
                <div class="config-tiles" id="difficultyTiles">
                    <div class="config-tile difficulty-easy selected" data-value="easy" onclick="selectDifficulty('easy')">Easy</div>
                    <div class="config-tile difficulty-medium" data-value="medium" onclick="selectDifficulty('medium')">Medium</div>
                    <div class="config-tile difficulty-hard" data-value="hard" onclick="selectDifficulty('hard')">Hard</div>
                </div>
            </div>
        </div>

        <div class="games-grid">
            <div class="game-card castle" onclick="selectGame('castle')">
                <div class="game-icon">üè∞</div>
                <div class="game-title">Math Castle</div>
                <div class="game-description">Defend your castle with cannon math! Solve problems to load cannons and defeat enemies.</div>
            </div>

            <div class="game-card express" onclick="selectGame('express')">
                <div class="game-icon">üöÇ</div>
                <div class="game-title">Math Express</div>
                <div class="game-description">All aboard the math train! Collect coal and steam to power your locomotive adventure.</div>
            </div>

            <div class="game-card miner" onclick="selectGame('miner')">
                <div class="game-icon">‚õèÔ∏è</div>
                <div class="game-title">Math Miner</div>
                <div class="game-description">Dig deep for treasure! Solve equations to power your mining equipment and find gold.</div>
            </div>

            <div class="game-card plane" onclick="selectGame('plane')">
                <div class="game-icon">‚úàÔ∏è</div>
                <div class="game-title">Math Plane</div>
                <div class="game-description">Soar through the sky! Use wind power from math problems to fly your paper airplane.</div>
            </div>

            <div class="game-card fieldgoal" onclick="selectGame('fieldgoal')">
                <div class="game-icon">üèà</div>
                <div class="game-title">Math Field Goals</div>
                <div class="game-description">Kick field goals! Solve problems to earn footballs and score through the uprights.</div>
            </div>

            <div class="game-card minigolf" onclick="selectGame('minigolf')">
                <div class="game-icon">‚õ≥</div>
                <div class="game-title">Math Mini Golf</div>
                <div class="game-description">Putt your way to victory! Solve problems to earn strokes and sink the ball.</div>
            </div>

            <div class="game-card motorcycle" onclick="selectGame('motorcycle')">
                <div class="game-icon">üèçÔ∏è</div>
                <div class="game-title">Math Racer</div>
                <div class="game-description">Race to the finish! Earn turbo boosts and dodge the edges.</div>
            </div>

            <div class="game-card snowball" onclick="selectGame('snowball')">
                <div class="game-icon">‚ùÑÔ∏è</div>
                <div class="game-title">Snowball Math</div>
                <div class="game-description">Knock down snowmen! Solve problems to earn snowballs and take aim.</div>
            </div>
        </div>

        <div class="global-settings">
            <button class="sound-toggle" id="globalSoundToggle" onclick="toggleGlobalSound()">üîä</button>
            <button class="adventure-button" onclick="showMyAdventure()">üìä My Adventure</button>
        </div>
    </div>

    <!-- My Adventure Screen -->
    <div id="myAdventureScreen" class="container" style="display: none; max-width: 1000px;">
        <button class="back-button" onclick="hideMyAdventure()">‚Üê Back to Hub</button>
        <h2 class="adventure-title">üìä My Adventure</h2>

        <!-- Tab Navigation -->
        <div class="adventure-tabs">
            <button class="adventure-tab active" id="mathProgressTab" onclick="showMathProgress()">üßÆ Math Progress</button>
            <button class="adventure-tab" id="gameProgressTab" onclick="showGameProgress()">üéÆ Game Progress</button>
        </div>

        <!-- Math Progress Table -->
        <div id="mathProgressContent" class="adventure-content">
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>Mode</th>
                        <th>Easy</th>
                        <th>Medium</th>
                        <th>Hard</th>
                    </tr>
                </thead>
                <tbody id="mathProgressBody">
                </tbody>
            </table>
        </div>

        <!-- Game Progress Table -->
        <div id="gameProgressContent" class="adventure-content" style="display: none;">
            <div class="stats-filter">
                <label>Mode Filter: </label>
                <select id="gameModeFilter" onchange="renderGameProgress()">
                    <option value="">All Modes</option>
                    <option value="addition">‚ûï Addition</option>
                    <option value="subtraction">‚ûñ Subtraction</option>
                    <option value="multiplication">‚úñÔ∏è Multiplication</option>
                    <option value="division">‚ûó Division</option>
                    <option value="dice">üé≤ Dice</option>
                    <option value="coin">ü™ô Coins</option>
                    <option value="change">üíµ Change</option>
                    <option value="fractions">¬Ω Fractions</option>
                    <option value="hundred">üíØ Hundred</option>
                </select>
            </div>
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>Game</th>
                        <th>Easy</th>
                        <th>Medium</th>
                        <th>Hard</th>
                    </tr>
                </thead>
                <tbody id="gameProgressBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Shared Game Container (used by all games for common screens) -->
    <div id="sharedGameContainer" class="container game-container" style="display: none;">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Shared Selection Screen -->
        <div id="gameSelectionScreen" class="phase-transition" style="text-align: center; position: relative;">
            <!-- Profile Display (Selection Screen) -->
            <div id="sharedProfileDisplay" class="profile-display-game">
                <button class="profile-button" onclick="toggleGameProfileDropdown('shared')">
                    <span id="sharedProfileAvatar">ü¶ä</span>
                    <span id="sharedProfileName">Player 1</span>
                    <span class="dropdown-arrow">‚ñº</span>
                    <span class="dev-indicator">DEV</span>
                </button>
                <div id="sharedProfileDropdown" class="profile-dropdown">
                    <!-- Populated dynamically -->
                </div>
            </div>
            <button id="devModeBtn" onclick="startDevMode()" style="position: absolute; bottom: 10px; right: 10px; padding: 5px 8px; font-size: 0.7em; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; opacity: 0.7;">DEV</button>
            <h2 class="phase-title" id="selectionTitle">üè∞ Math Castle</h2>
            <p id="selectionPrompt">Choose the castle you will defend!</p>

            <div class="castle-selection">
                <div class="castle-option selected" id="option0" onclick="selectOption(0)">
                    <canvas class="castle-preview" id="preview0" width="150" height="150"></canvas>
                    <div class="castle-name" id="optionName0">Red Kingdom</div>
                </div>
                <div class="castle-option" id="option1" onclick="selectOption(1)">
                    <canvas class="castle-preview" id="preview1" width="150" height="150"></canvas>
                    <div class="castle-name" id="optionName1">Blue Kingdom</div>
                </div>
            </div>

            <button class="start-button" id="startGameBtn" onclick="startMathPhase()">Start!</button>
        </div>

        <!-- Shared Math Phase -->
        <div id="gameMathPhase" class="math-phase hidden" style="position: relative;">
            <!-- Profile Display (Math Phase - non-interactive) -->
            <div id="mathPhaseProfileDisplay" class="profile-display-game playing">
                <button class="profile-button">
                    <span class="gameProfileAvatar">ü¶ä</span>
                    <span class="gameProfileName">Player 1</span>
                    <span class="dev-indicator">DEV</span>
                </button>
            </div>
            <button id="skipTimerBtn" onclick="skipMathTimer()" style="position: absolute; bottom: 10px; right: 10px; padding: 5px 8px; font-size: 0.7em; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; opacity: 0.7;">SKIP</button>
            <div class="phase-header">
                <h2 class="phase-title" id="mathPhaseTitle">üßÆ Math Battle - Round <span id="mathRoundNumber">1</span></h2>
                <div class="timer" id="mathTimer">60</div>
            </div>

            <div class="problem-display" id="problemDisplay">
                <div id="problemText">5 + 3 = ?</div>
                <div class="feedback-icon" id="feedbackIcon"></div>
            </div>

            <div class="input-section">
                <input type="text" class="answer-input" id="answerInput" readonly>

                <div class="numberpad">
                    <button onclick="addNumber('1')">1</button>
                    <button onclick="addNumber('2')">2</button>
                    <button onclick="addNumber('3')">3</button>
                    <button onclick="addNumber('4')">4</button>
                    <button onclick="addNumber('5')">5</button>
                    <button onclick="addNumber('6')">6</button>
                    <button onclick="addNumber('7')">7</button>
                    <button onclick="addNumber('8')">8</button>
                    <button onclick="addNumber('9')">9</button>
                    <button onclick="clearInput()" class="wide">Clear</button>
                    <button onclick="addNumber('0')">0</button>
                </div>
            </div>

            <div class="score-display">
                <div class="score-item">
                    <div><span id="resourceIcon">üî•</span> <span id="resourceName">Cannon Points</span>: <span id="resourceCount">0</span></div>
                    <div id="resourceDisplay" class="points-display"></div>
                </div>
            </div>
        </div>

        <!-- Shared Round Complete Screen -->
        <div id="roundCompleteScreen" class="phase-transition hidden" style="text-align: center;">
            <h2 class="phase-title" id="roundCompleteTitle" style="color: #27ae60; animation: bounce 0.5s ease-in-out infinite;">‚≠ê Nice Work! ‚≠ê</h2>
            <p>Round <span id="completedRoundNumber">1</span> Complete!</p>

            <div class="score-display" id="roundStats" style="flex-direction: column; gap: 15px; font-size: 1.3em; margin: 30px 0;">
                <!-- Populated dynamically -->
            </div>

            <button class="start-button" id="nextRoundBtn" onclick="startNextRound()">Next Round!</button>
        </div>

        <!-- Shared Game Over Screen -->
        <div id="gameOverScreen" class="phase-transition hidden" style="text-align: center;">
            <h2 class="phase-title" id="gameOverTitle" style="color: #e74c3c;">üè∞ Castle Fallen! üè∞</h2>

            <div class="score-display" id="gameOverStats" style="flex-direction: column; gap: 15px; font-size: 1.3em; margin: 30px 0;">
                <!-- Populated dynamically from config -->
            </div>

            <div style="display: flex; justify-content: center; gap: 15px;">
                <button class="start-button" id="playAgainBtn" onclick="playAgain()">Battle Again!</button>
                <button class="start-button" onclick="returnToHub()" style="background: linear-gradient(145deg, #95a5a6, #7f8c8d);">Return to Hub</button>
            </div>
        </div>
    </div>

    <!-- Math Castle Game -->
    <div id="castleGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display -->
        <div id="castleProfileDisplay" class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Cannon Phase (Action Phase) -->
        <div id="castleCannonPhase" class="action-phase hidden" style="position: relative;">
            <div class="phase-header">
                <h2 class="phase-title">üè∞ Defend the Castle - Round <span id="castleCannonRound">1</span></h2>
                <div style="display: flex; justify-content: center; gap: 20px; font-size: 1.1em;">
                    <span>üí£ <span id="castleCannonCount">0</span></span>
                    <span>üéØ <span id="castleTargetsDisplay">0</span> targets</span>
                </div>
            </div>

            <canvas id="castleGameCanvas" class="game-canvas" width="800" height="400"></canvas>

            <!-- Gauges Row -->
            <div style="display: flex; justify-content: center; gap: 40px; margin: 15px 0;">
                <!-- Angle Gauge -->
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 120px; height: 65px; position: relative;">
                        <svg width="120" height="65" viewBox="0 0 120 65">
                            <!-- Quarter circle arc from right (0¬∞) to top (90¬∞) -->
                            <path d="M 110 55 A 50 50 0 0 0 60 5" stroke="#3498db" stroke-width="6" fill="none"/>
                            <circle cx="60" cy="55" r="5" fill="#2c3e50"/>
                        </svg>
                        <div id="castleAngleNeedle" style="position: absolute; bottom: 10px; left: 60px; transform-origin: bottom center; width: 3px; height: 45px; background: #2c3e50; transform: translateX(-50%) rotate(45deg); border-radius: 2px;"></div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-weight: bold; font-size: 0.8em; color: #7f8c8d;">ANGLE</div>
                        <div id="castleAngleDisplay" style="font-weight: bold; color: #2c3e50;">45¬∞</div>
                    </div>
                </div>

                <!-- Power Gauge -->
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 120px; height: 60px; position: relative;">
                        <svg width="120" height="60" viewBox="0 0 120 60">
                            <!-- Red zone (low power) -->
                            <path d="M 10 50 A 50 50 0 0 1 43.3 10.4" stroke="#e74c3c" stroke-width="6" fill="none"/>
                            <!-- Yellow zone (medium power) -->
                            <path d="M 43.3 10.4 A 50 50 0 0 1 76.7 10.4" stroke="#f39c12" stroke-width="6" fill="none"/>
                            <!-- Green zone (high power) -->
                            <path d="M 76.7 10.4 A 50 50 0 0 1 110 50" stroke="#27ae60" stroke-width="6" fill="none"/>
                            <circle cx="60" cy="50" r="5" fill="#2c3e50"/>
                        </svg>
                        <div id="castlePowerNeedle" style="position: absolute; bottom: 10px; left: 60px; transform-origin: bottom center; width: 3px; height: 40px; background: #2c3e50; transform: translateX(-50%) rotate(0deg); border-radius: 2px;"></div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-weight: bold; font-size: 0.8em; color: #7f8c8d;">POWER</div>
                        <div id="castlePowerDisplay" style="font-weight: bold; color: #2c3e50;">50%</div>
                    </div>
                </div>
            </div>

            <!-- Buttons Row -->
            <div style="display: flex; justify-content: center; gap: 8px; margin: 10px 0; flex-wrap: wrap;">
                <button class="start-button" onclick="castleGame.fireCannon()" style="padding: 12px 25px; background: linear-gradient(145deg, #e74c3c, #c0392b);">
                    üéØ FIRE!
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(Space)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustAngle(3)" style="padding: 10px 15px;">
                    ‚ñ≤ UP
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üë)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustAngle(-3)" style="padding: 10px 15px;">
                    ‚ñº DOWN
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üì)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustPower(-5)" style="padding: 10px 15px;">
                    ‚óÄ LESS
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üê)</span>
                </button>
                <button class="start-button" onclick="castleGame.adjustPower(5)" style="padding: 10px 15px;">
                    ‚ñ∂ MORE
                    <span style="display: block; font-size: 0.7em; opacity: 0.8;">(‚Üí)</span>
                </button>
            </div>

            <div style="text-align: center; font-size: 0.9em; color: #7f8c8d;">
                Aim with buttons or arrow keys. Fire with button or spacebar. Hit all targets!
            </div>
        </div>
    </div>

    <!-- Math Express Game -->
    <div id="expressGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Train Phase (Action Phase) -->
        <div id="expressTrainPhase" class="action-phase hidden" style="position: relative;">
            <div class="phase-header">
                <h2 class="phase-title">üöÇ Train Run - Round <span id="expressTrainRoundNumber">1</span></h2>
                <div style="font-size: 0.9em; color: #7f8c8d;">Total Distance: <span id="expressTotalDistance">0</span></div>
                <div style="font-size: 1em; color: #27ae60; font-weight: bold;">Next Station in: <span id="expressToStation">200</span></div>
            </div>

            <canvas id="expressGameCanvas" class="game-canvas" width="800" height="300"></canvas>

            <div class="action-info" style="gap: 20px;">
                <div>üî• <span id="expressSteamDisplay">0</span> Steam</div>
                <div>üìè <span id="expressDistanceDisplay">0</span></div>
            </div>

            <div style="display: flex; justify-content: center; gap: 20px; margin: 15px 0; align-items: center;">
                <button class="start-button" id="expressBoostButton" onclick="expressGame.boost()" style="padding: 12px 20px; background: linear-gradient(145deg, #27ae60, #2ecc71); display: flex; align-items: center; gap: 8px;">
                    <span>üöÄ</span>
                    <span style="display: flex; flex-direction: column; align-items: flex-start; line-height: 1.2;">
                        <span style="font-weight: bold;">STEAM</span>
                        <span style="font-size: 0.7em; opacity: 0.8;">(Space)</span>
                    </span>
                </button>

                <!-- Speedometer -->
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 100px; height: 50px; position: relative;">
                        <svg width="100" height="50" viewBox="0 0 100 50">
                            <!-- Red zone (slow) -->
                            <path d="M 10 45 A 40 40 0 0 1 33 12" stroke="#e74c3c" stroke-width="5" fill="none"/>
                            <!-- Yellow zone (medium) -->
                            <path d="M 33 12 A 40 40 0 0 1 67 12" stroke="#f39c12" stroke-width="5" fill="none"/>
                            <!-- Green zone (fast) -->
                            <path d="M 67 12 A 40 40 0 0 1 90 45" stroke="#27ae60" stroke-width="5" fill="none"/>
                            <!-- Center dot -->
                            <circle cx="50" cy="45" r="4" fill="#2c3e50"/>
                        </svg>
                        <div id="expressSpeedNeedle" style="position: absolute; bottom: 8px; left: 50%; transform-origin: bottom center; width: 2px; height: 32px; background: #2c3e50; transform: translateX(-50%) rotate(-90deg); transition: transform 0.1s ease-out; border-radius: 1px;"></div>
                    </div>
                    <div style="font-weight: bold; font-size: 0.7em; color: #2c3e50;">SPEED: <span id="expressSpeedDisplay">0</span></div>
                </div>

                <button class="start-button" id="expressBrakeButton" onclick="expressGame.brake()" style="padding: 12px 20px; background: linear-gradient(145deg, #e74c3c, #c0392b); display: flex; align-items: center; gap: 8px;">
                    <span>üõë</span>
                    <span style="display: flex; flex-direction: column; align-items: flex-start; line-height: 1.2;">
                        <span style="font-weight: bold;">BRAKE</span>
                        <span style="font-size: 0.7em; opacity: 0.8;">(Enter)</span>
                    </span>
                </button>
            </div>
        </div>
    </div>

    <!-- Math Miner Game -->
    <div id="minerGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display (Playing Mode) -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Mining Phase (Action Phase) -->
        <div id="minerMiningPhase" class="action-phase hidden">
            <div class="phase-header">
                <h2 class="phase-title">‚õèÔ∏è Mining Time!</h2>
            </div>

            <canvas id="minerGameCanvas" class="game-canvas" width="512" height="384"></canvas>

            <div class="action-info">
                <div>‚õèÔ∏è <span id="minerDigRemaining">0</span> Dig Points</div>
                <div>ü™ô <span id="minerCoinsDisplay">0/3</span> Coins</div>
            </div>
        </div>
    </div>

    <!-- Math Plane Game -->
    <div id="planeGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display (Playing Mode) -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Flight Phase (Action Phase) -->
        <div id="planeFlightPhase" class="action-phase hidden">
            <div class="phase-header">
                <h2 class="phase-title">‚úàÔ∏è Paper Plane Flight - Round <span id="planeFlightRoundNumber">1</span></h2>
            </div>

            <canvas id="planeGameCanvas" class="game-canvas" width="800" height="300"></canvas>

            <div class="action-info">
                <div>üí® <span id="planeWindRemaining">0</span> Wind Points</div>
                <div>üìè <span id="planeDistanceDisplay">0</span> Distance</div>
                <div>üéØ Target: <span id="planeTargetDisplay">200</span></div>
                <div>üìê Altitude: <span id="planeAltitudeDisplay">0</span>m</div>
            </div>

            <div id="planeLaunchIndicator" style="text-align: center; margin: 10px 0; color: #27ae60; font-weight: bold; animation: pulse 1s infinite;">
                Press SPACE to launch!
            </div>

            <div style="display: flex; justify-content: center; gap: 10px; margin: 15px 0;">
                <button class="start-button" onclick="planeGame.useWind()" style="padding: 8px 15px; background: linear-gradient(145deg, #3498db, #2980b9);">üí® WIND (Space)</button>
                <button class="start-button" onclick="planeGame.airBrake()" style="padding: 8px 15px; background: linear-gradient(145deg, #e74c3c, #c0392b);">üõë BRAKE (Enter)</button>
            </div>
        </div>
    </div>

    <!-- Field Goal Game Container -->
    <div id="fieldgoalGame" class="container game-container">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display (Playing Mode) -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Kick Phase (Action Phase) -->
        <div id="fieldgoalKickPhase" class="action-phase hidden">
            <div class="fieldgoal-game-area">
                <!-- Power Meter (vertical, on left side) -->
                <div class="power-meter-container" id="powerMeterContainer">
                    <div class="power-meter-label">POWER</div>
                    <div class="power-meter-bar">
                        <div class="power-meter-indicator" id="powerIndicator"></div>
                    </div>
                </div>

                <!-- Main Canvas -->
                <canvas id="fieldgoalCanvas" class="game-canvas" width="800" height="450"></canvas>
            </div>

            <!-- Direction Meter (horizontal, below canvas) -->
            <div class="direction-meter-container">
                <div class="direction-meter-bar">
                    <div class="direction-meter-indicator" id="directionIndicator"></div>
                </div>
                <div class="direction-meter-labels">
                    <span>LEFT</span>
                    <span>CENTER</span>
                    <span>RIGHT</span>
                </div>
            </div>

            <div class="kick-status" id="kickStatus">Press SPACE to set direction</div>
        </div>
    </div>

    <!-- Mini Golf Game Container -->
    <div id="minigolfGame" class="container game-container" style="display: none;">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display (Playing Mode) -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Putt Phase (Action Phase) -->
        <div id="minigolfPuttPhase" class="action-phase hidden">
            <div class="minigolf-game-area">
                <!-- Power Meter (vertical, on left side) -->
                <div class="minigolf-power-meter" id="minigolfPowerMeter">
                    <div class="power-meter-label">POWER</div>
                    <div class="minigolf-power-bar">
                        <div class="minigolf-power-fill" id="minigolfPowerFill"></div>
                    </div>
                </div>

                <!-- Main Canvas -->
                <canvas id="minigolfCanvas" class="game-canvas" width="800" height="600"></canvas>
            </div>

            <div class="putt-status" id="puttStatus">Use ‚Üê ‚Üí to aim, hold SPACE for power</div>
        </div>
    </div>

    <!-- Motorcycle Game Container -->
    <div id="motorcycleGame" class="container game-container" style="display: none;">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display (Playing Mode) -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Race Phase (Action Phase) -->
        <div id="motorcycleRacePhase" class="action-phase hidden">
            <canvas id="motorcycleCanvas" class="game-canvas" width="800" height="600"></canvas>
            <div class="race-status" id="raceStatus">‚Üê ‚Üí to steer, SPACE for turbo</div>
        </div>
    </div>

    <!-- Snowball Game Container -->
    <div id="snowballGame" class="container game-container" style="display: none;">
        <button class="back-button" onclick="returnToHub()">‚Üê Back to Hub</button>

        <!-- Profile Display (Playing Mode) -->
        <div class="profile-display-game playing">
            <button class="profile-button">
                <span class="gameProfileAvatar">ü¶ä</span>
                <span class="gameProfileName">Player 1</span>
                <span class="dev-indicator">DEV</span>
            </button>
        </div>

        <!-- Throw Phase (Action Phase) -->
        <div id="snowballThrowPhase" class="action-phase hidden">
            <canvas id="snowballCanvas" class="game-canvas" width="800" height="600"></canvas>
            <div class="throw-status" id="throwStatus">Arrow keys to aim, hold SPACE for power</div>
        </div>
    </div>

    <script>
        // Global Audio System
        const sounds = {
            enabled: true,
            audioContext: null,

            init() {
                if (typeof AudioContext !== 'undefined') {
                    this.audioContext = new AudioContext();
                }
            },

            // Engine sound system for motorcycle
            engineOscillator: null,
            engineGain: null,

            startEngine() {
                if (!this.enabled || !this.audioContext) return;
                if (this.engineOscillator) return;  // Already running

                this.engineOscillator = this.audioContext.createOscillator();
                this.engineGain = this.audioContext.createGain();

                this.engineOscillator.type = 'sawtooth';
                this.engineOscillator.connect(this.engineGain);
                this.engineGain.connect(this.audioContext.destination);

                this.engineOscillator.frequency.setValueAtTime(80, this.audioContext.currentTime);
                this.engineGain.gain.setValueAtTime(0.08, this.audioContext.currentTime);

                this.engineOscillator.start();
            },

            updateEngine(speed) {
                if (!this.engineOscillator || !this.engineGain) return;

                // Map speed (5-12) to frequency (80-200 Hz) for engine pitch
                const baseFreq = 80;
                const freqRange = 120;
                const freq = baseFreq + (speed - 5) * (freqRange / 7);
                this.engineOscillator.frequency.setValueAtTime(Math.max(60, Math.min(200, freq)), this.audioContext.currentTime);

                // Louder when boosting
                const vol = speed > 7 ? 0.12 : 0.08;
                this.engineGain.gain.setValueAtTime(vol, this.audioContext.currentTime);
            },

            stopEngine() {
                if (this.engineOscillator) {
                    this.engineOscillator.stop();
                    this.engineOscillator = null;
                    this.engineGain = null;
                }
            },

            playCorrect() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, this.audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, this.audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.5);
            },

            playIncorrect() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            },

            playButtonClick() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime + 0.05);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            },

            playDig() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'square';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime + 0.05);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            },

            playCoin() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(880, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(1100, this.audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(1320, this.audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.4);
            },

            playMove() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'triangle';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.08);
            },

            playWhoosh() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            },

            // Field Goal Game Sounds
            playWhistle() {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Whistle sweep down
                oscillator.frequency.setValueAtTime(900, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.3);

                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.4);
            },

            playDoink() {
                if (!this.enabled || !this.audioContext) return;

                // Metallic clang sound
                const oscillator = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'triangle';
                oscillator2.type = 'sine';
                oscillator.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // High metallic frequencies
                oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                oscillator2.frequency.setValueAtTime(2400, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

                oscillator.start(this.audioContext.currentTime);
                oscillator2.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.5);
                oscillator2.stop(this.audioContext.currentTime + 0.5);
            },

            playCrowdCheer() {
                if (!this.enabled || !this.audioContext) return;

                // Create noise for crowd
                const bufferSize = this.audioContext.sampleRate * 0.8;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.5;
                }

                const noise = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();

                noise.buffer = buffer;
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 0.5;

                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                gainNode.gain.setValueAtTime(0.01, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.15, this.audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);

                noise.start(this.audioContext.currentTime);
                noise.stop(this.audioContext.currentTime + 0.8);
            },

            playCrowdGroan() {
                if (!this.enabled || !this.audioContext) return;

                // Low rumble for groan
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sawtooth';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.5);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.6);
            },

            playKick() {
                if (!this.enabled || !this.audioContext) return;

                // Thump sound for kick
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }
        };

        // Initialize audio when page loads
        sounds.init();

        // Resume audio context on first user interaction (browser autoplay policy)
        document.addEventListener('click', () => {
            if (sounds.audioContext && sounds.audioContext.state === 'suspended') {
                sounds.audioContext.resume();
            }
        }, { once: true });

        // Global sound toggle
        function toggleGlobalSound() {
            sounds.enabled = !sounds.enabled;
            const button = document.getElementById('globalSoundToggle');
            button.textContent = sounds.enabled ? 'üîä' : 'üîá';
            button.classList.toggle('muted', !sounds.enabled);
        }

        // Global Math Problem Generator
        const mathEngine = {
            // Fixed difficulty parameters (not affected by round)
            difficultyParams: {
                easy: { addMax: 10, multMax: 5, diceCount: 2, coinCount: 3, fracMax: 10 },
                medium: { addMax: 20, multMax: 10, diceCount: 3, coinCount: 4, fracMax: 20 },
                hard: { addMax: 50, multMax: 12, diceCount: 4, coinCount: 5, fracMax: 30 }
            },

            generateProblem(type, difficulty) {
                const params = this.difficultyParams[difficulty] || this.difficultyParams.easy;
                switch(type) {
                    case 'addition': return this.generateAddition(params);
                    case 'subtraction': return this.generateSubtraction(params);
                    case 'multiplication': return this.generateMultiplication(params);
                    case 'division': return this.generateDivision(params);
                    case 'dice': return this.generateDice(params);
                    case 'coin': return this.generateCoin(params);
                    case 'change': return this.generateChange(params);
                    case 'fractions': return this.generateFractions(params);
                    case 'hundred': return this.generateHundred(params);
                    default: return this.generateAddition(params);
                }
            },

            generateAddition(params) {
                const a = Math.floor(Math.random() * params.addMax) + 1;
                const b = Math.floor(Math.random() * params.addMax) + 1;
                const answer = a + b;
                return { question: `${a} + ${b}`, answer, expectedDigits: answer.toString().length };
            },

            generateSubtraction(params) {
                let a = Math.floor(Math.random() * params.addMax) + 1;
                let b = Math.floor(Math.random() * params.addMax) + 1;
                if (b > a) [a, b] = [b, a]; // ensure non-negative result
                const answer = a - b;
                return { question: `${a} - ${b}`, answer, expectedDigits: Math.max(1, answer.toString().length) };
            },

            generateMultiplication(params) {
                const a = Math.floor(Math.random() * params.multMax) + 1;
                const b = Math.floor(Math.random() * params.multMax) + 1;
                const answer = a * b;
                return { question: `${a} √ó ${b}`, answer, expectedDigits: answer.toString().length };
            },

            generateDivision(params) {
                const divisors = params.multMax <= 5 ? [2, 5] :
                                 params.multMax <= 10 ? [2, 3, 4, 5] : [2, 3, 4, 5, 6, 7, 8, 9, 10];
                const b = divisors[Math.floor(Math.random() * divisors.length)];
                const quotient = Math.floor(Math.random() * params.multMax) + 1;
                const a = b * quotient; // ensures clean division
                return { question: `${a} √∑ ${b}`, answer: quotient, expectedDigits: quotient.toString().length };
            },

            generateDice(params) {
                const dice = [];
                for (let i = 0; i < params.diceCount; i++) {
                    dice.push(Math.floor(Math.random() * 6) + 1);
                }
                const sum = dice.reduce((a, b) => a + b, 0);
                const diceEmoji = dice.map(d => ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][d-1]).join(' ');
                const diceHTML = `<span class="dice-display">${diceEmoji}</span>`;
                return { question: diceHTML, answer: sum, expectedDigits: sum.toString().length, isHTML: true };
            },

            generateCoin(params) {
                const coinValues = [1, 5, 10, 25];
                const coins = [];
                const count = Math.floor(Math.random() * 2) + params.coinCount - 1;
                for (let i = 0; i < count; i++) {
                    coins.push(coinValues[Math.floor(Math.random() * coinValues.length)]);
                }
                const sum = coins.reduce((a, b) => a + b, 0);
                // Create HTML coin display with colored circles
                const coinHTML = coins.map(c => {
                    const coinClass = c === 1 ? 'penny' : c === 5 ? 'nickel' : c === 10 ? 'dime' : 'quarter';
                    return `<span class="coin ${coinClass}">${c}</span>`;
                }).join(' ');
                return { question: coinHTML, answer: sum, expectedDigits: sum.toString().length, isHTML: true };
            },

            generateChange(params) {
                // Generate coins that sum to 15-85 cents based on difficulty
                const coinValues = params.coinCount <= 3 ? [25, 10] :
                                   params.coinCount <= 4 ? [25, 10, 5] : [25, 10, 5, 1];
                const coins = [];
                const targetMin = params.coinCount <= 3 ? 15 : params.coinCount <= 4 ? 20 : 25;
                const targetMax = params.coinCount <= 3 ? 50 : params.coinCount <= 4 ? 70 : 85;

                // Generate coins until we're in target range
                let sum = 0;
                const maxCoins = params.coinCount + 1;
                while (coins.length < maxCoins && sum < targetMin) {
                    const coin = coinValues[Math.floor(Math.random() * coinValues.length)];
                    if (sum + coin <= targetMax) {
                        coins.push(coin);
                        sum += coin;
                    }
                }

                // Ensure we have at least some coins
                if (coins.length === 0) {
                    coins.push(25);
                    sum = 25;
                }

                const change = 100 - sum;

                // Create HTML with dollar bill, minus sign, and coins
                const coinHTML = coins.map(c => {
                    const coinClass = c === 1 ? 'penny' : c === 5 ? 'nickel' : c === 10 ? 'dime' : 'quarter';
                    return `<span class="coin ${coinClass}">${c}</span>`;
                }).join(' ');

                const changeHTML = `<span class="dollar-bill">100</span><span class="change-minus">‚àí</span>${coinHTML}`;
                return { question: changeHTML, answer: change, expectedDigits: change.toString().length, isHTML: true };
            },

            generateFractions(params) {
                const fractions = params.fracMax <= 10 ? [[1,2]] :
                                  params.fracMax <= 20 ? [[1,2], [1,4], [3,4]] : [[1,2], [1,3], [2,3], [1,4], [3,4]];
                const [num, den] = fractions[Math.floor(Math.random() * fractions.length)];
                const whole = den * (Math.floor(Math.random() * Math.floor(params.fracMax / den)) + 1);
                const answer = (whole * num) / den;
                return { question: `${num}/${den} of ${whole}`, answer, expectedDigits: answer.toString().length };
            },

            generateHundred(params) {
                // 100 - X = ? problems
                // Easy: subtract 1-10, Medium: subtract 1-30, Hard: subtract 1-50
                const subtractMax = params.addMax <= 10 ? 10 : params.addMax <= 20 ? 30 : 50;
                const b = Math.floor(Math.random() * subtractMax) + 1;
                const answer = 100 - b;
                return { question: `100 ‚àí ${b}`, answer, expectedDigits: answer.toString().length };
            }
        };

        // Global Game State Manager
        const gameManager = {
            currentGame: null,
            mathSettings: {
                problemType: 'addition',
                difficulty: 'easy'
            },
            gameStates: {
                castle: { round: 1, score: 0, phase: 'start', resources: 0, castleFlagColor: 'red', devMode: false, totalTargetsDestroyed: 0 },
                express: { round: 1, score: 0, phase: 'start', resources: 0, trainColor: 'red', devMode: false, totalDistance: 0 },
                miner: { round: 1, score: 0, phase: 'start', resources: 0, minerColor: 'red', devMode: false, totalCoinsCollected: 0 },
                plane: { round: 1, score: 0, phase: 'start', resources: 0, airplaneType: 'red', devMode: false, totalDistance: 0 },
                fieldgoal: { round: 1, score: 0, phase: 'start', resources: 0, teamColor: 'red', devMode: false, totalFieldGoalsMade: 0 },
                minigolf: { round: 1, score: 0, phase: 'start', resources: 0, ballColor: 'white', devMode: false, totalHolesCompleted: 0 },
                motorcycle: { round: 1, score: 0, phase: 'start', resources: 0, bikeColor: 'red', devMode: false, totalDistanceTraveled: 0 },
                snowball: { round: 1, score: 0, phase: 'start', resources: 0, teamColor: 'red', devMode: false, totalSnowmenHit: 0 }
            }
        };

        // Game Configuration Object - defines game-specific parameters for shared templates
        const gameConfigs = {
            castle: {
                id: 'castle',
                title: 'Math Castle',
                icon: 'üè∞',
                themeColor: '#e74c3c',

                selectionPrompt: 'Choose the castle you will defend!',
                options: [
                    { id: 'red', name: 'Red Kingdom', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Kingdom', color: '#3498db' }
                ],
                selectionKey: 'castleFlagColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniCastle(ctx, 75, 85, colorId);
                },

                mathTitle: 'Math Battle',
                resourceName: 'Cannon Points',
                resourceIcon: 'üî•',
                pointClass: 'cannon-point',

                actionPhaseId: 'castleCannonPhase',
                startAction: () => castleGame.showCannonPhase(),
                gameObject: () => castleGame,

                gameOverTitle: 'Castle Fallen!',
                gameOverIcon: 'üè∞',
                playAgainText: 'Battle Again!',
                startButtonText: 'Defend Castle!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalTargetsDestroyed', label: 'Targets Destroyed', color: '#e74c3c' }
                ]
            },

            express: {
                id: 'express',
                title: 'Math Express',
                icon: 'üöÇ',
                themeColor: '#e67e22',

                selectionPrompt: 'Choose your train to conduct!',
                options: [
                    { id: 'red', name: 'Red Express', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Express', color: '#3498db' }
                ],
                selectionKey: 'trainColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniTrain(ctx, 75, 85, colorId);
                },

                mathTitle: 'Math Station',
                resourceName: 'Steam Points',
                resourceIcon: 'üî•',
                pointClass: 'coal-point',

                actionPhaseId: 'expressTrainPhase',
                startAction: () => expressGame.showTrainPhase(),
                gameObject: () => expressGame,

                gameOverTitle: 'End of the Line!',
                gameOverIcon: 'üöÇ',
                playAgainText: 'Try Again!',
                startButtonText: 'All Aboard!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalDistance', label: 'Total Distance', color: '#27ae60' }
                ]
            },

            miner: {
                id: 'miner',
                title: 'Math Miner',
                icon: '‚õèÔ∏è',
                themeColor: '#8B4513',

                selectionPrompt: 'Choose your miner!',
                options: [
                    { id: 'red', name: 'Alex', color: '#e74c3c' },
                    { id: 'blue', name: 'Sam', color: '#3498db' }
                ],
                selectionKey: 'minerColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniMiner(ctx, 75, 85, colorId);
                },

                mathTitle: 'Math Mine',
                resourceName: 'Dig Points',
                resourceIcon: '‚õèÔ∏è',
                pointClass: 'dig-point',

                actionPhaseId: 'minerMiningPhase',
                startAction: () => minerGame.showMiningPhase(),
                gameObject: () => minerGame,

                gameOverTitle: 'Mining Complete!',
                gameOverIcon: '‚õ∞Ô∏è',
                playAgainText: 'Mine Again!',
                startButtonText: 'Start Mining!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalCoinsCollected', label: 'Total Coins', color: '#f1c40f' }
                ]
            },

            plane: {
                id: 'plane',
                title: 'Math Plane',
                icon: '‚úàÔ∏è',
                themeColor: '#3498db',

                selectionPrompt: 'Choose your paper airplane!',
                options: [
                    { id: 'red', name: 'Red Glider', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Flyer', color: '#3498db' }
                ],
                selectionKey: 'airplaneType',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniPlane(ctx, 75, 75, colorId);
                },

                mathTitle: 'Math Workshop',
                resourceName: 'Wind Points',
                resourceIcon: 'üí®',
                pointClass: 'wind-point',

                actionPhaseId: 'planeFlightPhase',
                startAction: () => planeGame.showFlightPhase(),
                gameObject: () => planeGame,

                gameOverTitle: 'Flight Ended!',
                gameOverIcon: '‚úàÔ∏è',
                playAgainText: 'Fly Again!',
                startButtonText: 'Take Flight!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalDistance', label: 'Total Distance', color: '#27ae60' }
                ]
            },

            fieldgoal: {
                id: 'fieldgoal',
                title: 'Math Field Goals',
                icon: 'üèà',
                themeColor: '#27ae60',

                selectionPrompt: 'Choose your team!',
                options: [
                    { id: 'red', name: 'Red Team', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Team', color: '#3498db' }
                ],
                selectionKey: 'teamColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    drawMiniKicker(ctx, 75, 85, colorId);
                },

                mathTitle: 'Kick Practice',
                resourceName: 'Footballs',
                resourceIcon: 'üèà',
                pointClass: 'football-point',

                actionPhaseId: 'fieldgoalKickPhase',
                startAction: () => fieldgoalGame.showKickPhase(),
                gameObject: () => fieldgoalGame,

                gameOverTitle: 'Game Over!',
                gameOverIcon: 'üèà',
                playAgainText: 'Play Again!',
                startButtonText: 'Kick Off!',
                stats: [
                    { key: 'round', label: 'Round Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalFieldGoalsMade', label: 'Field Goals Made', color: '#f39c12' }
                ]
            },

            minigolf: {
                id: 'minigolf',
                title: 'Math Mini Golf',
                icon: '‚õ≥',
                themeColor: '#27ae60',

                selectionPrompt: 'Choose your ball color!',
                options: [
                    { id: 'white', name: 'Classic White', color: '#ffffff' },
                    { id: 'orange', name: 'Bright Orange', color: '#ff6b35' }
                ],
                selectionKey: 'ballColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    // Draw golf ball
                    const colors = { white: '#ffffff', orange: '#ff6b35' };
                    ctx.fillStyle = colors[colorId] || '#ffffff';
                    ctx.beginPath();
                    ctx.arc(75, 75, 35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath();
                    ctx.arc(65, 65, 10, 0, Math.PI * 2);
                    ctx.fill();
                },

                mathTitle: 'Practice Swings',
                resourceName: 'Strokes',
                resourceIcon: '‚õ≥',
                pointClass: 'golf-point',

                actionPhaseId: 'minigolfPuttPhase',
                startAction: () => minigolfGame.startPuttPhase(),
                gameObject: () => minigolfGame,

                gameOverTitle: 'Round Over!',
                gameOverIcon: '‚õ≥',
                playAgainText: 'Play Again!',
                startButtonText: 'Tee Off!',
                stats: [
                    { key: 'round', label: 'Holes Reached', color: '#27ae60' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalHolesCompleted', label: 'Holes Completed', color: '#f39c12' }
                ]
            },

            motorcycle: {
                id: 'motorcycle',
                title: 'Math Racer',
                icon: 'üèçÔ∏è',
                themeColor: '#c0392b',

                selectionPrompt: 'Choose your bike!',
                options: [
                    { id: 'red', name: 'Red Rocket', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Blaze', color: '#3498db' }
                ],
                selectionKey: 'bikeColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    const colors = { red: '#e74c3c', blue: '#3498db' };
                    const color = colors[colorId] || '#e74c3c';
                    const darkerColor = colorId === 'blue' ? '#2980b9' : '#c0392b';

                    ctx.save();
                    ctx.translate(75, 75);  // Center of preview
                    ctx.scale(1.8, 1.8);    // Scale up for preview

                    // Front wheel
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.ellipse(0, -18, 8, 5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Rear wheel
                    ctx.beginPath();
                    ctx.ellipse(0, 20, 9, 6, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Bike body (rounded)
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(-10, -12);
                    ctx.quadraticCurveTo(-12, 0, -10, 15);
                    ctx.lineTo(-6, 18);
                    ctx.lineTo(6, 18);
                    ctx.lineTo(10, 15);
                    ctx.quadraticCurveTo(12, 0, 10, -12);
                    ctx.lineTo(6, -15);
                    ctx.lineTo(-6, -15);
                    ctx.closePath();
                    ctx.fill();

                    // Fuel tank
                    ctx.fillStyle = darkerColor;
                    ctx.beginPath();
                    ctx.ellipse(0, 2, 7, 5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Windshield
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.moveTo(-6, -14);
                    ctx.quadraticCurveTo(0, -20, 6, -14);
                    ctx.lineTo(4, -10);
                    ctx.lineTo(-4, -10);
                    ctx.closePath();
                    ctx.fill();

                    // Handlebars
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-12, -8);
                    ctx.lineTo(-8, -10);
                    ctx.moveTo(8, -10);
                    ctx.lineTo(12, -8);
                    ctx.stroke();

                    // Exhaust
                    ctx.fillStyle = '#666';
                    ctx.fillRect(8, 10, 6, 3);

                    // Rider helmet
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(0, -6, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // Visor
                    ctx.fillStyle = '#4a90d9';
                    ctx.beginPath();
                    ctx.arc(0, -5, 4, -0.3, Math.PI + 0.3);
                    ctx.fill();
                    // Body
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.ellipse(0, 4, 5, 7, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                },

                mathTitle: 'Turbo Charge',
                resourceName: 'Turbos',
                resourceIcon: '‚ö°',
                pointClass: 'turbo-point',

                actionPhaseId: 'motorcycleRacePhase',
                startAction: () => motorcycleGame.startRacePhase(),
                gameObject: () => motorcycleGame,

                gameOverTitle: 'Race Over!',
                gameOverIcon: 'üèçÔ∏è',
                playAgainText: 'Race Again!',
                startButtonText: 'Start Engine!',
                stats: [
                    { key: 'round', label: 'Tracks Completed', color: '#c0392b' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalDistanceTraveled', label: 'Total Distance', color: '#f39c12' }
                ]
            },

            snowball: {
                id: 'snowball',
                title: 'Snowball Math',
                icon: '‚ùÑÔ∏è',
                themeColor: '#74b9ff',

                selectionPrompt: 'Choose your team!',
                options: [
                    { id: 'red', name: 'Red Team', color: '#e74c3c' },
                    { id: 'blue', name: 'Blue Team', color: '#3498db' }
                ],
                selectionKey: 'teamColor',
                drawPreview: (canvas, colorId) => {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 150, 150);
                    const scarfColor = colorId === 'blue' ? '#3498db' : '#e74c3c';

                    ctx.save();
                    ctx.translate(75, 85);

                    // Bottom ball
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 25, 22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Middle ball
                    ctx.beginPath();
                    ctx.arc(0, 0, 16, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Head
                    ctx.beginPath();
                    ctx.arc(0, -22, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Top hat
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-10, -42, 20, 6);
                    ctx.fillRect(-7, -58, 14, 18);

                    // Carrot nose
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.moveTo(0, -22);
                    ctx.lineTo(12, -20);
                    ctx.lineTo(0, -18);
                    ctx.closePath();
                    ctx.fill();

                    // Eyes
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(-4, -26, 2, 0, Math.PI * 2);
                    ctx.arc(4, -26, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Scarf
                    ctx.fillStyle = scarfColor;
                    ctx.fillRect(-12, -10, 24, 6);
                    ctx.fillRect(8, -10, 6, 18);

                    // Stick arms
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-16, 0);
                    ctx.lineTo(-32, -10);
                    ctx.moveTo(16, 0);
                    ctx.lineTo(32, -8);
                    ctx.stroke();

                    ctx.restore();
                },

                mathTitle: 'Snowball Time',
                resourceName: 'Snowballs',
                resourceIcon: '‚õÑ',
                pointClass: 'snowball-point',

                actionPhaseId: 'snowballThrowPhase',
                startAction: () => snowballGame.startThrowPhase(),
                gameObject: () => snowballGame,

                gameOverTitle: 'Game Over!',
                gameOverIcon: '‚ùÑÔ∏è',
                playAgainText: 'Play Again!',
                startButtonText: 'Let it Snow!',
                stats: [
                    { key: 'round', label: 'Rounds Completed', color: '#74b9ff' },
                    { key: 'score', label: 'Math Score', color: '#3498db' },
                    { key: 'totalSnowmenHit', label: 'Snowmen Hit', color: '#00b894' }
                ]
            }
        };

        // ===== STORAGE MANAGER =====
        const storageManager = {
            STORAGE_KEY: 'mathAdventureStats',
            VERSION: 2,
            AVATARS: ['ü¶ä', 'üê±', 'üê∂', 'ü¶Å', 'üêº', 'üê®', 'üê∏', 'üê∞', 'üêª', 'üêØ', 'üê∑', 'üêµ'],

            // Get default empty stats object
            getDefaultStats() {
                return { highScore: 0, totalScore: 0, highestLevel: 0, totalLevels: 0 };
            },

            // Generate unique profile ID
            generateProfileId() {
                return 'profile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            },

            // Migrate v1 data to v2 format
            migrateFromV1(oldData) {
                const profileId = this.generateProfileId();
                return {
                    version: 2,
                    activeProfileId: profileId,
                    profiles: {
                        [profileId]: {
                            id: profileId,
                            name: 'Player 1',
                            avatar: 'ü¶ä',
                            created: Date.now(),
                            stats: oldData.stats || {}
                        }
                    }
                };
            },

            // Get default v2 data structure with one profile
            getDefaultData() {
                const profileId = this.generateProfileId();
                return {
                    version: 2,
                    activeProfileId: profileId,
                    profiles: {
                        [profileId]: {
                            id: profileId,
                            name: 'Player 1',
                            avatar: 'ü¶ä',
                            created: Date.now(),
                            stats: {}
                        }
                    }
                };
            },

            // Load stats from localStorage (with migration support)
            load() {
                try {
                    const data = localStorage.getItem(this.STORAGE_KEY);
                    if (data) {
                        const parsed = JSON.parse(data);
                        // Already v2
                        if (parsed.version === 2) {
                            return parsed;
                        }
                        // Migrate from v1
                        if (parsed.version === 1) {
                            const migrated = this.migrateFromV1(parsed);
                            this.save(migrated);
                            return migrated;
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load stats:', e);
                }
                // No data or invalid - create default
                const defaultData = this.getDefaultData();
                this.save(defaultData);
                return defaultData;
            },

            // Save stats to localStorage
            save(data) {
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                } catch (e) {
                    console.warn('Failed to save stats:', e);
                }
            },

            // Get active profile
            getActiveProfile() {
                const data = this.load();
                return data.profiles[data.activeProfileId];
            },

            // Get all profiles as array
            getAllProfiles() {
                const data = this.load();
                return Object.values(data.profiles).sort((a, b) => a.created - b.created);
            },

            // Create a new profile
            createProfile(name, avatar) {
                const data = this.load();
                const profileId = this.generateProfileId();
                data.profiles[profileId] = {
                    id: profileId,
                    name: name.trim() || 'Player',
                    avatar: avatar || 'ü¶ä',
                    created: Date.now(),
                    stats: {}
                };
                data.activeProfileId = profileId;
                this.save(data);
                return profileId;
            },

            // Switch to a different profile
            switchProfile(profileId) {
                const data = this.load();
                if (data.profiles[profileId]) {
                    data.activeProfileId = profileId;
                    this.save(data);
                    return true;
                }
                return false;
            },

            // Delete a profile
            deleteProfile(profileId) {
                const data = this.load();
                const profileIds = Object.keys(data.profiles);
                // Cannot delete the last profile
                if (profileIds.length <= 1) {
                    return false;
                }
                if (data.profiles[profileId]) {
                    delete data.profiles[profileId];
                    // If deleted profile was active, switch to another
                    if (data.activeProfileId === profileId) {
                        data.activeProfileId = Object.keys(data.profiles)[0];
                    }
                    this.save(data);
                    return true;
                }
                return false;
            },

            // Update a profile's avatar
            updateProfileAvatar(profileId, newAvatar) {
                const data = this.load();
                if (data.profiles[profileId]) {
                    data.profiles[profileId].avatar = newAvatar;
                    this.save(data);
                    return true;
                }
                return false;
            },

            // Get stat key for a game/mode/difficulty combination
            getStatKey(game, mode, difficulty) {
                return `${game}_${mode}_${difficulty}`;
            },

            // Get stats for a specific combination (from active profile)
            getStats(game, mode, difficulty) {
                const profile = this.getActiveProfile();
                const key = this.getStatKey(game, mode, difficulty);
                return profile.stats[key] || this.getDefaultStats();
            },

            // Update stats after a game ends (for active profile)
            updateStats(game, mode, difficulty, score, level) {
                const data = this.load();
                const profile = data.profiles[data.activeProfileId];
                const key = this.getStatKey(game, mode, difficulty);
                const current = profile.stats[key] || this.getDefaultStats();

                // Update math progress stats
                if (score > current.highScore) {
                    current.highScore = score;
                }
                current.totalScore += score;

                // Update game progress stats
                if (level > current.highestLevel) {
                    current.highestLevel = level;
                }
                current.totalLevels += level;

                profile.stats[key] = current;
                this.save(data);
            },

            // Get all stats (from active profile)
            getAllStats() {
                return this.getActiveProfile().stats;
            },

            // Get stars for a score/level based on type
            getStars(value, type) {
                if (value === 0) return '';

                const thresholds = {
                    highScore: [1, 10, 20],      // 1-9=1star, 10-19=2stars, 20+=3stars
                    totalScore: [1, 50, 100],    // 1-49=1star, 50-99=2stars, 100+=3stars
                    highestLevel: [1, 4, 7],     // 1-3=1star, 4-6=2stars, 7+=3stars
                    totalLevels: [1, 16, 31]     // 1-15=1star, 16-30=2stars, 31+=3stars
                };

                const [min1, min2, min3] = thresholds[type] || [1, 10, 20];
                if (value >= min3) return '‚≠ê‚≠ê‚≠ê';
                if (value >= min2) return '‚≠ê‚≠ê';
                if (value >= min1) return '‚≠ê';
                return '';
            },

            // Aggregate stats across games for a mode/difficulty (for Math Progress)
            aggregateMathStats(mode, difficulty) {
                const games = ['castle', 'express', 'miner', 'plane', 'fieldgoal', 'minigolf', 'motorcycle', 'snowball'];
                let highScore = 0, totalScore = 0;

                games.forEach(game => {
                    const stats = this.getStats(game, mode, difficulty);
                    if (stats.highScore > highScore) highScore = stats.highScore;
                    totalScore += stats.totalScore;
                });

                return { highScore, totalScore };
            },

            // Aggregate stats across modes for a game/difficulty (for Game Progress)
            aggregateGameStats(game, difficulty, modeFilter = null) {
                const modes = ['addition', 'subtraction', 'multiplication', 'division', 'dice', 'coin', 'change', 'fractions', 'hundred'];
                const modesToCheck = modeFilter ? [modeFilter] : modes;

                let highestLevel = 0, totalLevels = 0;

                modesToCheck.forEach(mode => {
                    const stats = this.getStats(game, mode, difficulty);
                    if (stats.highestLevel > highestLevel) highestLevel = stats.highestLevel;
                    totalLevels += stats.totalLevels;
                });

                return { highestLevel, totalLevels };
            }
        };

        // Current game type being played (used by shared functions)
        let currentGameType = null;
        let mathTimer = 60;
        let mathInterval = null;

        // ===== SHARED GAME FUNCTIONS =====

        // Show selection screen for a game
        function showSelectionScreen(gameType) {
            currentGameType = gameType;
            const config = gameConfigs[gameType];
            const state = gameManager.gameStates[gameType];

            // Hide hub, show shared container
            document.getElementById('gameHub').classList.remove('active');
            document.getElementById('gameHub').style.display = 'none';
            document.getElementById('sharedGameContainer').style.display = 'block';
            document.getElementById('sharedGameContainer').classList.add('active');

            // Show selection screen, hide others
            document.getElementById('gameSelectionScreen').classList.remove('hidden');
            document.getElementById('gameMathPhase').classList.add('hidden');
            document.getElementById('roundCompleteScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');

            // Populate from config
            document.getElementById('selectionTitle').innerHTML = `${config.icon} ${config.title}`;
            document.getElementById('selectionPrompt').textContent = config.selectionPrompt;
            document.getElementById('startGameBtn').textContent = config.startButtonText;

            // Setup options
            config.options.forEach((option, i) => {
                document.getElementById(`optionName${i}`).textContent = option.name;
                const canvas = document.getElementById(`preview${i}`);
                config.drawPreview(canvas, option.id);
            });

            // Highlight current selection
            updateSelectionHighlight();
        }

        // Handle option selection
        function selectOption(index) {
            sounds.playButtonClick();
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            state[config.selectionKey] = config.options[index].id;
            updateSelectionHighlight();
        }

        // Select problem type tile
        function selectProblemType(type) {
            sounds.playButtonClick();
            gameManager.mathSettings.problemType = type;

            // Update tile selection visual
            document.querySelectorAll('#problemTypeTiles .config-tile').forEach(tile => {
                tile.classList.toggle('selected', tile.dataset.value === type);
            });
        }

        // Select difficulty tile
        function selectDifficulty(difficulty) {
            sounds.playButtonClick();
            gameManager.mathSettings.difficulty = difficulty;

            // Update tile selection visual
            document.querySelectorAll('#difficultyTiles .config-tile').forEach(tile => {
                tile.classList.toggle('selected', tile.dataset.value === difficulty);
            });
        }

        // Update selection highlight based on current state
        function updateSelectionHighlight() {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];
            const currentSelection = state[config.selectionKey];

            config.options.forEach((option, i) => {
                const optionEl = document.getElementById(`option${i}`);
                if (option.id === currentSelection) {
                    optionEl.classList.add('selected');
                } else {
                    optionEl.classList.remove('selected');
                }
            });
        }

        // Update DEV mode indicator visibility across all profile displays
        function updateDevIndicator() {
            const state = currentGameType ? gameManager.gameStates[currentGameType] : null;
            const isDevMode = state && state.devMode;

            document.querySelectorAll('.dev-indicator').forEach(el => {
                el.classList.toggle('active', isDevMode);
            });
        }

        // Start dev mode (follow normal flow but with base resources)
        function startDevMode() {
            sounds.playButtonClick();
            const state = gameManager.gameStates[currentGameType];

            state.devMode = true;
            state.resources = 10;  // Base resources in dev mode

            updateDevIndicator();  // Show DEV badge
            startMathPhase();      // Follow normal flow
        }

        // Start the math phase
        function startMathPhase() {
            sounds.playButtonClick();
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            // Initialize game object if needed
            const gameObj = config.gameObject();
            if (gameObj && gameObj.init) {
                gameObj.init();
            }

            state.phase = 'math';
            // Only reset resources on round 1 if not in dev mode (dev mode starts with base resources)
            if (state.round === 1 && !state.devMode) {
                state.resources = 0;
            }

            // Hide selection, show math phase
            document.getElementById('gameSelectionScreen').classList.add('hidden');
            document.getElementById('gameMathPhase').classList.remove('hidden');

            // Populate from config
            document.getElementById('mathPhaseTitle').innerHTML =
                `üßÆ ${config.mathTitle} - Round <span id="mathRoundNumber">${state.round}</span>`;
            document.getElementById('resourceIcon').textContent = config.resourceIcon;
            document.getElementById('resourceName').textContent = config.resourceName;
            document.getElementById('answerInput').value = '';

            // Initialize timer
            mathTimer = 60;
            updateSharedTimerDisplay();

            if (mathInterval) clearInterval(mathInterval);
            mathInterval = setInterval(() => {
                mathTimer--;
                updateSharedTimerDisplay();
                if (mathTimer <= 0) {
                    endSharedMathPhase();
                }
            }, 1000);

            generateSharedProblem();
            updateResourceDisplay();
        }

        // Update timer display
        function updateSharedTimerDisplay() {
            document.getElementById('mathTimer').textContent = mathTimer;
        }

        // Skip math timer (dev mode only)
        function skipMathTimer() {
            sounds.playButtonClick();
            mathTimer = 0;
            updateSharedTimerDisplay();
        }

        // Generate new problem
        function generateSharedProblem() {
            const state = gameManager.gameStates[currentGameType];
            const { problemType, difficulty } = gameManager.mathSettings;
            state.currentProblem = mathEngine.generateProblem(problemType, difficulty);
            const problemEl = document.getElementById('problemText');
            if (state.currentProblem.isHTML) {
                problemEl.innerHTML = `${state.currentProblem.question}<span class="math-equals">= ?</span>`;
            } else {
                problemEl.textContent = `${state.currentProblem.question} = ?`;
            }
        }

        // End math phase, transition to action
        function endSharedMathPhase() {
            if (mathInterval) {
                clearInterval(mathInterval);
                mathInterval = null;
            }

            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];
            state.phase = 'action';

            // Hide shared container's math phase
            document.getElementById('gameMathPhase').classList.add('hidden');

            // Hide shared container, show game-specific container for action phase
            document.getElementById('sharedGameContainer').style.display = 'none';
            document.getElementById('sharedGameContainer').classList.remove('active');

            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.add('active');
            gameElement.style.display = 'block';

            // Start the action phase
            config.startAction();
        }

        // Shared number pad input
        function addNumber(num) {
            sounds.playButtonClick();
            const input = document.getElementById('answerInput');
            if (input.value.length < 4) {
                input.value += num;

                // Auto-submit when answer has enough digits
                const state = gameManager.gameStates[currentGameType];
                if (state && state.currentProblem && input.value.length >= state.currentProblem.expectedDigits) {
                    setTimeout(() => submitSharedAnswer(), 100);
                }
            }
        }

        // Clear input
        function clearInput() {
            sounds.playButtonClick();
            document.getElementById('answerInput').value = '';
        }

        // Submit answer
        function submitSharedAnswer() {
            const state = gameManager.gameStates[currentGameType];
            const config = gameConfigs[currentGameType];
            const input = document.getElementById('answerInput');
            const userAnswer = parseInt(input.value);

            if (isNaN(userAnswer)) return;

            if (userAnswer === state.currentProblem.answer) {
                showSharedFeedback(true);
                state.resources++;
                state.score++;
                updateResourceDisplay(true);

                setTimeout(() => {
                    generateSharedProblem();
                    input.value = '';
                    clearSharedFeedback();
                }, 800);
            } else {
                showSharedFeedback(false);
                setTimeout(() => {
                    input.value = '';
                    clearSharedFeedback();
                }, 800);
            }
        }

        // Show feedback
        function showSharedFeedback(isCorrect) {
            const problemDisplay = document.getElementById('problemDisplay');
            const feedbackIcon = document.getElementById('feedbackIcon');
            const problemText = document.getElementById('problemText');

            if (isCorrect) {
                sounds.playCorrect();
                problemDisplay.classList.add('correct');
                feedbackIcon.textContent = '‚úì';
                feedbackIcon.className = 'feedback-icon show correct';

                const state = gameManager.gameStates[currentGameType];
                if (state.currentProblem.isHTML) {
                    problemText.innerHTML = `${state.currentProblem.question}<span class="math-equals">= ${state.currentProblem.answer}</span>`;
                } else {
                    problemText.textContent = `${state.currentProblem.question} = ${state.currentProblem.answer}`;
                }
            } else {
                sounds.playIncorrect();
                problemDisplay.classList.add('incorrect');
                feedbackIcon.textContent = '‚úó';
                feedbackIcon.className = 'feedback-icon show incorrect';
            }
        }

        // Clear feedback
        function clearSharedFeedback() {
            const problemDisplay = document.getElementById('problemDisplay');
            const feedbackIcon = document.getElementById('feedbackIcon');
            problemDisplay.classList.remove('correct', 'incorrect');
            feedbackIcon.classList.remove('show');
        }

        // Update resource display
        function updateResourceDisplay(animate = false) {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            document.getElementById('resourceCount').textContent = state.resources;
            updatePointsDisplay('resourceDisplay', state.resources, config.pointClass, animate);
        }

        // Show round complete screen
        function showRoundComplete(roundStats = {}) {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            // Hide game container, show shared container
            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.remove('active');
            gameElement.style.display = 'none';

            document.getElementById('sharedGameContainer').style.display = 'block';
            document.getElementById('sharedGameContainer').classList.add('active');
            document.getElementById('roundCompleteScreen').classList.remove('hidden');

            // Populate round number
            document.getElementById('completedRoundNumber').textContent = state.round;

            // Populate round-specific stats
            const statsContainer = document.getElementById('roundStats');
            statsContainer.innerHTML = '';
            Object.entries(roundStats).forEach(([label, value]) => {
                const div = document.createElement('div');
                div.innerHTML = `${label}: <span style="color: #27ae60; font-weight: bold;">${value}</span>`;
                statsContainer.appendChild(div);
            });
        }

        // Start next round
        function startNextRound() {
            sounds.playButtonClick();
            const state = gameManager.gameStates[currentGameType];
            state.round++;

            document.getElementById('roundCompleteScreen').classList.add('hidden');

            // In dev mode, add base resources for the next round
            if (state.devMode) {
                state.resources += 10;
            }

            startMathPhase();  // Always go through math phase
        }

        // Show game over screen
        function showGameOver() {
            const config = gameConfigs[currentGameType];
            const state = gameManager.gameStates[currentGameType];

            // Save stats to localStorage (skip in dev mode)
            if (!state.devMode) {
                storageManager.updateStats(
                    currentGameType,
                    gameManager.mathSettings.problemType,
                    gameManager.mathSettings.difficulty,
                    state.score,
                    state.round
                );
            }

            // Hide game container, show shared container
            const gameElement = document.getElementById(currentGameType + 'Game');
            gameElement.classList.remove('active');
            gameElement.style.display = 'none';

            document.getElementById('sharedGameContainer').style.display = 'block';
            document.getElementById('sharedGameContainer').classList.add('active');
            document.getElementById('gameOverScreen').classList.remove('hidden');

            // Populate title
            document.getElementById('gameOverTitle').innerHTML =
                `${config.gameOverIcon} ${config.gameOverTitle} ${config.gameOverIcon}`;
            document.getElementById('gameOverTitle').style.color = config.themeColor;

            // Populate stats
            const statsContainer = document.getElementById('gameOverStats');
            statsContainer.innerHTML = '';
            config.stats.forEach(stat => {
                const value = state[stat.key] || 0;
                const div = document.createElement('div');
                div.innerHTML = `${stat.label}: <span style="color: ${stat.color}; font-weight: bold;">${value}</span>`;
                statsContainer.appendChild(div);
            });

            // Update play again button text
            document.getElementById('playAgainBtn').textContent = config.playAgainText;
        }

        // Play again - reset and go to selection
        function playAgain() {
            sounds.playButtonClick();
            resetSharedGameState();

            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('gameSelectionScreen').classList.remove('hidden');

            // Redraw previews
            const config = gameConfigs[currentGameType];
            config.options.forEach((option, i) => {
                const canvas = document.getElementById(`preview${i}`);
                config.drawPreview(canvas, option.id);
            });
            updateSelectionHighlight();
        }

        // Reset game state for current game
        function resetSharedGameState() {
            const state = gameManager.gameStates[currentGameType];
            const config = gameConfigs[currentGameType];

            state.round = 1;
            state.score = 0;
            state.resources = 0;
            state.phase = 'start';
            state.devMode = false;

            // Hide DEV indicator
            updateDevIndicator();

            // Reset game-specific stats
            if (currentGameType === 'castle') state.totalTargetsDestroyed = 0;
            if (currentGameType === 'express') state.totalDistance = 0;
            if (currentGameType === 'miner') state.totalCoinsCollected = 0;
            if (currentGameType === 'plane') state.totalDistance = 0;
        }

        // ===== END SHARED GAME FUNCTIONS =====

        // Hub Navigation - now uses shared selection screen
        function selectGame(gameType) {
            gameManager.currentGame = gameType;
            showSelectionScreen(gameType);
        }

        function returnToHub() {
            sounds.playButtonClick();

            // Clear any running timer
            if (mathInterval) {
                clearInterval(mathInterval);
                mathInterval = null;
            }

            // Stop all game loops
            castleGame.gameRunning = false;
            expressGame.gameRunning = false;
            minerGame.miningRunning = false;
            planeGame.flightRunning = false;
            fieldgoalGame.gameRunning = false;

            // Hide shared container
            document.getElementById('sharedGameContainer').classList.remove('active');
            document.getElementById('sharedGameContainer').style.display = 'none';

            // Hide current game container
            if (gameManager.currentGame) {
                const gameElement = document.getElementById(gameManager.currentGame + 'Game');
                if (gameElement) {
                    gameElement.classList.remove('active');
                    gameElement.style.display = 'none';
                }

                // Reset game state
                resetSharedGameState();
            }

            // Show hub
            document.getElementById('gameHub').style.display = 'block';
            document.getElementById('gameHub').classList.add('active');
            gameManager.currentGame = null;
            currentGameType = null;
        }

        // ===== MY ADVENTURE FUNCTIONS =====

        function showMyAdventure() {
            sounds.playButtonClick();
            // Update title with profile name
            const profile = storageManager.getActiveProfile();
            document.querySelector('.adventure-title').textContent = `üìä ${profile.name}'s Adventure`;
            document.getElementById('gameHub').style.display = 'none';
            document.getElementById('myAdventureScreen').style.display = 'block';
            renderMathProgress();
        }

        function hideMyAdventure() {
            sounds.playButtonClick();
            document.getElementById('myAdventureScreen').style.display = 'none';
            document.getElementById('gameHub').style.display = 'block';
        }

        function showMathProgress() {
            document.getElementById('mathProgressTab').classList.add('active');
            document.getElementById('gameProgressTab').classList.remove('active');
            document.getElementById('mathProgressContent').style.display = 'block';
            document.getElementById('gameProgressContent').style.display = 'none';
            renderMathProgress();
        }

        function showGameProgress() {
            document.getElementById('mathProgressTab').classList.remove('active');
            document.getElementById('gameProgressTab').classList.add('active');
            document.getElementById('mathProgressContent').style.display = 'none';
            document.getElementById('gameProgressContent').style.display = 'block';
            renderGameProgress();
        }

        function renderMathProgress() {
            const modes = [
                { id: 'addition', icon: '‚ûï', name: 'Addition' },
                { id: 'subtraction', icon: '‚ûñ', name: 'Subtraction' },
                { id: 'multiplication', icon: '‚úñÔ∏è', name: 'Multiplication' },
                { id: 'division', icon: '‚ûó', name: 'Division' },
                { id: 'dice', icon: 'üé≤', name: 'Dice' },
                { id: 'coin', icon: 'ü™ô', name: 'Coins' },
                { id: 'change', icon: 'üíµ', name: 'Change' },
                { id: 'fractions', icon: '¬Ω', name: 'Fractions' },
                { id: 'hundred', icon: 'üíØ', name: 'Hundred' }
            ];
            const difficulties = ['easy', 'medium', 'hard'];

            const tbody = document.getElementById('mathProgressBody');
            tbody.innerHTML = '';

            modes.forEach(mode => {
                const row = document.createElement('tr');

                // Mode column
                const modeCell = document.createElement('td');
                modeCell.innerHTML = `<span class="mode-icon">${mode.icon}</span>${mode.name}`;
                row.appendChild(modeCell);

                // Difficulty columns
                difficulties.forEach(diff => {
                    const stats = storageManager.aggregateMathStats(mode.id, diff);
                    const cell = document.createElement('td');

                    if (stats.highScore === 0 && stats.totalScore === 0) {
                        cell.innerHTML = '<span class="stats-empty">‚Äî</span>';
                    } else {
                        cell.innerHTML = `
                            <div class="stats-cell">
                                <div class="stats-cell-row">
                                    <div class="stats-value">
                                        <span class="stats-label">High Score</span>
                                        <span class="stats-number">${stats.highScore}</span>
                                        <span class="stats-stars">${storageManager.getStars(stats.highScore, 'highScore')}</span>
                                    </div>
                                    <div class="stats-value">
                                        <span class="stats-label">Total Score</span>
                                        <span class="stats-number">${stats.totalScore}</span>
                                        <span class="stats-stars">${storageManager.getStars(stats.totalScore, 'totalScore')}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    row.appendChild(cell);
                });

                tbody.appendChild(row);
            });
        }

        function renderGameProgress() {
            const games = [
                { id: 'castle', icon: 'üè∞', name: 'Math Castle' },
                { id: 'express', icon: 'üöÇ', name: 'Math Express' },
                { id: 'miner', icon: '‚õèÔ∏è', name: 'Math Miner' },
                { id: 'plane', icon: '‚úàÔ∏è', name: 'Math Plane' },
                { id: 'fieldgoal', icon: 'üèà', name: 'Field Goals' },
                { id: 'minigolf', icon: '‚õ≥', name: 'Mini Golf' },
                { id: 'motorcycle', icon: 'üèçÔ∏è', name: 'Math Racer' },
                { id: 'snowball', icon: '‚ùÑÔ∏è', name: 'Snowball Math' }
            ];
            const difficulties = ['easy', 'medium', 'hard'];
            const modeFilter = document.getElementById('gameModeFilter').value || null;

            const tbody = document.getElementById('gameProgressBody');
            tbody.innerHTML = '';

            games.forEach(game => {
                const row = document.createElement('tr');

                // Game column
                const gameCell = document.createElement('td');
                gameCell.innerHTML = `<span class="game-icon">${game.icon}</span>${game.name}`;
                row.appendChild(gameCell);

                // Difficulty columns
                difficulties.forEach(diff => {
                    const stats = storageManager.aggregateGameStats(game.id, diff, modeFilter);
                    const cell = document.createElement('td');

                    if (stats.highestLevel === 0 && stats.totalLevels === 0) {
                        cell.innerHTML = '<span class="stats-empty">‚Äî</span>';
                    } else {
                        cell.innerHTML = `
                            <div class="stats-cell">
                                <div class="stats-cell-row">
                                    <div class="stats-value">
                                        <span class="stats-label">Highest Level</span>
                                        <span class="stats-number">${stats.highestLevel}</span>
                                        <span class="stats-stars">${storageManager.getStars(stats.highestLevel, 'highestLevel')}</span>
                                    </div>
                                    <div class="stats-value">
                                        <span class="stats-label">Total Levels</span>
                                        <span class="stats-number">${stats.totalLevels}</span>
                                        <span class="stats-stars">${storageManager.getStars(stats.totalLevels, 'totalLevels')}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    row.appendChild(cell);
                });

                tbody.appendChild(row);
            });
        }

        // ===== PROFILE MANAGEMENT FUNCTIONS =====

        // State for profile creation/editing
        let selectedAvatar = 'ü¶ä';
        let profileToDelete = null;

        // Update profile display in hub and all game screens
        function updateProfileDisplay() {
            const profile = storageManager.getActiveProfile();
            if (profile) {
                // Update hub profile display
                document.getElementById('currentProfileAvatar').textContent = profile.avatar;
                document.getElementById('currentProfileName').textContent = profile.name;

                // Update shared game container profile
                const sharedAvatar = document.getElementById('sharedProfileAvatar');
                const sharedName = document.getElementById('sharedProfileName');
                if (sharedAvatar) sharedAvatar.textContent = profile.avatar;
                if (sharedName) sharedName.textContent = profile.name;

                // Update all game profile displays (class-based)
                document.querySelectorAll('.gameProfileAvatar').forEach(el => {
                    el.textContent = profile.avatar;
                });
                document.querySelectorAll('.gameProfileName').forEach(el => {
                    el.textContent = profile.name;
                });
            }
        }

        // Toggle profile dropdown
        function toggleProfileDropdown() {
            const dropdown = document.getElementById('profileDropdown');
            if (dropdown.classList.contains('show')) {
                hideProfileDropdown();
            } else {
                renderProfileDropdown();
                dropdown.classList.add('show');
            }
        }

        // Hide profile dropdown
        function hideProfileDropdown() {
            document.getElementById('profileDropdown').classList.remove('show');
        }

        // Toggle game profile dropdown (for shared container on game selection screens)
        function toggleGameProfileDropdown(containerId) {
            const dropdown = document.getElementById(containerId + 'ProfileDropdown');
            if (dropdown.classList.contains('show')) {
                hideGameProfileDropdown(containerId);
            } else {
                renderGameProfileDropdown(containerId);
                dropdown.classList.add('show');
            }
        }

        // Hide game profile dropdown
        function hideGameProfileDropdown(containerId) {
            const dropdown = document.getElementById(containerId + 'ProfileDropdown');
            if (dropdown) dropdown.classList.remove('show');
        }

        // Render game profile dropdown items
        function renderGameProfileDropdown(containerId) {
            const profiles = storageManager.getAllProfiles();
            const activeProfile = storageManager.getActiveProfile();
            const dropdown = document.getElementById(containerId + 'ProfileDropdown');

            let html = '';
            profiles.forEach(profile => {
                const isActive = profile.id === activeProfile.id;
                html += `
                    <div class="profile-dropdown-item ${isActive ? 'active' : ''}" onclick="switchToProfileFromGame('${profile.id}', '${containerId}')">
                        <span class="profile-avatar">${profile.avatar}</span>
                        <span class="profile-name">${profile.name}</span>
                        ${isActive ? '<span class="check-mark">‚úì</span>' : ''}
                    </div>
                `;
            });

            html += '<div class="profile-dropdown-divider"></div>';
            html += `
                <div class="profile-dropdown-manage" onclick="showProfileManager()">
                    <span>‚öôÔ∏è</span>
                    <span>Manage Players</span>
                </div>
            `;

            dropdown.innerHTML = html;
        }

        // Switch profile from game selection screen
        function switchToProfileFromGame(profileId, containerId) {
            storageManager.switchProfile(profileId);
            updateProfileDisplay();
            hideGameProfileDropdown(containerId);
            sounds.playCorrect();
        }

        // Render profile dropdown items
        function renderProfileDropdown() {
            const profiles = storageManager.getAllProfiles();
            const activeProfile = storageManager.getActiveProfile();
            const dropdown = document.getElementById('profileDropdown');

            let html = '';
            profiles.forEach(profile => {
                const isActive = profile.id === activeProfile.id;
                html += `
                    <div class="profile-dropdown-item ${isActive ? 'active' : ''}" onclick="switchToProfile('${profile.id}')">
                        <span class="profile-avatar">${profile.avatar}</span>
                        <span class="profile-name">${profile.name}</span>
                        ${isActive ? '<span class="check-mark">‚úì</span>' : ''}
                    </div>
                `;
            });

            html += '<div class="profile-dropdown-divider"></div>';
            html += `
                <div class="profile-dropdown-manage" onclick="showProfileManager()">
                    <span>‚öôÔ∏è</span>
                    <span>Manage Players</span>
                </div>
            `;

            dropdown.innerHTML = html;
        }

        // Switch to a different profile
        function switchToProfile(profileId) {
            storageManager.switchProfile(profileId);
            updateProfileDisplay();
            hideProfileDropdown();
            sounds.playCorrect();
        }

        // Show profile manager modal
        function showProfileManager() {
            hideProfileDropdown();
            renderProfileList();
            document.getElementById('profileManagerModal').classList.add('show');
        }

        // Hide profile manager modal
        function hideProfileManager() {
            document.getElementById('profileManagerModal').classList.remove('show');
        }

        // Render list of profiles in manager
        function renderProfileList() {
            const profiles = storageManager.getAllProfiles();
            const canDelete = profiles.length > 1;
            const list = document.getElementById('profileList');

            let html = '';
            profiles.forEach(profile => {
                html += `
                    <div class="profile-list-item">
                        <span class="profile-avatar clickable" onclick="showEditAvatar('${profile.id}', '${profile.avatar}')" title="Click to change avatar">${profile.avatar}</span>
                        <span class="profile-name">${profile.name}</span>
                        ${canDelete ? `<button class="delete-profile-btn" onclick="showDeleteConfirm('${profile.id}', '${profile.name}')">üóëÔ∏è</button>` : ''}
                    </div>
                `;
            });

            list.innerHTML = html;
        }

        // State for avatar editing
        let editingProfileId = null;

        // Show avatar edit modal
        function showEditAvatar(profileId, currentAvatar) {
            editingProfileId = profileId;
            selectedAvatar = currentAvatar;
            renderAvatarGrid('editAvatarGrid');
            document.getElementById('editAvatarModal').classList.add('show');
        }

        // Hide avatar edit modal
        function hideEditAvatar() {
            editingProfileId = null;
            document.getElementById('editAvatarModal').classList.remove('show');
        }

        // Save edited avatar
        function saveEditedAvatar() {
            if (editingProfileId && selectedAvatar) {
                storageManager.updateProfileAvatar(editingProfileId, selectedAvatar);
                updateProfileDisplay();
                renderProfileList();
                hideEditAvatar();
                sounds.playCorrect();
            }
        }

        // Show create profile modal
        function showCreateProfile() {
            hideProfileDropdown();
            hideProfileManager();
            selectedAvatar = 'ü¶ä';
            document.getElementById('profileNameInput').value = '';
            renderAvatarGrid();
            document.getElementById('createProfileModal').classList.add('show');
            document.getElementById('profileNameInput').focus();
        }

        // Hide create profile modal
        function hideCreateProfile() {
            document.getElementById('createProfileModal').classList.remove('show');
        }

        // Render avatar selection grid
        function renderAvatarGrid(gridId = 'avatarGrid') {
            const grid = document.getElementById(gridId);
            let html = '';
            storageManager.AVATARS.forEach(avatar => {
                const isSelected = avatar === selectedAvatar;
                html += `<div class="avatar-option ${isSelected ? 'selected' : ''}" onclick="selectAvatar('${avatar}', '${gridId}')">${avatar}</div>`;
            });
            grid.innerHTML = html;
        }

        // Select an avatar
        function selectAvatar(avatar, gridId = 'avatarGrid') {
            selectedAvatar = avatar;
            renderAvatarGrid(gridId);
        }

        // Submit new profile
        function submitProfile() {
            const name = document.getElementById('profileNameInput').value.trim();
            if (!name) {
                document.getElementById('profileNameInput').focus();
                return;
            }

            storageManager.createProfile(name, selectedAvatar);
            updateProfileDisplay();
            hideCreateProfile();
            sounds.playCorrect();
        }

        // Show delete confirmation modal
        function showDeleteConfirm(profileId, profileName) {
            profileToDelete = profileId;
            document.getElementById('deleteProfileName').textContent = profileName;
            document.getElementById('deleteConfirmModal').classList.add('show');
        }

        // Hide delete confirmation modal
        function hideDeleteConfirm() {
            profileToDelete = null;
            document.getElementById('deleteConfirmModal').classList.remove('show');
        }

        // Confirm and delete profile
        function confirmDeleteProfile() {
            if (profileToDelete) {
                storageManager.deleteProfile(profileToDelete);
                updateProfileDisplay();
                renderProfileList();
                hideDeleteConfirm();
                sounds.playButtonClick();
            }
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(e) {
            // Close profile dropdown if clicking outside
            const dropdown = document.getElementById('profileDropdown');
            const profileButton = document.querySelector('.profile-button');
            if (dropdown && dropdown.classList.contains('show')) {
                if (!dropdown.contains(e.target) && !profileButton.contains(e.target)) {
                    hideProfileDropdown();
                }
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideProfileDropdown();
                hideProfileManager();
                hideCreateProfile();
                hideDeleteConfirm();
            }
        });

        // ===== END PROFILE MANAGEMENT =====

        // Shared function for visual point displays with gap for grouping by 5s
        function updatePointsDisplay(displayId, points, pointClass, animate = false) {
            const display = document.getElementById(displayId);
            if (!display) return;

            display.innerHTML = '';

            const large = Math.floor(points / 10);
            const small = points % 10;

            // Add large (10-point) blocks
            for (let i = 0; i < large; i++) {
                const block = document.createElement('div');
                block.className = `${pointClass}-large`;
                if (!animate) block.style.animation = 'none';
                display.appendChild(block);
            }

            // Add small (1-point) blocks with gap after 5th
            for (let i = 0; i < small; i++) {
                const block = document.createElement('div');
                block.className = pointClass;
                if (i === 5) block.classList.add('point-gap');  // Gap after 5th point
                if (!animate) block.style.animation = 'none';
                display.appendChild(block);
            }
        }

        function updateScore(gameType) {
            const state = gameManager.gameStates[gameType];

            // Update visual displays
            switch(gameType) {
                case 'castle':
                    castleGame.updateCannonDisplay();
                    break;
                case 'express':
                    expressGame.updateCoalDisplay();
                    break;
                case 'miner':
                    minerGame.updateDigDisplay();
                    break;
                case 'plane':
                    planeGame.updateWindDisplay();
                    break;
            }
        }

        // Mini Drawing Functions (used by gameConfigs)
        function drawMiniCastle(ctx, x, y, flagColor) {
            const scale = 0.6;

            // Castle base
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(x - 30 * scale, y - 20 * scale, 60 * scale, 40 * scale);

            // Towers
            ctx.fillRect(x - 35 * scale, y - 40 * scale, 20 * scale, 60 * scale);
            ctx.fillRect(x + 15 * scale, y - 40 * scale, 20 * scale, 60 * scale);
            ctx.fillRect(x - 10 * scale, y - 50 * scale, 20 * scale, 70 * scale);

            // Tower tops
            ctx.fillStyle = '#34495e';
            ctx.beginPath();
            ctx.moveTo(x - 40 * scale, y - 40 * scale);
            ctx.lineTo(x - 25 * scale, y - 55 * scale);
            ctx.lineTo(x - 10 * scale, y - 40 * scale);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x + 10 * scale, y - 40 * scale);
            ctx.lineTo(x + 25 * scale, y - 55 * scale);
            ctx.lineTo(x + 40 * scale, y - 40 * scale);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x - 15 * scale, y - 50 * scale);
            ctx.lineTo(x, y - 65 * scale);
            ctx.lineTo(x + 15 * scale, y - 50 * scale);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = '#f39c12';
            ctx.fillRect(x - 25 * scale, y - 10 * scale, 5 * scale, 8 * scale);
            ctx.fillRect(x + 20 * scale, y - 10 * scale, 5 * scale, 8 * scale);
            ctx.fillRect(x - 3 * scale, y - 20 * scale, 6 * scale, 8 * scale);

            // Gate
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 8 * scale, y + 5 * scale, 16 * scale, 15 * scale);
            ctx.beginPath();
            ctx.arc(x, y + 5 * scale, 8 * scale, 0, Math.PI, true);
            ctx.fill();

            // Flag
            drawMiniFlag(ctx, x, y - 65 * scale, flagColor, scale);
        }

        function drawMiniFlag(ctx, x, y, color, scale) {
            // Flag pole
            ctx.fillStyle = '#34495e';
            ctx.fillRect(x - 1, y - 20 * scale, 2, 25 * scale);

            // Flag ball on top
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y - 22 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Flag
            ctx.fillStyle = color === 'red' ? '#e74c3c' : '#3498db';
            ctx.beginPath();
            ctx.moveTo(x + 1, y - 20 * scale);
            ctx.lineTo(x + 20 * scale, y - 17 * scale);
            ctx.lineTo(x + 20 * scale, y - 7 * scale);
            ctx.lineTo(x + 1, y - 10 * scale);
            ctx.closePath();
            ctx.fill();
        }

        function drawMiniTrain(ctx, x, y, color) {
            const trainColor = color === 'red' ? '#e74c3c' : '#3498db';
            const scale = 1.2;

            // Engine body
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 25 * scale, y - 15 * scale, 50 * scale, 22 * scale);

            // Cab
            ctx.fillStyle = trainColor;
            ctx.fillRect(x - 30 * scale, y - 25 * scale, 25 * scale, 25 * scale);

            // Smokestack
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(x + 10 * scale, y - 30 * scale, 8 * scale, 15 * scale);
            ctx.fillRect(x + 7 * scale, y - 33 * scale, 14 * scale, 6 * scale);

            // Windows
            ctx.fillStyle = '#5dade2';
            ctx.fillRect(x - 26 * scale, y - 20 * scale, 8 * scale, 8 * scale);
            ctx.fillRect(x - 16 * scale, y - 20 * scale, 8 * scale, 8 * scale);

            // Cow catcher
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.moveTo(x + 25 * scale, y + 5 * scale);
            ctx.lineTo(x + 33 * scale, y + 12 * scale);
            ctx.lineTo(x + 25 * scale, y + 12 * scale);
            ctx.closePath();
            ctx.fill();

            // Wheels
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(x - 15 * scale, y + 12 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5 * scale, y + 12 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 20 * scale, y + 12 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Wheel highlights
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.arc(x - 15 * scale, y + 12 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5 * scale, y + 12 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 20 * scale, y + 12 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Smoke puffs
            ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.beginPath();
            ctx.arc(x + 14 * scale, y - 40 * scale, 6 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8 * scale, y - 50 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 18 * scale, y - 55 * scale, 5 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMiniPlane(ctx, x, y, color) {
            const planeColor = color === 'red' ? '#e74c3c' : '#3498db';
            const accentColor = color === 'red' ? '#c0392b' : '#2980b9';
            const scale = 3;

            ctx.save();
            ctx.translate(x, y);

            // Main body (fuselage)
            ctx.fillStyle = planeColor;
            ctx.beginPath();
            ctx.moveTo(20 * scale, 0);
            ctx.lineTo(-15 * scale, -3 * scale);
            ctx.lineTo(-20 * scale, 0);
            ctx.lineTo(-15 * scale, 3 * scale);
            ctx.closePath();
            ctx.fill();

            // Nose cone
            ctx.fillStyle = accentColor;
            ctx.beginPath();
            ctx.moveTo(20 * scale, 0);
            ctx.lineTo(15 * scale, -2 * scale);
            ctx.lineTo(15 * scale, 2 * scale);
            ctx.closePath();
            ctx.fill();

            // Main wing
            ctx.fillStyle = planeColor;
            ctx.beginPath();
            ctx.moveTo(5 * scale, 0);
            ctx.lineTo(-5 * scale, -15 * scale);
            ctx.lineTo(-10 * scale, -15 * scale);
            ctx.lineTo(-5 * scale, 0);
            ctx.lineTo(-10 * scale, 15 * scale);
            ctx.lineTo(-5 * scale, 15 * scale);
            ctx.closePath();
            ctx.fill();

            // Wing stripe
            ctx.fillStyle = accentColor;
            ctx.fillRect(-8 * scale, -12 * scale, 2 * scale, 24 * scale);

            // Tail fin (vertical)
            ctx.fillStyle = planeColor;
            ctx.beginPath();
            ctx.moveTo(-15 * scale, 0);
            ctx.lineTo(-20 * scale, -8 * scale);
            ctx.lineTo(-22 * scale, -8 * scale);
            ctx.lineTo(-20 * scale, 0);
            ctx.closePath();
            ctx.fill();

            // Tail fin (horizontal)
            ctx.beginPath();
            ctx.moveTo(-15 * scale, 0);
            ctx.lineTo(-20 * scale, -4 * scale);
            ctx.lineTo(-22 * scale, -4 * scale);
            ctx.lineTo(-22 * scale, 4 * scale);
            ctx.lineTo(-20 * scale, 4 * scale);
            ctx.closePath();
            ctx.fill();

            // Cockpit window
            ctx.fillStyle = '#5dade2';
            ctx.beginPath();
            ctx.ellipse(10 * scale, 0, 4 * scale, 2 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            // Window shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.ellipse(11 * scale, -0.5 * scale, 2 * scale, 1 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Motion lines
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x - 25 * scale - i * 8, y - 5 + i * 5);
                ctx.lineTo(x - 35 * scale - i * 8, y - 5 + i * 5);
                ctx.stroke();
            }
        }

        function drawMiniMiner(ctx, x, y, color) {
            const bodyColor = color === 'red' ? '#e74c3c' : '#3498db';
            const scale = 2.5;

            // Hard hat
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.ellipse(x, y - 20 * scale, 10 * scale, 6 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(x - 8 * scale, y - 22 * scale, 16 * scale, 8 * scale);

            // Hat light
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath();
            ctx.arc(x, y - 24 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Face
            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(x, y - 10 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(x - 3 * scale, y - 12 * scale, 1.5 * scale, 0, Math.PI * 2);
            ctx.arc(x + 3 * scale, y - 12 * scale, 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x, y - 8 * scale, 3 * scale, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Body (colored)
            ctx.fillStyle = bodyColor;
            ctx.fillRect(x - 8 * scale, y - 2 * scale, 16 * scale, 18 * scale);

            // Arms
            ctx.fillRect(x - 12 * scale, y, 4 * scale, 12 * scale);
            ctx.fillRect(x + 8 * scale, y, 4 * scale, 12 * scale);

            // Hands
            ctx.fillStyle = '#fad7a0';
            ctx.beginPath();
            ctx.arc(x - 10 * scale, y + 14 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.arc(x + 10 * scale, y + 14 * scale, 3 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#5d4e37';
            ctx.fillRect(x - 6 * scale, y + 16 * scale, 5 * scale, 10 * scale);
            ctx.fillRect(x + 1 * scale, y + 16 * scale, 5 * scale, 10 * scale);

            // Boots
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 7 * scale, y + 24 * scale, 6 * scale, 4 * scale);
            ctx.fillRect(x + 1 * scale, y + 24 * scale, 6 * scale, 4 * scale);

            // Pickaxe
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 15 * scale, y - 5 * scale);
            ctx.lineTo(x + 25 * scale, y + 15 * scale);
            ctx.stroke();

            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.moveTo(x + 13 * scale, y - 8 * scale);
            ctx.lineTo(x + 20 * scale, y - 2 * scale);
            ctx.lineTo(x + 17 * scale, y - 5 * scale);
            ctx.lineTo(x + 10 * scale, y - 5 * scale);
            ctx.closePath();
            ctx.fill();
        }

        function drawMiniKicker(ctx, x, y, color) {
            const kickerColor = color === 'red' ? '#e74c3c' : '#3498db';
            const scale = 2;

            // Draw mini field
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(x - 50, y + 20, 100, 35);

            // Draw goal posts
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 3;
            ctx.beginPath();
            // Left post
            ctx.moveTo(x + 25, y + 20);
            ctx.lineTo(x + 25, y - 20);
            // Right post
            ctx.moveTo(x + 45, y + 20);
            ctx.lineTo(x + 45, y - 20);
            // Crossbar
            ctx.moveTo(x + 25, y - 20);
            ctx.lineTo(x + 45, y - 20);
            ctx.stroke();

            // Upper extensions
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 25, y - 20);
            ctx.lineTo(x + 25, y - 30);
            ctx.moveTo(x + 45, y - 20);
            ctx.lineTo(x + 45, y - 30);
            ctx.stroke();

            // Draw kicker
            // Body
            ctx.fillStyle = kickerColor;
            ctx.fillRect(x - 30, y - 5, 15, 25);

            // Head
            ctx.fillStyle = '#fdbf6f';
            ctx.beginPath();
            ctx.arc(x - 22, y - 12, 8, 0, Math.PI * 2);
            ctx.fill();

            // Helmet
            ctx.fillStyle = kickerColor;
            ctx.beginPath();
            ctx.arc(x - 22, y - 14, 9, Math.PI, 0);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x - 28, y + 20, 5, 12);
            // Kicking leg
            ctx.save();
            ctx.translate(x - 20, y + 20);
            ctx.rotate(-0.6);
            ctx.fillRect(0, 0, 5, 15);
            ctx.restore();

            // Draw football in flight
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(x + 5, y - 5, 10, 6, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Laces on football
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x + 2, y - 5);
            ctx.lineTo(x + 8, y - 5);
            ctx.stroke();
        }


        // Global keyboard handler
        function handleGlobalKeyPress(e) {
            // Handle Enter key for action buttons (green buttons like Next Round, Play Again, Start)
            if (e.key === 'Enter') {
                // Check for visible action buttons in priority order
                const actionButtons = [
                    document.getElementById('nextRoundBtn'),      // Next Round
                    document.getElementById('playAgainBtn'),      // Play Again
                    document.getElementById('startGameBtn'),      // Start Game
                    document.getElementById('submitAnswer')       // Submit Math Answer
                ];

                for (const btn of actionButtons) {
                    if (btn && btn.offsetParent !== null && !btn.closest('.hidden')) {
                        e.preventDefault();
                        btn.click();
                        return;
                    }
                }
            }

            if (!gameManager.currentGame && !currentGameType) return;

            const currentGame = currentGameType || gameManager.currentGame;
            const state = gameManager.gameStates[currentGame];

            // Centralized + key handler for dev mode (works in both math and action phases)
            if ((e.key === '+' || e.key === '=') && state.devMode) {
                e.preventDefault();
                state.resources++;

                // Update display based on current phase
                if (state.phase === 'math') {
                    updateResourceDisplay();
                } else {
                    // Update game-specific resource display
                    switch (currentGame) {
                        case 'castle':
                            castleGame.updateCannonDisplay();
                            break;
                        case 'miner':
                            minerGame.updateMiningDisplay();
                            break;
                        case 'plane':
                            planeGame.updateFlightDisplay();
                            break;
                        // Other games update display in their game loops
                    }
                }
                return;
            }

            if (state.phase === 'math') {
                if (e.key >= '0' && e.key <= '9') {
                    // Use shared input system (addNumber handles sound and auto-submit)
                    addNumber(e.key);
                } else if (e.key === 'Backspace' || e.key === 'Delete') {
                    clearInput();
                }
            } else if (currentGame === 'castle' && state.phase === 'cannon') {
                castleGame.handleCannonKeyPress(e);
            } else if (currentGame === 'express' && state.phase === 'train') {
                expressGame.handleTrainKeyPress(e);
            } else if (currentGame === 'miner' && state.phase === 'mining') {
                minerGame.handleMiningKeyPress(e);
            } else if (currentGame === 'plane' && state.phase === 'flight') {
                planeGame.handleFlightKeyPress(e);
            }
        }

        // Add keyboard listener
        document.addEventListener('keydown', handleGlobalKeyPress);

        // === MINER GAME MODULE ===
        const minerGame = {
            canvas: null,
            ctx: null,
            GRID_WIDTH: 16,
            GRID_HEIGHT: 12,
            BLOCK_SIZE: 32,
            TERRAIN_TYPES: { AIR: 0, GRASS: 1, DIRT: 2, COIN: 3 },
            terrain: [],
            coinPositions: [],
            particles: [],
            playerPosition: { x: 8, y: 3 },
            miningRunning: false,
            mathTimer: 60,
            mathInterval: null,
            roundCoinsCollected: 0,
            totalCoins: 3,

            init() {
                this.canvas = document.getElementById('minerGameCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                    this.ctx.imageSmoothingEnabled = false;
                }
            },

            updateDigDisplay(animate = false) {
                const state = gameManager.gameStates.miner;
                const pointsEl = document.getElementById('minerDigPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('minerDigDisplay', state.resources, 'dig-point', animate);
            },

            addDigPoint() {
                this.updateDigDisplay(true);
            },

            showMiningPhase() {
                const state = gameManager.gameStates.miner;
                state.phase = 'mining';

                // Show mining phase (container switching is handled by shared system)
                document.getElementById('minerMiningPhase').classList.remove('hidden');

                this.startMining();
            },

            startMining() {
                const state = gameManager.gameStates.miner;
                this.roundCoinsCollected = 0;
                this.totalCoins = Math.min(3 + state.round - 1, 8);
                this.playerPosition = { x: 8, y: 3 };
                this.particles = [];

                this.generateTerrain(state.round);
                this.updateMiningDisplay();
                this.miningRunning = true;
                this.gameLoop();
            },

            generateTerrain(round) {
                this.terrain = [];
                this.coinPositions = [];

                // Initialize grid
                for (let y = 0; y < this.GRID_HEIGHT; y++) {
                    this.terrain[y] = [];
                    for (let x = 0; x < this.GRID_WIDTH; x++) {
                        if (y < 4) {
                            this.terrain[y][x] = this.TERRAIN_TYPES.AIR;
                        } else if (y === 4) {
                            this.terrain[y][x] = this.TERRAIN_TYPES.GRASS;
                        } else {
                            this.terrain[y][x] = this.TERRAIN_TYPES.DIRT;
                        }
                    }
                }

                // Place coins based on round
                if (round === 1) {
                    this.placeCoin(8, 6);
                    this.placeCoin(8, 8);
                    this.placeCoin(8, 10);
                } else if (round === 2) {
                    this.placeCoin(8, 6);
                    this.placeCoin(8, 8);
                    this.placeCoin(10, 8);
                    this.placeCoin(12, 8);
                } else if (round === 3) {
                    this.placeCoin(4, 7);
                    this.placeCoin(8, 9);
                    this.placeCoin(12, 7);
                    this.placeCoin(6, 11);
                    this.placeCoin(10, 11);
                } else {
                    // Random placement for later rounds
                    const numCoins = Math.min(5 + (round - 3), 8);
                    let placed = 0;
                    while (placed < numCoins) {
                        const x = 2 + Math.floor(Math.random() * 10);
                        const y = 6 + Math.floor(Math.random() * 5);
                        if (this.terrain[y][x] === this.TERRAIN_TYPES.DIRT) {
                            this.placeCoin(x, y);
                            placed++;
                        }
                    }
                }
            },

            placeCoin(x, y) {
                this.terrain[y][x] = this.TERRAIN_TYPES.COIN;
                this.coinPositions.push({ x, y });
            },

            movePlayer(dx, dy) {
                const state = gameManager.gameStates.miner;
                const newX = this.playerPosition.x + dx;
                const newY = this.playerPosition.y + dy;

                // Bounds check
                if (newX < 0 || newX >= this.GRID_WIDTH || newY < 0 || newY >= this.GRID_HEIGHT) {
                    return;
                }

                const targetTerrain = this.terrain[newY][newX];

                if (targetTerrain === this.TERRAIN_TYPES.AIR) {
                    // Free movement
                    this.playerPosition.x = newX;
                    this.playerPosition.y = newY;
                    sounds.playMove();
                } else if (targetTerrain === this.TERRAIN_TYPES.GRASS || targetTerrain === this.TERRAIN_TYPES.DIRT) {
                    // Need to dig
                    if (state.resources > 0) {
                        state.resources--;
                        this.digBlock(newX, newY);
                        this.playerPosition.x = newX;
                        this.playerPosition.y = newY;
                        sounds.playDig();
                        this.updateMiningDisplay();
                    } else {
                        sounds.playIncorrect();
                    }
                } else if (targetTerrain === this.TERRAIN_TYPES.COIN) {
                    // Collect coin
                    this.collectCoin(newX, newY);
                    this.playerPosition.x = newX;
                    this.playerPosition.y = newY;
                }
            },

            digBlock(x, y) {
                this.terrain[y][x] = this.TERRAIN_TYPES.AIR;

                // Create particles
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x * this.BLOCK_SIZE + this.BLOCK_SIZE / 2,
                        y: y * this.BLOCK_SIZE + this.BLOCK_SIZE / 2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3 - 1,
                        life: 30,
                        color: y === 4 ? '#27ae60' : '#8B4513'
                    });
                }
            },

            collectCoin(x, y) {
                this.terrain[y][x] = this.TERRAIN_TYPES.AIR;
                this.roundCoinsCollected++;
                gameManager.gameStates.miner.totalCoinsCollected++;
                sounds.playCoin();
                this.updateMiningDisplay();

                // Check if all coins collected
                if (this.roundCoinsCollected >= this.totalCoins) {
                    setTimeout(() => this.endRound(true), 500);
                }
            },

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3; // Gravity
                    p.life--;
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },

            updateMiningDisplay() {
                const state = gameManager.gameStates.miner;
                document.getElementById('minerDigRemaining').textContent = state.resources;
                document.getElementById('minerCoinsDisplay').textContent = `${this.roundCoinsCollected}/${this.totalCoins}`;
            },

            endRound(success) {
                this.miningRunning = false;
                const state = gameManager.gameStates.miner;

                if (success) {
                    // Use shared round complete screen
                    showRoundComplete({
                        'Coins Collected': this.roundCoinsCollected,
                        'Total Coins': state.totalCoinsCollected
                    });
                } else {
                    showGameOver();
                }
            },

            render() {
                if (!this.ctx) return;
                const ctx = this.ctx;

                // Clear canvas
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw terrain
                for (let y = 0; y < this.GRID_HEIGHT; y++) {
                    for (let x = 0; x < this.GRID_WIDTH; x++) {
                        const terrain = this.terrain[y][x];
                        const px = x * this.BLOCK_SIZE;
                        const py = y * this.BLOCK_SIZE;

                        if (terrain === this.TERRAIN_TYPES.GRASS) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(px, py, this.BLOCK_SIZE, this.BLOCK_SIZE);
                            ctx.fillStyle = '#27ae60';
                            ctx.fillRect(px, py, this.BLOCK_SIZE, 8);
                        } else if (terrain === this.TERRAIN_TYPES.DIRT) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(px, py, this.BLOCK_SIZE, this.BLOCK_SIZE);
                            // Add texture
                            ctx.fillStyle = '#654321';
                            for (let i = 0; i < 3; i++) {
                                const tx = px + ((x * 7 + i * 11) % 28) + 2;
                                const ty = py + ((y * 13 + i * 17) % 28) + 2;
                                ctx.fillRect(tx, ty, 2, 2);
                            }
                        } else if (terrain === this.TERRAIN_TYPES.COIN) {
                            // Draw coin
                            const coinX = px + this.BLOCK_SIZE / 2;
                            const coinY = py + this.BLOCK_SIZE / 2;
                            const scale = 0.8 + Math.sin(Date.now() * 0.005) * 0.1;

                            ctx.fillStyle = '#f1c40f';
                            ctx.beginPath();
                            ctx.arc(coinX, coinY, 10 * scale, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = '#f39c12';
                            ctx.beginPath();
                            ctx.arc(coinX, coinY, 7 * scale, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = '#2c3e50';
                            ctx.font = 'bold 10px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('$', coinX, coinY);
                        }
                    }
                }

                // Draw particles
                for (const p of this.particles) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 30;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                }
                ctx.globalAlpha = 1;

                // Draw player
                this.drawMiner(this.playerPosition.x * this.BLOCK_SIZE, this.playerPosition.y * this.BLOCK_SIZE);
            },

            checkGameOver() {
                // Check for game over (no dig points and unreachable coins)
                const state = gameManager.gameStates.miner;
                if (state.resources <= 0 && this.roundCoinsCollected < this.totalCoins) {
                    // Check if any coins are in AIR (reachable)
                    let hasReachableCoins = false;
                    for (const coin of this.coinPositions) {
                        if (this.terrain[coin.y][coin.x] === this.TERRAIN_TYPES.COIN) {
                            // Check if adjacent cells have air
                            const adjacent = [
                                [coin.x - 1, coin.y], [coin.x + 1, coin.y],
                                [coin.x, coin.y - 1], [coin.x, coin.y + 1]
                            ];
                            for (const [ax, ay] of adjacent) {
                                if (ax >= 0 && ax < this.GRID_WIDTH && ay >= 0 && ay < this.GRID_HEIGHT) {
                                    if (this.terrain[ay][ax] === this.TERRAIN_TYPES.AIR) {
                                        hasReachableCoins = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (hasReachableCoins) break;
                    }
                    if (!hasReachableCoins && this.roundCoinsCollected < this.totalCoins) {
                        this.endRound(false);
                        return true;
                    }
                }
                return false;
            },

            drawMiner(x, y) {
                const ctx = this.ctx;
                const minerColor = gameManager.gameStates.miner.minerColor;
                const bodyColor = minerColor === 'red' ? '#e74c3c' : '#3498db';

                // Body (uses selected color)
                ctx.fillStyle = bodyColor;
                ctx.fillRect(x + 8, y + 12, 16, 16);

                // Head
                ctx.fillStyle = '#FDBCB4';
                ctx.fillRect(x + 10, y + 4, 12, 10);

                // Hair (same color for both, just different character names)
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(x + 8, y + 2, 16, 6);

                // Helmet
                ctx.fillStyle = '#f1c40f';
                ctx.strokeStyle = '#e67e22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x + 16, y + 6, 10, Math.PI, 0);
                ctx.stroke();

                // Arms
                ctx.fillStyle = '#FDBCB4';
                ctx.fillRect(x + 4, y + 14, 4, 8);
                ctx.fillRect(x + 24, y + 14, 4, 8);

                // Legs
                ctx.fillStyle = '#654321';
                ctx.fillRect(x + 10, y + 24, 6, 8);
                ctx.fillRect(x + 16, y + 24, 6, 8);
            },

            gameLoop() {
                if (!this.miningRunning) return;

                this.updateParticles();
                this.render();

                // Check for game over after rendering
                if (this.checkGameOver()) return;

                requestAnimationFrame(() => this.gameLoop());
            },

            handleMiningKeyPress(e) {
                if (!this.miningRunning) return;

                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        this.movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        this.movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        this.movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        this.movePlayer(1, 0);
                        break;
                }
            }
        };

        // === PLANE GAME MODULE ===
        const planeGame = {
            canvas: null,
            ctx: null,
            airplane: {
                x: 50,
                y: 180,
                velocityX: 0,
                velocityY: 0,
                speed: 0,
                altitude: 120,
                onGround: false,
                width: 40,
                height: 20,
                angle: 0
            },
            background: {
                clouds: [],
                trees: [],      // Deciduous trees (forest, hills)
                pines: [],      // Pine trees (mountains)
                hills: [],      // Rolling hills
                mountains: [],  // Mountain peaks
                mesas: [],      // Desert mesas
                cacti: []       // Desert cacti
            },
            flightRunning: false,
            launched: false,
            mathTimer: 60,
            mathInterval: null,
            distance: 0,
            targetDistance: 600,

            // Landing zone configuration (symmetric around target)
            // Layout: RED - ORANGE - GREEN(trashcan) - ORANGE - RED
            landingZones: {
                redWidth: 60,       // Each side
                orangeWidth: 40,    // Each side
                greenWidth: 30,     // Center zone (half size of red)
                trashcanWidth: 10,  // Bullseye in center of green
                redBonus: 0,        // "YOU LANDED!"
                orangeBonus: 100,   // +100 distance
                greenBonus: 500,    // +500 distance
                trashcanBonus: 250  // Extra bonus for hitting trashcan
            },

            // Biome configuration for dynamic backgrounds
            // Each biome spans 600 distance units, backgrounds stop before landing zone
            biomeConfigs: {
                forest: {
                    trees: { count: 12, spacing: 50, heightRange: [30, 50] },
                    clouds: { count: 8, yRange: [20, 80] },
                    groundColor: '#27ae60'
                },
                hills: {
                    hills: { count: 4, heightRange: [40, 80], widthRange: [150, 300] },
                    trees: { count: 6, spacing: 100, heightRange: [25, 40] },
                    clouds: { count: 6, yRange: [10, 60] },
                    groundColor: '#9ACD32',
                    hillColor: '#6B8E23'
                },
                mountains: {
                    mountains: { count: 3, heightRange: [80, 140], widthRange: [200, 400] },
                    pines: { count: 8, spacing: 75, heightRange: [35, 55] },
                    clouds: { count: 4, yRange: [5, 40] },
                    groundColor: '#8FBC8F',
                    mountainColor: '#708090'
                },
                desert: {
                    mesas: { count: 2, heightRange: [50, 90], widthRange: [150, 250] },
                    cacti: { count: 8, spacing: 75, heightRange: [20, 40] },
                    clouds: { count: 2, yRange: [15, 50] },
                    groundColor: '#DEB887',
                    mesaColor: '#CD853F'
                }
            },

            // Biome sequence: Forest -> Hills -> Mountains -> Desert (repeats)
            biomeSequence: ['forest', 'hills', 'mountains', 'desert'],
            biomeLength: 600, // Each biome spans 600 distance units

            init() {
                this.canvas = document.getElementById('planeGameCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                    this.ctx.imageSmoothingEnabled = false;
                }
                this.initializeBackground();
            },

            initializeBackground() {
                // Clear all background arrays
                this.background.clouds = [];
                this.background.trees = [];
                this.background.pines = [];
                this.background.hills = [];
                this.background.mountains = [];
                this.background.mesas = [];
                this.background.cacti = [];
            },

            // Get the biome type for a given distance
            getBiomeForDistance(distance) {
                const biomeIndex = Math.floor(distance / this.biomeLength);
                return this.biomeSequence[biomeIndex % this.biomeSequence.length];
            },

            // Generate all biomes up to target distance (excluding landing zone)
            generateBiomes(targetDistance) {
                this.initializeBackground();

                // Calculate landing zone start (backgrounds stop before landing zone)
                const zones = this.landingZones;
                const zoneRadius = zones.greenWidth / 2 + zones.orangeWidth + zones.redWidth;
                const backgroundEndDistance = targetDistance - zoneRadius;

                // Generate each biome section
                let currentDistance = 0;
                while (currentDistance < backgroundEndDistance) {
                    const biomeType = this.getBiomeForDistance(currentDistance);
                    const biomeEnd = Math.min(
                        currentDistance + this.biomeLength,
                        backgroundEndDistance
                    );

                    this.generateBiomeSection(biomeType, currentDistance, biomeEnd);
                    currentDistance += this.biomeLength;
                }
            },

            // Parallax factors for each element type (slower = further back)
            parallaxFactors: {
                clouds: 0.3,
                mountains: 0.3,
                mesas: 0.4,
                hills: 0.5,
                pines: 0.6,
                trees: 0.7,
                cacti: 0.7
            },

            // Generate background elements for a specific biome section
            generateBiomeSection(biomeType, startDistance, endDistance) {
                const config = this.biomeConfigs[biomeType];
                const pixelScale = 4; // distance units to pixels
                const baseStartX = startDistance * pixelScale;
                const baseEndX = endDistance * pixelScale;
                const baseSectionWidth = baseEndX - baseStartX;

                // Helper to calculate x position with parallax compensation
                // Elements with slower parallax need smaller x values to appear at the right screen position
                const getParallaxX = (baseX, parallax) => baseX * parallax;

                // Generate clouds for this section (parallax 0.3)
                if (config.clouds) {
                    const parallax = this.parallaxFactors.clouds;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const cloudCount = config.clouds.count;
                    for (let i = 0; i < cloudCount; i++) {
                        this.background.clouds.push({
                            x: startX + Math.random() * sectionWidth,
                            y: config.clouds.yRange[0] + Math.random() * (config.clouds.yRange[1] - config.clouds.yRange[0]),
                            width: 40 + Math.random() * 40,
                            height: 20 + Math.random() * 15,
                            biome: biomeType
                        });
                    }
                }

                // Generate trees (deciduous) for forest and hills (parallax 0.7)
                if (config.trees) {
                    const parallax = this.parallaxFactors.trees;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const treeCount = config.trees.count;
                    const spacing = config.trees.spacing * pixelScale * parallax;
                    for (let i = 0; i < treeCount; i++) {
                        const baseX = startX + (i / treeCount) * sectionWidth;
                        this.background.trees.push({
                            x: baseX + (Math.random() - 0.5) * spacing,
                            height: config.trees.heightRange[0] + Math.random() * (config.trees.heightRange[1] - config.trees.heightRange[0]),
                            biome: biomeType
                        });
                    }
                }

                // Generate hills (parallax 0.5)
                if (config.hills) {
                    const parallax = this.parallaxFactors.hills;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const hillCount = config.hills.count;
                    for (let i = 0; i < hillCount; i++) {
                        const width = config.hills.widthRange[0] + Math.random() * (config.hills.widthRange[1] - config.hills.widthRange[0]);
                        this.background.hills.push({
                            x: startX + (i / hillCount) * sectionWidth + Math.random() * (sectionWidth / hillCount),
                            width: width,
                            height: config.hills.heightRange[0] + Math.random() * (config.hills.heightRange[1] - config.hills.heightRange[0]),
                            color: config.hillColor,
                            biome: biomeType
                        });
                    }
                }

                // Generate mountains (parallax 0.3)
                if (config.mountains) {
                    const parallax = this.parallaxFactors.mountains;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const mountainCount = config.mountains.count;
                    for (let i = 0; i < mountainCount; i++) {
                        const width = config.mountains.widthRange[0] + Math.random() * (config.mountains.widthRange[1] - config.mountains.widthRange[0]);
                        this.background.mountains.push({
                            x: startX + (i / mountainCount) * sectionWidth + Math.random() * (sectionWidth / mountainCount),
                            width: width,
                            height: config.mountains.heightRange[0] + Math.random() * (config.mountains.heightRange[1] - config.mountains.heightRange[0]),
                            color: config.mountainColor,
                            biome: biomeType
                        });
                    }
                }

                // Generate pine trees (parallax 0.6)
                if (config.pines) {
                    const parallax = this.parallaxFactors.pines;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const pineCount = config.pines.count;
                    const spacing = config.pines.spacing * pixelScale * parallax;
                    for (let i = 0; i < pineCount; i++) {
                        const baseX = startX + (i / pineCount) * sectionWidth;
                        this.background.pines.push({
                            x: baseX + (Math.random() - 0.5) * spacing,
                            height: config.pines.heightRange[0] + Math.random() * (config.pines.heightRange[1] - config.pines.heightRange[0]),
                            biome: biomeType
                        });
                    }
                }

                // Generate mesas (parallax 0.4)
                if (config.mesas) {
                    const parallax = this.parallaxFactors.mesas;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const mesaCount = config.mesas.count;
                    for (let i = 0; i < mesaCount; i++) {
                        const width = config.mesas.widthRange[0] + Math.random() * (config.mesas.widthRange[1] - config.mesas.widthRange[0]);
                        this.background.mesas.push({
                            x: startX + (i / mesaCount) * sectionWidth + Math.random() * (sectionWidth / mesaCount),
                            width: width,
                            height: config.mesas.heightRange[0] + Math.random() * (config.mesas.heightRange[1] - config.mesas.heightRange[0]),
                            color: config.mesaColor,
                            biome: biomeType
                        });
                    }
                }

                // Generate cacti (parallax 0.7)
                if (config.cacti) {
                    const parallax = this.parallaxFactors.cacti;
                    const startX = getParallaxX(baseStartX, parallax);
                    const sectionWidth = getParallaxX(baseSectionWidth, parallax);
                    const cactiCount = config.cacti.count;
                    const spacing = config.cacti.spacing * pixelScale * parallax;
                    for (let i = 0; i < cactiCount; i++) {
                        const baseX = startX + (i / cactiCount) * sectionWidth;
                        this.background.cacti.push({
                            x: baseX + (Math.random() - 0.5) * spacing,
                            height: config.cacti.heightRange[0] + Math.random() * (config.cacti.heightRange[1] - config.cacti.heightRange[0]),
                            biome: biomeType
                        });
                    }
                }
            },

            updateWindDisplay(animate = false) {
                const state = gameManager.gameStates.plane;
                const pointsEl = document.getElementById('planeWindPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('planeWindDisplay', state.resources, 'wind-point', animate);
            },

            addWindPoint() {
                this.updateWindDisplay(true);
            },

            showFlightPhase() {
                const state = gameManager.gameStates.plane;
                state.phase = 'flight';

                // Show flight phase (container switching is handled by shared system)
                document.getElementById('planeFlightPhase').classList.remove('hidden');

                this.startFlight();
            },

            startFlight() {
                const state = gameManager.gameStates.plane;

                // Reset airplane
                this.airplane.x = 50;
                this.airplane.y = 180;
                this.airplane.velocityX = 0;
                this.airplane.velocityY = 0;
                this.airplane.speed = 0;
                this.airplane.altitude = 120;
                this.airplane.onGround = true;
                this.airplane.angle = 0;

                this.distance = 0;
                this.targetDistance = state.round * 600;
                this.launched = false;
                this.flightRunning = true;

                // Generate biomes based on target distance
                this.generateBiomes(this.targetDistance);

                // Update UI
                document.getElementById('planeFlightRoundNumber').textContent = state.round;
                document.getElementById('planeTargetDisplay').textContent = this.targetDistance;
                document.getElementById('planeLaunchIndicator').style.display = 'block';

                this.updateFlightDisplay();
                this.gameLoop();
            },

            useWind() {
                const state = gameManager.gameStates.plane;

                if (!this.launched) {
                    // First use: launch (FREE - no wind cost)
                    this.launched = true;
                    this.airplane.velocityX = 7;
                    this.airplane.velocityY = -2;
                    this.airplane.onGround = false;
                    document.getElementById('planeLaunchIndicator').style.display = 'none';
                    sounds.playWhoosh();
                } else {
                    // Subsequent: boost (costs wind point)
                    if (state.resources <= 0) {
                        sounds.playIncorrect();
                        return;
                    }
                    state.resources--;
                    sounds.playWhoosh();

                    const speedFactor = Math.max(0.5, 1 - (this.airplane.speed / 15));
                    this.airplane.velocityX += 3.5 * speedFactor;
                    this.airplane.velocityY -= 0.3;
                }

                this.updateFlightDisplay();
            },

            airBrake() {
                if (!this.launched) return;

                this.airplane.velocityX *= 0.7;
                this.airplane.velocityY *= 0.7;
                sounds.playButtonClick();
            },

            updateFlightDisplay() {
                const state = gameManager.gameStates.plane;
                document.getElementById('planeWindRemaining').textContent = state.resources;
                document.getElementById('planeDistanceDisplay').textContent = Math.floor(this.distance);
                document.getElementById('planeAltitudeDisplay').textContent = Math.floor(this.airplane.altitude);

                // Hide launch indicator after launch (launch is free, so show even with 0 resources)
                const indicator = document.getElementById('planeLaunchIndicator');
                if (indicator) {
                    indicator.style.display = this.launched ? 'none' : 'block';
                }
            },

            updateAirplanePhysics() {
                if (!this.launched) return;

                const gravity = 0.21;
                this.airplane.velocityY += gravity;

                // Calculate lift based on velocity
                const totalVelocity = Math.sqrt(
                    this.airplane.velocityX * this.airplane.velocityX +
                    this.airplane.velocityY * this.airplane.velocityY
                );

                const angleOfAttack = Math.atan2(-this.airplane.velocityY, this.airplane.velocityX);
                const liftCoefficient = 0.030;
                const lift = totalVelocity * liftCoefficient * Math.cos(angleOfAttack) + 0.03;

                this.airplane.velocityY -= lift;

                // Air resistance
                this.airplane.velocityX *= 0.997;
                this.airplane.velocityY *= 0.985;

                // High altitude penalty - thin air above canvas
                if (this.airplane.y < 0) {
                    const penaltyDepth = Math.min(100, Math.abs(this.airplane.y));
                    const penaltyFactor = penaltyDepth / 100; // 0 to 1

                    // Extra gravity (thin air = less lift)
                    this.airplane.velocityY += 0.3 * penaltyFactor;

                    // Reduced horizontal momentum (turbulence)
                    this.airplane.velocityX *= (1 - 0.02 * penaltyFactor);
                }

                // Clamp velocities
                this.airplane.velocityX = Math.min(12, Math.max(-2, this.airplane.velocityX));
                this.airplane.velocityY = Math.min(10, Math.max(-10, this.airplane.velocityY));

                // Update position
                this.airplane.x += this.airplane.velocityX;
                this.airplane.y += this.airplane.velocityY;

                // Calculate altitude (ground is at y=250)
                this.airplane.altitude = Math.max(0, 250 - this.airplane.y);

                // Ground collision
                if (this.airplane.y >= 250) {
                    this.airplane.y = 250;
                    this.airplane.onGround = true;
                    this.airplane.velocityX *= 0.93; // Ground friction
                    this.airplane.velocityY = 0;
                    this.airplane.altitude = 0;
                } else {
                    this.airplane.onGround = false;
                }

                // Update speed and angle
                this.airplane.speed = totalVelocity;
                this.airplane.angle = Math.atan2(this.airplane.velocityY, this.airplane.velocityX);

                // Update distance
                this.distance = Math.floor(this.airplane.x / 4);

                // Calculate zone boundaries (symmetric around target)
                const zones = this.landingZones;
                const zoneRadius = zones.greenWidth / 2 + zones.orangeWidth + zones.redWidth;
                const zoneStart = this.targetDistance - zoneRadius;
                const zoneEnd = this.targetDistance + zoneRadius;

                // Check for landing within zone area
                if (this.airplane.onGround && this.distance >= zoneStart && this.distance <= zoneEnd) {
                    this.landAtTarget();
                    return;
                }

                // Check for game over (stopped on ground outside zones or out of resources)
                const state = gameManager.gameStates.plane;
                if (this.airplane.onGround && this.airplane.speed < 0.5 && this.launched) {
                    if (state.resources <= 0 || this.distance > zoneEnd) {
                        this.endFlightPhase();
                    }
                }
            },

            landAtTarget() {
                this.flightRunning = false;
                const state = gameManager.gameStates.plane;

                // Determine landing zone and bonus
                const zone = this.getLandingZone();
                const bonus = this.getLandingBonus(zone);

                // Store for display
                state.lastLandingZone = zone;
                state.lastLandingBonus = bonus;

                // Add base distance + bonus to total
                state.totalDistance += this.distance + bonus;

                // Determine landing message
                let landingMessage;
                switch(zone) {
                    case 'trashcan':
                        landingMessage = 'BULLSEYE! +750m';
                        break;
                    case 'green':
                        landingMessage = 'PERFECT LANDING! +500m';
                        break;
                    case 'orange':
                        landingMessage = 'GREAT LANDING! +100m';
                        break;
                    case 'red':
                        landingMessage = 'YOU LANDED!';
                        break;
                    default:
                        landingMessage = 'MISSED THE ZONE';
                }

                // Use shared round complete screen
                setTimeout(() => {
                    showRoundComplete({
                        'Landing': landingMessage,
                        'Distance Flown': Math.round(this.distance) + 'm',
                        'Bonus Distance': bonus > 0 ? '+' + bonus + 'm' : '0m',
                        'Total Distance': Math.floor(state.totalDistance) + 'm'
                    });
                }, 1000);
            },

            endFlightPhase() {
                this.flightRunning = false;
                const state = gameManager.gameStates.plane;
                state.totalDistance += this.distance;

                showGameOver();
            },

            render() {
                if (!this.ctx) return;
                const ctx = this.ctx;

                // Camera follows plane
                const cameraX = Math.max(0, this.airplane.x - this.canvas.width / 3);

                // Clear and draw sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#98FB98');
                gradient.addColorStop(1, '#8B4513');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw clouds (parallax 0.3x - far background)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (const cloud of this.background.clouds) {
                    const cloudX = cloud.x - cameraX * 0.3;
                    if (cloudX > -100 && cloudX < this.canvas.width + 100) {
                        ctx.beginPath();
                        ctx.arc(cloudX, cloud.y, cloud.width / 2, 0, Math.PI * 2);
                        ctx.arc(cloudX + cloud.width / 3, cloud.y - 5, cloud.width / 3, 0, Math.PI * 2);
                        ctx.arc(cloudX - cloud.width / 4, cloud.y, cloud.width / 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw mountains (parallax 0.3x - far background)
                for (const mountain of this.background.mountains) {
                    const mountainX = mountain.x - cameraX * 0.3;
                    if (mountainX > -mountain.width && mountainX < this.canvas.width + mountain.width) {
                        this.drawMountain(ctx, mountainX, mountain.width, mountain.height, mountain.color);
                    }
                }

                // Draw mesas (parallax 0.4x - mid background)
                for (const mesa of this.background.mesas) {
                    const mesaX = mesa.x - cameraX * 0.4;
                    if (mesaX > -mesa.width && mesaX < this.canvas.width + mesa.width) {
                        this.drawMesa(ctx, mesaX, mesa.width, mesa.height, mesa.color);
                    }
                }

                // Draw hills (parallax 0.5x - mid background)
                for (const hill of this.background.hills) {
                    const hillX = hill.x - cameraX * 0.5;
                    if (hillX > -hill.width && hillX < this.canvas.width + hill.width) {
                        this.drawHill(ctx, hillX, hill.width, hill.height, hill.color);
                    }
                }

                // Draw pine trees (parallax 0.6x - near background)
                for (const pine of this.background.pines) {
                    const pineX = pine.x - cameraX * 0.6;
                    if (pineX > -50 && pineX < this.canvas.width + 50) {
                        this.drawPineTree(ctx, pineX, pine.height);
                    }
                }

                // Draw deciduous trees (parallax 0.7x - near background)
                for (const tree of this.background.trees) {
                    const treeX = tree.x - cameraX * 0.7;
                    if (treeX > -50 && treeX < this.canvas.width + 50) {
                        // Trunk
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(treeX - 5, 250 - tree.height, 10, tree.height);
                        // Leaves
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.arc(treeX, 250 - tree.height - 15, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw cacti (parallax 0.7x - near background)
                for (const cactus of this.background.cacti) {
                    const cactusX = cactus.x - cameraX * 0.7;
                    if (cactusX > -50 && cactusX < this.canvas.width + 50) {
                        this.drawCactus(ctx, cactusX, cactus.height);
                    }
                }

                // Draw ground
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 250, this.canvas.width, 50);
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(0, 250, this.canvas.width, 5);

                // Draw target and landing zones
                const targetX = this.targetDistance * 4 - cameraX;
                // Calculate total zone half-width for proper culling
                const zones = this.landingZones;
                const zoneHalfWidth = (zones.greenWidth / 2 + zones.orangeWidth + zones.redWidth) * 4;
                // Show zones if any part is visible on screen
                if (targetX + zoneHalfWidth > 0 && targetX - zoneHalfWidth < this.canvas.width) {
                    this.drawTarget(ctx, targetX, 235);
                }

                // Draw airplane
                this.drawAirplane(ctx, this.airplane.x - cameraX, this.airplane.y);

                // Draw wind effect at high speed
                if (this.airplane.speed > 7 && this.launched) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        const startX = this.airplane.x - cameraX - 20 - i * 10;
                        const startY = this.airplane.y + (Math.random() - 0.5) * 10;
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(startX - 15, startY);
                        ctx.stroke();
                    }
                }

                // Draw altitude warning when too high
                if (this.airplane.y < 30 && this.launched) {
                    const warningIntensity = Math.min(1, (30 - this.airplane.y) / 30);

                    // Red border overlay
                    ctx.strokeStyle = `rgba(231, 76, 60, ${0.3 + warningIntensity * 0.5})`;
                    ctx.lineWidth = 4 + warningIntensity * 4;
                    ctx.strokeRect(2, 2, this.canvas.width - 4, this.canvas.height - 4);

                    // Warning text
                    if (this.airplane.y < 0) {
                        ctx.fillStyle = `rgba(231, 76, 60, ${0.7 + Math.sin(Date.now() / 100) * 0.3})`;
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('TOO HIGH!', this.canvas.width / 2, 40);
                    }
                }
            },

            getLandingZone() {
                const zones = this.landingZones;
                // Distance from target center (can be negative or positive)
                const distFromCenter = Math.abs(this.distance - this.targetDistance);

                // Check zones from center outward (symmetric layout)
                const halfTrashcan = zones.trashcanWidth / 2;
                const halfGreen = zones.greenWidth / 2;
                const orangeEdge = halfGreen + zones.orangeWidth;
                const redEdge = orangeEdge + zones.redWidth;

                if (distFromCenter <= halfTrashcan) {
                    return 'trashcan';  // Bullseye!
                } else if (distFromCenter <= halfGreen) {
                    return 'green';
                } else if (distFromCenter <= orangeEdge) {
                    return 'orange';
                } else if (distFromCenter <= redEdge) {
                    return 'red';
                } else {
                    return 'miss';  // Outside all zones
                }
            },

            getLandingBonus(zone) {
                const zones = this.landingZones;
                switch(zone) {
                    case 'trashcan': return zones.greenBonus + zones.trashcanBonus;
                    case 'green': return zones.greenBonus;
                    case 'orange': return zones.orangeBonus;
                    case 'red': return zones.redBonus;
                    default: return 0;  // Miss - no bonus
                }
            },

            drawTarget(ctx, x, y) {
                const zones = this.landingZones;
                const zoneHeight = 15;
                const groundY = 250;
                const pixelScale = 4; // distance units to pixels

                // Calculate zone boundaries (symmetric around target center x)
                const halfGreen = (zones.greenWidth / 2) * pixelScale;
                const orangeWidth = zones.orangeWidth * pixelScale;
                const redWidth = zones.redWidth * pixelScale;

                // Calculate fade-in opacity based on distance to target
                const distanceToTarget = this.targetDistance - this.distance;
                const fadeStartDistance = 200; // Start fading in at 200 units away
                const opacity = Math.min(1, Math.max(0, 1 - (distanceToTarget / fadeStartDistance)));

                if (opacity <= 0) return; // Don't draw if too far away

                // Draw zones from left to right: RED - ORANGE - GREEN - ORANGE - RED
                // Left red zone
                ctx.fillStyle = `rgba(231, 76, 60, ${0.7 * opacity})`;
                ctx.fillRect(x - halfGreen - orangeWidth - redWidth, groundY - zoneHeight, redWidth, zoneHeight);

                // Left orange zone
                ctx.fillStyle = `rgba(243, 156, 18, ${0.7 * opacity})`;
                ctx.fillRect(x - halfGreen - orangeWidth, groundY - zoneHeight, orangeWidth, zoneHeight);

                // Center green zone
                ctx.fillStyle = `rgba(46, 204, 113, ${0.8 * opacity})`;
                ctx.fillRect(x - halfGreen, groundY - zoneHeight, halfGreen * 2, zoneHeight);

                // Right orange zone
                ctx.fillStyle = `rgba(243, 156, 18, ${0.7 * opacity})`;
                ctx.fillRect(x + halfGreen, groundY - zoneHeight, orangeWidth, zoneHeight);

                // Right red zone
                ctx.fillStyle = `rgba(231, 76, 60, ${0.7 * opacity})`;
                ctx.fillRect(x + halfGreen + orangeWidth, groundY - zoneHeight, redWidth, zoneHeight);

                // Draw trashcan in center of green zone
                this.drawTrashcan(ctx, x, groundY - zoneHeight, opacity);
            },

            drawTrashcan(ctx, x, y, opacity) {
                // Trashcan body
                ctx.fillStyle = `rgba(39, 174, 96, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y + 2, 18, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = `rgba(46, 204, 113, ${opacity})`;
                ctx.fillRect(x - 12, y - 18, 24, 20);

                // Lid
                ctx.fillStyle = `rgba(39, 174, 96, ${opacity})`;
                ctx.fillRect(x - 14, y - 22, 28, 6);

                // Label
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GOAL', x, y - 6);
            },

            drawAirplane(ctx, x, y) {
                const state = gameManager.gameStates.plane;
                const color = state.airplaneType === 'red' ? '#e74c3c' : '#3498db';

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.airplane.angle);

                // Paper airplane shape
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(20, 0);      // Nose
                ctx.lineTo(-15, -10);   // Top wing
                ctx.lineTo(-10, 0);     // Body notch
                ctx.lineTo(-15, 10);    // Bottom wing
                ctx.closePath();
                ctx.fill();

                // Center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, 0);
                ctx.stroke();

                ctx.restore();
            },

            // Draw a rolling hill
            drawHill(ctx, x, width, height, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x - width / 2, 250);
                ctx.quadraticCurveTo(x, 250 - height, x + width / 2, 250);
                ctx.fill();
            },

            // Draw a mountain with snow cap
            drawMountain(ctx, x, width, height, color) {
                const groundY = 250;

                // Mountain body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x - width / 2, groundY);
                ctx.lineTo(x, groundY - height);
                ctx.lineTo(x + width / 2, groundY);
                ctx.closePath();
                ctx.fill();

                // Snow cap (top 25%)
                const snowHeight = height * 0.25;
                const snowWidth = width * 0.3;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.moveTo(x - snowWidth / 2, groundY - height + snowHeight);
                ctx.lineTo(x, groundY - height);
                ctx.lineTo(x + snowWidth / 2, groundY - height + snowHeight);
                ctx.closePath();
                ctx.fill();
            },

            // Draw a pine tree (triangular)
            drawPineTree(ctx, x, height) {
                const groundY = 250;

                // Trunk
                ctx.fillStyle = '#654321';
                ctx.fillRect(x - 4, groundY - height * 0.3, 8, height * 0.3);

                // Triangular foliage (3 layers)
                ctx.fillStyle = '#1a5c1a';
                const layerCount = 3;
                for (let i = 0; i < layerCount; i++) {
                    const layerY = groundY - height * 0.3 - (i * height * 0.25);
                    const layerWidth = 25 - (i * 5);
                    ctx.beginPath();
                    ctx.moveTo(x - layerWidth, layerY);
                    ctx.lineTo(x, layerY - height * 0.3);
                    ctx.lineTo(x + layerWidth, layerY);
                    ctx.closePath();
                    ctx.fill();
                }
            },

            // Draw a mesa (flat-topped rock formation)
            drawMesa(ctx, x, width, height, color) {
                const groundY = 250;

                // Mesa body with slightly angled sides
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x - width / 2 - 20, groundY);
                ctx.lineTo(x - width / 2, groundY - height);
                ctx.lineTo(x + width / 2, groundY - height);
                ctx.lineTo(x + width / 2 + 20, groundY);
                ctx.closePath();
                ctx.fill();

                // Darker top edge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(x - width / 2, groundY - height, width, 5);

                // Horizontal stripes for layering effect
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 1; i < 4; i++) {
                    const stripeY = groundY - height + (i * height / 4);
                    ctx.beginPath();
                    ctx.moveTo(x - width / 2 - 10 + (i * 5), stripeY);
                    ctx.lineTo(x + width / 2 + 10 - (i * 5), stripeY);
                    ctx.stroke();
                }
            },

            // Draw a cactus
            drawCactus(ctx, x, height) {
                const groundY = 250;

                // Main trunk
                ctx.fillStyle = '#228B22';
                ctx.fillRect(x - 6, groundY - height, 12, height);

                // Rounded top
                ctx.beginPath();
                ctx.arc(x, groundY - height, 6, 0, Math.PI, true);
                ctx.fill();

                // Left arm
                if (height > 25) {
                    const armY = groundY - height * 0.6;
                    ctx.fillRect(x - 18, armY, 12, 6);
                    ctx.fillRect(x - 18, armY - height * 0.25, 6, height * 0.25 + 6);
                    ctx.beginPath();
                    ctx.arc(x - 15, armY - height * 0.25, 3, 0, Math.PI, true);
                    ctx.fill();
                }

                // Right arm
                if (height > 30) {
                    const armY = groundY - height * 0.45;
                    ctx.fillRect(x + 6, armY, 12, 6);
                    ctx.fillRect(x + 12, armY - height * 0.2, 6, height * 0.2 + 6);
                    ctx.beginPath();
                    ctx.arc(x + 15, armY - height * 0.2, 3, 0, Math.PI, true);
                    ctx.fill();
                }
            },

            gameLoop() {
                if (!this.flightRunning) return;

                this.updateAirplanePhysics();
                this.updateFlightDisplay();
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            },

            handleFlightKeyPress(e) {
                if (!this.flightRunning) return;

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        this.useWind();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        this.airBrake();
                        break;
                }
            }
        };

        // === CASTLE GAME MODULE ===
        const castleGame = {
            canvas: null,
            ctx: null,
            cannon: {
                x: 120,
                y: 300,
                angle: 45,
                power: 50,
                minAngle: 0,
                maxAngle: 90,
                minPower: 10,
                maxPower: 100
            },
            projectiles: [],
            targets: [],
            particles: [],
            waterWaves: [],
            background: { clouds: [] },
            gameRunning: false,
            mathTimer: 60,
            mathInterval: null,
            roundTargetsDestroyed: 0,

            init() {
                this.canvas = document.getElementById('castleGameCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                }

                // Initialize clouds
                this.background.clouds = [];
                for (let i = 0; i < 5; i++) {
                    this.background.clouds.push({
                        x: Math.random() * 1000 - 200,
                        y: 30 + Math.random() * 80,
                        width: 60 + Math.random() * 40,
                        height: 30 + Math.random() * 20,
                        speed: 0.2 + Math.random() * 0.4
                    });
                }

                // Initialize water waves
                this.waterWaves = [];
                for (let i = 0; i < 8; i++) {
                    this.waterWaves.push({
                        x: 200 + i * 80,
                        phase: Math.random() * Math.PI * 2,
                        amplitude: 2 + Math.random() * 2,
                        speed: 0.03 + Math.random() * 0.02
                    });
                }
            },

            showCannonPhase() {
                const state = gameManager.gameStates.castle;
                state.phase = 'cannon';

                // Show cannon phase (container switching is handled by shared system)
                document.getElementById('castleCannonPhase').classList.remove('hidden');

                // Show countdown
                const cannonPhase = document.getElementById('castleCannonPhase');
                const countdownDiv = document.createElement('div');
                countdownDiv.style.cssText = `
                    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    font-size: 3em; font-weight: bold; color: #e74c3c;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3); z-index: 100;
                `;
                countdownDiv.textContent = 'DEFEND! üè∞';
                cannonPhase.appendChild(countdownDiv);

                setTimeout(() => {
                    countdownDiv.textContent = 'Ready...';
                    setTimeout(() => {
                        countdownDiv.textContent = 'FIRE!';
                        setTimeout(() => {
                            countdownDiv.remove();
                            this.startCannon();
                        }, 500);
                    }, 600);
                }, 800);
            },

            startCannon() {
                this.gameRunning = true;
                const state = gameManager.gameStates.castle;

                // Reset for new round
                this.projectiles = [];
                this.particles = [];
                this.walls = [];
                this.roundTargetsDestroyed = 0;
                this.cannon.angle = 45;
                this.cannon.power = 50;

                // Generate targets based on round
                const numTargets = Math.min(state.round + 2, 8);
                this.generateTargets(numTargets);

                // Generate walls for round 7+
                if (state.round >= 7) {
                    this.generateWalls(state.round);
                }

                document.getElementById('castleCannonRound').textContent = state.round;
                this.updateCannonControls();
                this.gameLoop();
            },

            generateTargets(numTargets) {
                this.targets = [];
                const state = gameManager.gameStates.castle;
                const round = state.round;
                const minX = 350, maxX = 750;
                const minY = 80, maxY = 260;

                // Determine if targets should move (round 4+)
                const hasMovement = round >= 4;

                for (let i = 0; i < numTargets; i++) {
                    let x, y, validPosition = false, attempts = 0;

                    while (!validPosition && attempts < 100) {
                        x = minX + Math.random() * (maxX - minX);
                        y = minY + Math.random() * (maxY - minY);
                        validPosition = true;

                        for (const target of this.targets) {
                            const dist = Math.sqrt((x - target.x) ** 2 + (y - target.y) ** 2);
                            if (dist < 70) { validPosition = false; break; }
                        }
                        attempts++;
                    }

                    // Movement properties based on round
                    let moveType = 'static';
                    let moveSpeed = 0;
                    let moveRange = 0;

                    if (hasMovement) {
                        moveType = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                        moveSpeed = 0.5 + (round - 4) * 0.15;  // Gets faster in later rounds
                        moveRange = 30 + (round - 4) * 5;      // Wider range in later rounds
                    }

                    this.targets.push({
                        x, y,
                        baseX: x,
                        baseY: y,
                        radius: 22 + Math.random() * 6,
                        hit: false,
                        bobOffset: Math.random() * Math.PI * 2,
                        moveType,
                        moveSpeed,
                        moveRange,
                        movePhase: Math.random() * Math.PI * 2
                    });
                }
            },

            generateWalls(round) {
                const numWalls = Math.min(round - 6, 3);  // 1 wall at round 7, max 3

                for (let i = 0; i < numWalls; i++) {
                    // Position walls between cannon and targets
                    const x = 250 + i * 80;  // Stagger horizontally
                    const y = 100 + Math.random() * 150;
                    const width = 15;
                    const height = 60 + Math.random() * 40;

                    this.walls.push({ x, y, width, height });
                }
            },

            adjustAngle(delta) {
                this.cannon.angle = Math.max(0, Math.min(90, this.cannon.angle + delta));
                this.updateCannonControls();
            },

            adjustPower(delta) {
                this.cannon.power = Math.max(10, Math.min(100, this.cannon.power + delta));
                this.updateCannonControls();
            },

            fireCannon() {
                const state = gameManager.gameStates.castle;
                if (state.resources <= 0) {
                    sounds.playIncorrect();
                    return;
                }

                state.resources--;
                updateScore('castle');
                sounds.playButtonClick();

                const angleRad = (this.cannon.angle * Math.PI) / 180;
                const velocity = (this.cannon.power / 100) * 16;
                const barrelLength = 45;

                this.projectiles.push({
                    x: this.cannon.x + Math.cos(angleRad) * barrelLength,
                    y: this.cannon.y - Math.sin(angleRad) * barrelLength,
                    vx: Math.cos(angleRad) * velocity,
                    vy: -Math.sin(angleRad) * velocity,
                    radius: 8,
                    gravity: 0.22,
                    trail: []
                });

                // Cannon recoil particles
                for (let i = 0; i < 6; i++) {
                    this.particles.push({
                        x: this.cannon.x + Math.cos(angleRad) * 30,
                        y: this.cannon.y - Math.sin(angleRad) * 30,
                        vx: -Math.cos(angleRad) * (2 + Math.random() * 3),
                        vy: -Math.sin(angleRad) * (2 + Math.random() * 3) + (Math.random() - 0.5) * 2,
                        life: 15 + Math.random() * 10,
                        color: '#f39c12'
                    });
                }

                this.updateCannonDisplay();
            },

            updateCannonControls() {
                const state = gameManager.gameStates.castle;
                const angleEl = document.getElementById('castleAngleDisplay');
                const powerEl = document.getElementById('castlePowerDisplay');
                const cannonEl = document.getElementById('castleCannonCount');
                const targetsEl = document.getElementById('castleTargetsDisplay');
                const angleNeedle = document.getElementById('castleAngleNeedle');
                const powerNeedle = document.getElementById('castlePowerNeedle');

                if (angleEl) angleEl.textContent = `${Math.round(this.cannon.angle)}¬∞`;
                if (powerEl) powerEl.textContent = `${this.cannon.power}%`;
                if (cannonEl) cannonEl.textContent = state.resources;
                if (targetsEl) targetsEl.textContent = this.targets.filter(t => !t.hit).length;

                // Update angle needle (0¬∞ = horizontal right, 90¬∞ = vertical up)
                // Needle rotation: 0¬∞ angle = +90deg (right), 90¬∞ angle = 0deg (up)
                if (angleNeedle) {
                    const angleRotation = 90 - this.cannon.angle;
                    angleNeedle.style.transform = `translateX(-50%) rotate(${angleRotation}deg)`;
                }

                // Update power needle (10-100% maps to -90deg to +90deg)
                // 10% = -90deg (left), 55% = 0deg (center), 100% = +90deg (right)
                if (powerNeedle) {
                    const powerRotation = ((this.cannon.power - 10) / 90) * 180 - 90;
                    powerNeedle.style.transform = `translateX(-50%) rotate(${powerRotation}deg)`;
                }
            },

            addCannonPoint() {
                this.updateCannonDisplay(true);
            },

            updateCannonDisplay(animate = false) {
                const state = gameManager.gameStates.castle;
                const pointsEl = document.getElementById('castleCannonPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('castleCannonDisplay', state.resources, 'cannon-point', animate);
            },

            handleCannonKeyPress(e) {
                if (!this.gameRunning) return;
                switch(e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        e.preventDefault(); this.adjustAngle(3); break;
                    case 'ArrowDown': case 's': case 'S':
                        e.preventDefault(); this.adjustAngle(-3); break;
                    case 'ArrowLeft': case 'a': case 'A':
                        e.preventDefault(); this.adjustPower(-5); break;
                    case 'ArrowRight': case 'd': case 'D':
                        e.preventDefault(); this.adjustPower(5); break;
                    case ' ': case 'Enter':
                        e.preventDefault(); this.fireCannon(); break;
                }
            },

            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];

                    proj.trail.push({ x: proj.x, y: proj.y });
                    if (proj.trail.length > 10) proj.trail.shift();

                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    proj.vy += proj.gravity;

                    // Check wall collisions (before targets)
                    let hitWall = false;
                    for (const wall of this.walls) {
                        if (proj.x > wall.x && proj.x < wall.x + wall.width &&
                            proj.y > wall.y && proj.y < wall.y + wall.height) {
                            // Hit wall - create brick particles, remove projectile
                            this.createBrickParticles(proj.x, proj.y);
                            sounds.playButtonClick();
                            this.projectiles.splice(i, 1);
                            hitWall = true;
                            break;
                        }
                    }
                    if (hitWall) continue;

                    // Check target collisions
                    for (const target of this.targets) {
                        if (!target.hit) {
                            const dist = Math.sqrt((proj.x - target.x) ** 2 + (proj.y - target.y) ** 2);
                            if (dist < proj.radius + target.radius) {
                                target.hit = true;
                                this.roundTargetsDestroyed++;
                                sounds.playCorrect();

                                // Explosion particles
                                for (let k = 0; k < 15; k++) {
                                    const angle = (k / 15) * Math.PI * 2;
                                    const speed = 3 + Math.random() * 5;
                                    this.particles.push({
                                        x: target.x, y: target.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        life: 25 + Math.random() * 15,
                                        color: ['#e74c3c', '#f39c12', '#ecf0f1'][Math.floor(Math.random() * 3)]
                                    });
                                }
                                this.projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }

                    // Water splash
                    if (proj.y > 315 && proj.x > 180) {
                        for (let k = 0; k < 8; k++) {
                            this.particles.push({
                                x: proj.x, y: 315,
                                vx: (Math.random() - 0.5) * 6,
                                vy: -Math.random() * 5 - 2,
                                life: 20,
                                color: '#3498db'
                            });
                        }
                        this.projectiles.splice(i, 1);
                        continue;
                    }

                    // Remove if out of bounds
                    if (proj.x > 850 || proj.y > 420 || proj.x < -50) {
                        this.projectiles.splice(i, 1);
                    }
                }
            },

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.25;
                    p.life--;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            },

            createBrickParticles(x, y) {
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        life: 20 + Math.random() * 10,
                        color: ['#a0522d', '#8b4513', '#d2b48c'][Math.floor(Math.random() * 3)]
                    });
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.updateProjectiles();
                this.updateParticles();
                this.updateCannonControls();
                this.render();

                const remaining = this.targets.filter(t => !t.hit).length;
                const state = gameManager.gameStates.castle;

                if (remaining === 0) {
                    this.endRound(true);
                    return;
                }

                if (state.resources <= 0 && this.projectiles.length === 0) {
                    setTimeout(() => this.endRound(false), 500);
                    return;
                }

                requestAnimationFrame(() => this.gameLoop());
            },

            endRound(success) {
                this.gameRunning = false;
                const state = gameManager.gameStates.castle;
                state.totalTargetsDestroyed += this.roundTargetsDestroyed;

                if (success) {
                    // Add bonus resources for next round
                    state.resources += 5;

                    // Use shared round complete screen
                    showRoundComplete({
                        'Targets Destroyed': this.roundTargetsDestroyed,
                        'Bonus Cannonballs': '+5'
                    });
                } else {
                    showGameOver();
                }
            },

            render() {
                if (!this.ctx) return;
                const ctx = this.ctx;
                const time = Date.now() * 0.001;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.6, '#b8e6f7');
                gradient.addColorStop(0.75, '#98FB98');
                gradient.addColorStop(1, '#3498db');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                for (const cloud of this.background.clouds) {
                    cloud.x += cloud.speed;
                    if (cloud.x > this.canvas.width + cloud.width) cloud.x = -cloud.width;

                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.height/2, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.3, cloud.y - cloud.height * 0.25, cloud.height/2.2, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width * 0.6, cloud.y, cloud.height/2.5, 0, Math.PI * 2);
                    ctx.arc(cloud.x + cloud.width, cloud.y + cloud.height * 0.1, cloud.height/2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Water with waves
                ctx.fillStyle = '#2980b9';
                ctx.beginPath();
                ctx.moveTo(180, 320);
                for (const wave of this.waterWaves) {
                    wave.phase += wave.speed;
                    const waveY = 320 + Math.sin(wave.phase) * wave.amplitude;
                    ctx.lineTo(wave.x, waveY);
                }
                ctx.lineTo(this.canvas.width, 320);
                ctx.lineTo(this.canvas.width, this.canvas.height);
                ctx.lineTo(180, this.canvas.height);
                ctx.closePath();
                ctx.fill();

                // Water highlights
                ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                for (let i = 0; i < 5; i++) {
                    const wx = 220 + i * 120 + Math.sin(time + i) * 10;
                    const wy = 335 + Math.sin(time * 1.5 + i) * 3;
                    ctx.beginPath();
                    ctx.ellipse(wx, wy, 30, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Castle
                this.drawCastle(ctx, time);

                // Walls (round 7+)
                for (const wall of this.walls) {
                    this.drawWall(ctx, wall);
                }

                // Targets (with movement and bobbing)
                for (const target of this.targets) {
                    if (!target.hit) {
                        let drawX = target.baseX;
                        let drawY = target.baseY;

                        // Apply movement based on type
                        if (target.moveType === 'horizontal') {
                            drawX = target.baseX + Math.sin(time * target.moveSpeed + target.movePhase) * target.moveRange;
                            target.x = drawX;  // Update for collision detection
                        } else if (target.moveType === 'vertical') {
                            drawY = target.baseY + Math.sin(time * target.moveSpeed + target.movePhase) * target.moveRange;
                            target.y = drawY;  // Update for collision detection
                        }

                        // Add subtle bob on top of movement
                        drawY += Math.sin(time * 2 + target.bobOffset) * 3;

                        this.drawTarget(ctx, drawX, drawY, target.radius);
                    }
                }

                // Projectiles with trails
                for (const proj of this.projectiles) {
                    // Trail
                    if (proj.trail.length > 1) {
                        ctx.strokeStyle = 'rgba(44, 62, 80, 0.4)';
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(proj.trail[0].x, proj.trail[0].y);
                        for (let i = 1; i < proj.trail.length; i++) {
                            ctx.lineTo(proj.trail[i].x, proj.trail[i].y);
                        }
                        ctx.stroke();
                    }

                    // Cannonball
                    ctx.fillStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Shine
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(proj.x - 2, proj.y - 2, proj.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Particles
                for (const p of this.particles) {
                    const alpha = Math.min(1, p.life / 20);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3 + (1 - alpha) * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            },

            drawCastle(ctx, time) {
                const state = gameManager.gameStates.castle;
                const flagColor = state.castleFlagColor === 'blue' ? '#3498db' : '#e74c3c';

                // Island
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(90, 345, 85, 45, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(90, 332, 80, 38, 0, 0, Math.PI * 2);
                ctx.fill();

                // Castle walls
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(25, 275, 130, 65);

                // Towers
                ctx.fillRect(15, 240, 35, 100);
                ctx.fillRect(130, 240, 35, 100);
                ctx.fillRect(65, 225, 50, 115);

                // Tower tops
                ctx.fillStyle = '#34495e';
                const towers = [[32, 240], [147, 240], [90, 225]];
                const widths = [40, 40, 55];
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(towers[i][0] - widths[i]/2, towers[i][1]);
                    ctx.lineTo(towers[i][0], towers[i][1] - 25);
                    ctx.lineTo(towers[i][0] + widths[i]/2, towers[i][1]);
                    ctx.closePath();
                    ctx.fill();
                }

                // Flag on center tower
                const flagWave = Math.sin(time * 3) * 0.15;
                ctx.fillStyle = '#34495e';
                ctx.fillRect(88, 175, 4, 50);

                ctx.fillStyle = flagColor;
                ctx.beginPath();
                ctx.moveTo(92, 180);
                ctx.quadraticCurveTo(115 + flagWave * 20, 188, 125, 195);
                ctx.quadraticCurveTo(115 + flagWave * 15, 202, 92, 210);
                ctx.closePath();
                ctx.fill();

                // Windows
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(28, 260, 10, 15);
                ctx.fillRect(143, 260, 10, 15);
                ctx.fillRect(80, 250, 15, 18);
                ctx.fillRect(40, 295, 12, 15);
                ctx.fillRect(128, 295, 12, 15);

                // Gate
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(75, 305, 30, 35);
                ctx.beginPath();
                ctx.arc(90, 305, 15, 0, Math.PI, true);
                ctx.fill();

                // Cannon
                const angleRad = (this.cannon.angle * Math.PI) / 180;

                // Cannon base
                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.arc(this.cannon.x, this.cannon.y + 5, 15, 0, Math.PI, true);
                ctx.fill();

                // Cannon pivot
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(this.cannon.x, this.cannon.y, 14, 0, Math.PI * 2);
                ctx.fill();

                // Cannon barrel
                ctx.save();
                ctx.translate(this.cannon.x, this.cannon.y);
                ctx.rotate(-angleRad);

                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.moveTo(0, -7);
                ctx.lineTo(45, -5);
                ctx.lineTo(48, -3);
                ctx.lineTo(48, 3);
                ctx.lineTo(45, 5);
                ctx.lineTo(0, 7);
                ctx.closePath();
                ctx.fill();

                // Barrel details
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(10, -5, 4, 10);
                ctx.fillRect(25, -5, 4, 10);

                ctx.restore();
            },

            drawTarget(ctx, x, y, radius) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(x + 3, y + 3, radius, radius * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // White ring
                ctx.fillStyle = '#ecf0f1';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
                ctx.fill();

                // Red center
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Bullseye
                ctx.fillStyle = '#ecf0f1';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
                ctx.fill();
            },

            drawWall(ctx, wall) {
                // Brick pattern
                const brickHeight = 12;
                const brickWidth = wall.width;
                const rows = Math.floor(wall.height / brickHeight);

                for (let row = 0; row < rows; row++) {
                    const y = wall.y + row * brickHeight;

                    // Alternate brick colors
                    ctx.fillStyle = row % 2 === 0 ? '#a0522d' : '#8b4513';
                    ctx.fillRect(wall.x, y, brickWidth, brickHeight - 1);

                    // Mortar lines
                    ctx.fillStyle = '#d2b48c';
                    ctx.fillRect(wall.x, y + brickHeight - 1, brickWidth, 1);
                }

                // Border
                ctx.strokeStyle = '#5d3a1a';
                ctx.lineWidth = 2;
                ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
            }
        };

        // === EXPRESS GAME MODULE ===
        // Rebuilt from scratch based on MathExpress20250603.html
        const expressGame = {
            canvas: null,
            ctx: null,

            // Engine (lead train car)
            train: {
                x: 50,
                y: 200,
                velocityX: 0,
                velocityY: 0,
                speed: 0,
                onGround: true,
                width: 60,
                height: 30,
                momentum: 0,
                wasAirborne: false,
                airTime: 0,
                brakingBeforeLanding: false
            },

            // Multiple train cars
            trainCars: [
                { x: 50, y: 200, angle: 0, type: 'engine', wheelRotation: 0 },
                { x: -15, y: 200, angle: 0, type: 'boxcar1', wheelRotation: 0 },
                { x: -80, y: 200, angle: 0, type: 'boxcar2', wheelRotation: 0 },
                { x: -145, y: 200, angle: 0, type: 'caboose', wheelRotation: 0 }
            ],

            // Path history for car following
            pathHistory: [],
            pathHistorySize: 200,

            carPhysics: {
                spacing: 65,
                carLength: 60,
                mass: 1,
                wheelRadius: 8
            },

            // Terrain with gentle hills
            terrain: {
                segments: [],
                segmentWidth: 30,
                lookAhead: 40,
                baseHeight: 250,
                lastX: 0,
                lastHeight: 250,
                hillState: {
                    currentPhase: 0,
                    hillLength: 800,
                    amplitude: 60,
                    nextHillDistance: 800
                },
                constraints: {
                    maxUphillChange: 4,
                    minHeight: 200,
                    maxHeight: 300
                }
            },

            // Parallax background
            background: {
                clouds: [],
                mountains: [],
                trees: []
            },

            // Station system
            currentRoundDistance: 0,
            roundTargetDistance: 0,
            startingSteamPoints: 0,

            gameRunning: false,
            mathTimer: 60,
            mathInterval: null,

            init() {
                this.canvas = document.getElementById('expressGameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.initializeBackground();
                this.initializeTerrain();
            },

            initializeBackground() {
                // Clouds
                this.background.clouds = [];
                for (let i = 0; i < 8; i++) {
                    this.background.clouds.push({
                        x: Math.random() * 1600,
                        y: 20 + Math.random() * 80,
                        width: 60 + Math.random() * 40,
                        height: 30 + Math.random() * 20,
                        speed: 0.2 + Math.random() * 0.3
                    });
                }

                // Mountains
                this.background.mountains = [];
                for (let i = 0; i < 5; i++) {
                    this.background.mountains.push({
                        x: i * 300,
                        width: 200 + Math.random() * 100,
                        height: 80 + Math.random() * 40
                    });
                }

                // Trees
                this.background.trees = [];
                for (let i = 0; i < 20; i++) {
                    this.background.trees.push({
                        x: i * 100 + Math.random() * 50,
                        height: 40 + Math.random() * 30,
                        width: 30 + Math.random() * 20
                    });
                }
            },

            initializeTerrain() {
                this.terrain.segments = [];
                this.terrain.lastX = 0;
                this.terrain.lastHeight = this.terrain.baseHeight;
                this.terrain.hillState.currentPhase = 0;
                this.terrain.hillState.nextHillDistance = 600 + Math.random() * 400;

                for (let i = 0; i < this.terrain.lookAhead; i++) {
                    this.generateNextTerrainSegment();
                }
            },

            generateNextTerrainSegment() {
                const x = this.terrain.lastX + this.terrain.segmentWidth;
                let targetHeight = this.terrain.baseHeight;

                // Check for new hill
                if (x >= this.terrain.hillState.nextHillDistance) {
                    this.terrain.hillState.currentPhase = 0;
                    this.terrain.hillState.amplitude = 40 + Math.random() * 80;
                    this.terrain.hillState.hillLength = 600 + Math.random() * 800;
                    this.terrain.hillState.nextHillDistance = x + this.terrain.hillState.hillLength + 400 + Math.random() * 600;
                }

                // Generate hill curve
                if (x >= this.terrain.hillState.nextHillDistance - this.terrain.hillState.hillLength &&
                    x < this.terrain.hillState.nextHillDistance) {
                    const hillProgress = (x - (this.terrain.hillState.nextHillDistance - this.terrain.hillState.hillLength)) / this.terrain.hillState.hillLength;
                    const hillHeight = Math.cos(hillProgress * Math.PI * 2) * this.terrain.hillState.amplitude;
                    targetHeight = this.terrain.baseHeight - hillHeight;
                }

                // Apply slope constraints
                const heightDifference = targetHeight - this.terrain.lastHeight;
                let actualHeight;

                if (heightDifference > 0) {
                    const maxUphillChange = this.terrain.constraints.maxUphillChange;
                    actualHeight = heightDifference > maxUphillChange ?
                        this.terrain.lastHeight + maxUphillChange : targetHeight;
                } else {
                    actualHeight = targetHeight;
                }

                actualHeight = Math.max(this.terrain.constraints.minHeight,
                              Math.min(this.terrain.constraints.maxHeight, actualHeight));

                this.terrain.segments.push({ x: x, y: actualHeight });
                this.terrain.lastX = x;
                this.terrain.lastHeight = actualHeight;
            },

            showTrainPhase() {
                const state = gameManager.gameStates.express;
                state.phase = 'train';

                // Remove any lingering station arrival overlay from previous round
                const existingArrival = document.getElementById('expressStationArrival');
                if (existingArrival) existingArrival.remove();

                // Calculate target distance for this round
                this.roundTargetDistance = state.round * 200;
                this.currentRoundDistance = 0;

                // Show train phase (container switching is handled by shared system)
                document.getElementById('expressTrainPhase').classList.remove('hidden');

                sounds.playButtonClick();

                // Show countdown
                const trainPhase = document.getElementById('expressTrainPhase');
                const countdownDiv = document.createElement('div');
                countdownDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 3em;
                    font-weight: bold;
                    color: #e74c3c;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                    z-index: 100;
                    pointer-events: none;
                `;
                countdownDiv.textContent = 'ALL ABOARD!';
                trainPhase.appendChild(countdownDiv);

                setTimeout(() => {
                    countdownDiv.textContent = 'Ready...';
                    setTimeout(() => {
                        countdownDiv.textContent = 'GO!';
                        setTimeout(() => {
                            countdownDiv.remove();
                            this.startTrain();
                        }, 500);
                    }, 800);
                }, 1000);
            },

            startTrain() {
                this.gameRunning = true;
                const state = gameManager.gameStates.express;
                this.startingSteamPoints = state.resources;
                this.currentRoundDistance = 0;
                this.distanceAdded = false;

                // Reset train
                this.train.x = 50;
                this.train.y = 200;
                this.train.velocityX = 0;
                this.train.velocityY = 0;
                this.train.speed = 0;
                this.train.momentum = 0;
                this.train.onGround = true;
                this.train.wasAirborne = false;
                this.train.airTime = 0;
                this.train.brakingBeforeLanding = false;

                // Reset terrain
                this.initializeTerrain();

                // Clear path history
                this.pathHistory = [];

                // Reset train cars
                this.trainCars[0] = { x: this.train.x, y: this.train.y, angle: 0, type: 'engine', wheelRotation: 0 };
                for (let i = 1; i < this.trainCars.length; i++) {
                    this.trainCars[i].x = this.train.x - (i * this.carPhysics.spacing);
                    this.trainCars[i].y = this.getTerrainHeightAt(this.trainCars[i].x) - this.train.height;
                    this.trainCars[i].angle = 0;
                    this.trainCars[i].wheelRotation = 0;
                    this.pathHistory.push({ x: this.trainCars[i].x, y: this.trainCars[i].y });
                }

                this.updateDisplays();
                this.gameLoop();
            },

            boost() {
                const state = gameManager.gameStates.express;
                if (state.resources > 0 && this.gameRunning) {
                    state.resources--;
                    updateScore('express');

                    if (Math.abs(this.train.velocityX) < 0.1) {
                        this.train.velocityX = 1.5;
                    }

                    // Strategic boost bonus - check for incline ahead
                    let boostMultiplier = 1.0;
                    const lookAheadDistance = 100;
                    const currentHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2);
                    const aheadHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2 + lookAheadDistance);

                    if (aheadHeight < currentHeight - 10) {
                        boostMultiplier = 1.5;
                    }

                    const baseBoostPower = 3.5;
                    this.train.momentum += baseBoostPower * boostMultiplier;

                    const maxMomentum = 4.5;
                    if (this.train.momentum > maxMomentum) {
                        this.train.momentum = maxMomentum;
                    }

                    sounds.playButtonClick();
                    this.updateDisplays();
                }
            },

            brake() {
                if (this.gameRunning) {
                    // Strategic braking check
                    if (!this.train.onGround && this.train.velocityY > 0 && Math.abs(this.train.velocityX) > 9) {
                        const futureY = this.train.y + this.train.velocityY * 10;
                        const terrainHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2);

                        if (futureY + this.train.height >= terrainHeight - 20) {
                            this.train.brakingBeforeLanding = true;
                        }
                    }

                    if (!this.train.onGround) {
                        this.train.velocityY += 2.5;
                        if (!this.train.brakingBeforeLanding) {
                            this.train.velocityX *= 0.98;
                        }
                    } else {
                        this.train.momentum *= 0.4;
                        this.train.velocityX *= 0.85;
                    }
                    sounds.playButtonClick();
                }
            },

            updateTrainPhysics() {
                const state = gameManager.gameStates.express;
                const totalMass = 1 + (this.trainCars.length - 1) * 0.3;

                // Apply momentum
                if (Math.abs(this.train.momentum) > 0) {
                    this.train.velocityX += (this.train.momentum / totalMass) * 0.2;

                    const maxVelocity = this.train.brakingBeforeLanding ? 13 : 11;
                    if (Math.abs(this.train.velocityX) > maxVelocity) {
                        this.train.velocityX = Math.sign(this.train.velocityX) * maxVelocity;
                    }

                    const distanceFactor = Math.min(state.totalDistance / 5000, 0.5);
                    this.train.momentum *= (0.96 - distanceFactor * 0.02);

                    if (Math.abs(this.train.momentum) < 0.01) {
                        this.train.momentum = 0;
                    }
                }

                // Update position
                this.train.x += this.train.velocityX;
                this.train.y += this.train.velocityY;

                // Get terrain info
                const terrainHeight = this.getTerrainHeightAt(this.train.x + this.train.width/2);
                const terrainSlope = this.getTerrainSlopeAt(this.train.x + this.train.width/2);

                // Ground collision
                if (this.train.y + this.train.height >= terrainHeight) {
                    this.train.y = terrainHeight - this.train.height;

                    if (!this.train.onGround && this.train.wasAirborne) {
                        this.train.momentum += 0.3;
                        this.train.wasAirborne = false;
                    }

                    this.train.onGround = true;

                    // Moon-like launch on hill crests
                    if (Math.abs(this.train.velocityX) > 3 && terrainSlope > 1.0) {
                        const launchPower = Math.min(this.train.velocityX * 0.6, 7);
                        this.train.velocityY = -launchPower;
                        this.train.onGround = false;
                        this.train.wasAirborne = true;
                        this.train.brakingBeforeLanding = false;
                        this.train.momentum += 0.3;
                    } else {
                        this.train.velocityY = 0;

                        if (Math.abs(this.train.velocityX) > 0.5) {
                            const slopeEffect = terrainSlope * 0.15 / totalMass;

                            if (terrainSlope > 0) {
                                this.train.momentum += slopeEffect * 0.1;
                                if (this.train.momentum > 4.5) this.train.momentum = 4.5;
                            } else {
                                const distanceFactor = Math.min(state.totalDistance / 5000, 0.5);
                                this.train.velocityX += slopeEffect * (3 + distanceFactor * 2);
                                this.train.velocityX *= (0.99 - distanceFactor * 0.01);
                                this.train.momentum *= (0.94 - distanceFactor * 0.02);
                            }
                        }
                    }
                } else {
                    this.train.onGround = false;
                    this.train.wasAirborne = true;
                    this.train.airTime++;
                    // Moon-like gravity
                    this.train.velocityY += 0.16;
                }

                // Friction
                if (Math.abs(this.train.velocityX) > 0.1) {
                    const distanceFactor = Math.min(state.totalDistance / 5000, 0.5);
                    const baseFriction = this.train.onGround ?
                        (0.997 - distanceFactor * 0.005) :
                        (1.0 - distanceFactor * 0.004);
                    const massFriction = 1 - ((1 - baseFriction) / totalMass);
                    this.train.velocityX *= massFriction;
                } else if (Math.abs(this.train.momentum) <= 0.1) {
                    this.train.velocityX = 0;
                }

                // Velocity cap
                const maxVelocity = this.train.brakingBeforeLanding ? 13 : 11;
                if (Math.abs(this.train.velocityX) > maxVelocity) {
                    this.train.velocityX = Math.sign(this.train.velocityX) * maxVelocity;
                }

                if (Math.abs(this.train.velocityX) < 0.3 && Math.abs(this.train.momentum) < 0.1) {
                    this.train.velocityX = 0;
                    this.train.momentum = 0;
                }

                this.train.speed = Math.abs(this.train.velocityX);

                // Update wheel rotations
                const wheelCircumference = 2 * Math.PI * this.carPhysics.wheelRadius;
                const rotationDelta = (this.train.velocityX / wheelCircumference) * Math.PI * 2;

                // Update engine car
                this.trainCars[0].x = this.train.x;
                this.trainCars[0].y = this.train.y;
                this.trainCars[0].angle = Math.atan(this.getTerrainSlopeAt(this.train.x + this.train.width/2)) * 0.5;
                this.trainCars[0].wheelRotation += rotationDelta;

                // Add to path history
                this.pathHistory.push({ x: this.train.x, y: this.train.y });
                if (this.pathHistory.length > this.pathHistorySize) {
                    this.pathHistory.shift();
                }

                // Update other cars to follow
                for (let i = 1; i < this.trainCars.length; i++) {
                    const car = this.trainCars[i];
                    const pathOffset = i * this.carPhysics.spacing;
                    const targetDistance = this.train.x - pathOffset;

                    let foundPosition = false;
                    for (let j = this.pathHistory.length - 1; j >= 0; j--) {
                        const pathPoint = this.pathHistory[j];
                        if (pathPoint.x <= targetDistance) {
                            car.x = pathPoint.x;
                            car.y = pathPoint.y;
                            foundPosition = true;

                            if (j > 0) {
                                const prevPoint = this.pathHistory[j - 1];
                                const dx = pathPoint.x - prevPoint.x;
                                const dy = pathPoint.y - prevPoint.y;
                                car.angle = Math.atan2(dy, dx);
                            }
                            break;
                        }
                    }

                    if (!foundPosition) {
                        const prevCar = this.trainCars[i - 1];
                        car.x = prevCar.x - this.carPhysics.spacing;
                        car.y = prevCar.y;
                        car.angle = prevCar.angle;
                    }

                    car.wheelRotation += rotationDelta;
                }

                // Update distance
                this.currentRoundDistance = Math.floor(this.train.x / 20);

                // Check if reached station
                if (this.currentRoundDistance >= this.roundTargetDistance) {
                    this.arriveAtStation();
                    return;
                }
            },

            getTerrainHeightAt(x) {
                const segmentIndex = Math.floor(x / this.terrain.segmentWidth);

                if (segmentIndex >= this.terrain.segments.length - 1 || segmentIndex < 0) {
                    return this.terrain.baseHeight;
                }

                const segment1 = this.terrain.segments[segmentIndex];
                const segment2 = this.terrain.segments[segmentIndex + 1];

                if (!segment1 || !segment2) return this.terrain.baseHeight;

                const localX = x - segment1.x;
                const t = localX / this.terrain.segmentWidth;

                return segment1.y + (segment2.y - segment1.y) * t;
            },

            getTerrainSlopeAt(x) {
                const h1 = this.getTerrainHeightAt(x - 10);
                const h2 = this.getTerrainHeightAt(x + 10);
                return (h1 - h2) / 20;
            },

            updateTerrain() {
                const trainProgress = this.train.x;
                const neededSegments = Math.floor(trainProgress / this.terrain.segmentWidth) + this.terrain.lookAhead;

                while (this.terrain.segments.length < neededSegments) {
                    this.generateNextTerrainSegment();
                }

                const minSegmentsToKeep = Math.max(0, Math.floor(trainProgress / this.terrain.segmentWidth) - 20);
                if (this.terrain.segments.length > minSegmentsToKeep + this.terrain.lookAhead + 20) {
                    this.terrain.segments.splice(0, this.terrain.segments.length - (this.terrain.lookAhead + 40));
                }
            },

            updateDisplays() {
                const state = gameManager.gameStates.express;

                const steamDisplay = document.getElementById('expressSteamDisplay');
                const distanceDisplay = document.getElementById('expressDistanceDisplay');
                const speedDisplay = document.getElementById('expressSpeedDisplay');
                const roundDisplay = document.getElementById('expressTrainRoundNumber');
                const steamPoints = document.getElementById('expressSteamPoints');
                const toStationDisplay = document.getElementById('expressToStation');
                const totalDistDisplay = document.getElementById('expressTotalDistance');

                if (steamDisplay) steamDisplay.textContent = state.resources;
                if (steamPoints) steamPoints.textContent = state.resources;
                if (distanceDisplay) distanceDisplay.textContent = this.currentRoundDistance;
                // Speed display scaled by 10x for more readable numbers (velocity units to display units)
                if (speedDisplay) speedDisplay.textContent = Math.floor(Math.abs(this.train.velocityX) * 10);
                if (roundDisplay) roundDisplay.textContent = state.round;
                if (toStationDisplay) toStationDisplay.textContent = Math.max(0, this.roundTargetDistance - this.currentRoundDistance);
                if (totalDistDisplay) totalDistDisplay.textContent = state.totalDistance + this.currentRoundDistance;

                // Update speedometer needle
                this.updateSpeedometer();
            },

            updateSpeedometer() {
                const needle = document.getElementById('expressSpeedNeedle');
                if (!needle) return;

                const currentSpeed = Math.abs(this.train.velocityX);

                if (currentSpeed > 10) {
                    needle.classList.add('redline');
                } else {
                    needle.classList.remove('redline');
                    const maxDisplaySpeed = 10;
                    const clampedSpeed = Math.min(currentSpeed, maxDisplaySpeed);
                    const rotation = -90 + (clampedSpeed / maxDisplaySpeed) * 180;
                    needle.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
                }
            },

            addCoalPoint() {
                this.updateCoalDisplay(true);
            },

            updateCoalDisplay(animate = false) {
                const state = gameManager.gameStates.express;
                const pointsEl = document.getElementById('expressSteamPoints');
                if (pointsEl) pointsEl.textContent = state.resources;
                updatePointsDisplay('expressCoalDisplay', state.resources, 'coal-point', animate);
            },

            handleTrainKeyPress(e) {
                if (!this.gameRunning) return;

                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        this.boost();
                        break;
                    case 'Enter':
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        e.preventDefault();
                        this.brake();
                        break;
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.updateTerrain();
                this.updateTrainPhysics();
                this.updateDisplays();
                this.render();

                // Check if train stopped
                const state = gameManager.gameStates.express;
                if (Math.abs(this.train.velocityX) <= 0.1 && Math.abs(this.train.momentum) <= 0.1 &&
                    this.train.onGround && state.resources <= 0) {
                    this.endRound(false);
                    return;
                }

                requestAnimationFrame(() => this.gameLoop());
            },

            arriveAtStation() {
                this.gameRunning = false;
                const state = gameManager.gameStates.express;

                // Only add distance once
                if (!this.distanceAdded) {
                    state.totalDistance += this.currentRoundDistance;
                    this.distanceAdded = true;
                }

                // Show arrival overlay
                const trainPhase = document.getElementById('expressTrainPhase');
                const arrivalDiv = document.createElement('div');
                arrivalDiv.id = 'expressStationArrival';
                arrivalDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255,255,255,0.95);
                    padding: 30px;
                    border-radius: 15px;
                    text-align: center;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                    z-index: 100;
                `;
                arrivalDiv.innerHTML = `
                    <h2 style="color: #27ae60; font-size: 2em; margin: 0;">üöâ Station Reached! üöâ</h2>
                    <p style="font-size: 1.3em; color: #2c3e50; margin: 15px 0;">Round ${state.round} Complete!</p>
                    <p style="font-size: 1em; color: #7f8c8d;">Distance This Round: ${this.currentRoundDistance}</p>
                    <p style="font-size: 1em; color: #7f8c8d;">Total Distance: ${state.totalDistance}</p>
                    <p style="font-size: 1em; color: #7f8c8d;">Steam Remaining: ${state.resources}</p>
                    <button onclick="expressGame.startNextRound()" style="margin-top: 15px; padding: 10px 25px; font-size: 1.1em; background: #27ae60; color: white; border: none; border-radius: 8px; cursor: pointer;">Next Round</button>
                `;
                trainPhase.appendChild(arrivalDiv);

                sounds.playButtonClick();
            },

            endRound(reachedStation) {
                this.gameRunning = false;
                const state = gameManager.gameStates.express;

                // Only add distance once
                if (!this.distanceAdded) {
                    state.totalDistance += this.currentRoundDistance;
                    this.distanceAdded = true;
                }

                setTimeout(() => {
                    if (this.currentRoundDistance > 50) {
                        // Use shared round complete screen
                        showRoundComplete({
                            'Distance Traveled': Math.round(this.currentRoundDistance) + 'm',
                            'Total Distance': state.totalDistance + 'm'
                        });
                    } else {
                        showGameOver();
                    }
                }, 1000);
            },

            startNextRound() {
                sounds.playButtonClick();
                const arrivalDiv = document.getElementById('expressStationArrival');
                if (arrivalDiv) arrivalDiv.remove();

                const state = gameManager.gameStates.express;
                state.round++;

                // Hide express game container, show shared container
                document.getElementById('expressGame').classList.remove('active');
                document.getElementById('expressGame').style.display = 'none';
                document.getElementById('sharedGameContainer').style.display = 'block';
                document.getElementById('sharedGameContainer').classList.add('active');

                startMathPhase();
            },

            render() {
                if (!this.ctx) return;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const cameraX = Math.max(0, this.train.x - this.canvas.width / 3);

                // Draw background
                this.drawBackground(cameraX);

                // Draw station if approaching
                const state = gameManager.gameStates.express;
                const stationX = this.roundTargetDistance * 20;
                if (stationX > 0 && stationX >= cameraX - 100 && stationX <= cameraX + this.canvas.width + 100) {
                    this.drawStation(stationX - cameraX, state.round);
                }

                // Draw terrain
                this.drawTerrain(cameraX);

                // Draw all train cars
                this.drawAllTrainCars(cameraX);

                // Draw speed trail
                if ((!this.train.onGround && Math.abs(this.train.velocityX) > 3) || Math.abs(this.train.velocityX) > 8) {
                    this.drawSpeedTrail(cameraX);
                }
            },

            drawBackground(cameraX) {
                // Sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(0.7, '#98FB98');
                gradient.addColorStop(1, '#8B4513');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Clouds (slow parallax)
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.background.clouds.forEach(cloud => {
                    cloud.x -= cloud.speed;
                    if (cloud.x + cloud.width < 0) cloud.x = 1600;

                    const x = cloud.x - cameraX * 0.1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, cloud.y, cloud.height/2, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width * 0.25, cloud.y - cloud.height * 0.2, cloud.height/2.5, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width * 0.5, cloud.y, cloud.height/2.2, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width * 0.75, cloud.y - cloud.height * 0.1, cloud.height/2.5, 0, Math.PI * 2);
                    this.ctx.arc(x + cloud.width, cloud.y, cloud.height/2, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Mountains (medium parallax)
                this.background.mountains.forEach(mountain => {
                    const x = mountain.x - cameraX * 0.3;

                    this.ctx.fillStyle = '#8B7355';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 200);
                    this.ctx.lineTo(x + mountain.width/2, 200 - mountain.height);
                    this.ctx.lineTo(x + mountain.width, 200);
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Snow cap
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + mountain.width/2 - 20, 200 - mountain.height + 20);
                    this.ctx.lineTo(x + mountain.width/2, 200 - mountain.height);
                    this.ctx.lineTo(x + mountain.width/2 + 20, 200 - mountain.height + 20);
                    this.ctx.closePath();
                    this.ctx.fill();
                });

                // Trees (fast parallax)
                this.background.trees.forEach(tree => {
                    const x = tree.x - cameraX * 0.5;

                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(x, 220 - tree.height, tree.width * 0.3, tree.height);

                    this.ctx.fillStyle = '#228B22';
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - tree.width/2, 220 - tree.height * 0.6);
                    this.ctx.lineTo(x + tree.width * 0.15, 220 - tree.height - 10);
                    this.ctx.lineTo(x + tree.width/2 + tree.width * 0.3, 220 - tree.height * 0.6);
                    this.ctx.closePath();
                    this.ctx.fill();
                });
            },

            drawStation(screenX, round) {
                const stationY = this.getTerrainHeightAt(screenX + this.train.x - this.canvas.width/3);

                // Station building
                this.ctx.fillStyle = '#c0392b';
                this.ctx.fillRect(screenX - 60, stationY - 80, 120, 80);

                // Roof
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.beginPath();
                this.ctx.moveTo(screenX - 70, stationY - 80);
                this.ctx.lineTo(screenX, stationY - 110);
                this.ctx.lineTo(screenX + 70, stationY - 80);
                this.ctx.closePath();
                this.ctx.fill();

                // Windows
                this.ctx.fillStyle = '#f39c12';
                this.ctx.fillRect(screenX - 40, stationY - 60, 20, 20);
                this.ctx.fillRect(screenX - 10, stationY - 60, 20, 20);
                this.ctx.fillRect(screenX + 20, stationY - 60, 20, 20);

                // Door
                this.ctx.fillStyle = '#34495e';
                this.ctx.fillRect(screenX - 15, stationY - 40, 30, 40);

                // Sign
                this.ctx.fillStyle = '#ecf0f1';
                this.ctx.fillRect(screenX - 50, stationY - 100, 100, 20);
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`STATION ${round}`, screenX, stationY - 85);

                // Platform
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.fillRect(screenX - 80, stationY - 5, 160, 5);
            },

            drawTerrain(cameraX) {
                // Brown dirt
                this.ctx.fillStyle = '#8B4513';
                this.ctx.strokeStyle = '#654321';
                this.ctx.lineWidth = 2;

                this.ctx.beginPath();
                this.ctx.moveTo(-cameraX, this.canvas.height);

                const startSegment = Math.max(0, Math.floor(cameraX / this.terrain.segmentWidth) - 2);
                const endSegment = Math.min(this.terrain.segments.length - 1,
                    Math.floor((cameraX + this.canvas.width) / this.terrain.segmentWidth) + 2);

                for (let i = startSegment; i <= endSegment; i++) {
                    if (this.terrain.segments[i]) {
                        const segment = this.terrain.segments[i];
                        if (i === startSegment) {
                            this.ctx.lineTo(segment.x - cameraX, segment.y);
                        } else {
                            const prevSegment = this.terrain.segments[i - 1];
                            const controlX1 = prevSegment.x + this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY1 = prevSegment.y;
                            const controlX2 = segment.x - this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY2 = segment.y;
                            this.ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, segment.x - cameraX, segment.y);
                        }
                    }
                }

                this.ctx.lineTo(this.canvas.width + 100, this.canvas.height);
                this.ctx.lineTo(-cameraX, this.canvas.height);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                // Green grass on top
                this.ctx.fillStyle = '#228B22';
                this.ctx.beginPath();

                for (let i = startSegment; i <= endSegment; i++) {
                    if (this.terrain.segments[i]) {
                        const segment = this.terrain.segments[i];
                        if (i === startSegment) {
                            this.ctx.moveTo(segment.x - cameraX, segment.y - 5);
                        } else {
                            const prevSegment = this.terrain.segments[i - 1];
                            const controlX1 = prevSegment.x + this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY1 = prevSegment.y - 5;
                            const controlX2 = segment.x - this.terrain.segmentWidth * 0.3 - cameraX;
                            const controlY2 = segment.y - 5;
                            this.ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, segment.x - cameraX, segment.y - 5);
                        }
                    }
                }

                for (let i = endSegment; i >= startSegment; i--) {
                    if (this.terrain.segments[i]) {
                        const segment = this.terrain.segments[i];
                        this.ctx.lineTo(segment.x - cameraX, segment.y);
                    }
                }

                this.ctx.closePath();
                this.ctx.fill();
            },

            drawAllTrainCars(cameraX) {
                // Draw cars from back to front
                for (let i = this.trainCars.length - 1; i >= 0; i--) {
                    const car = this.trainCars[i];
                    const carX = car.x - cameraX;
                    const carY = car.y;

                    this.ctx.save();
                    this.ctx.translate(carX + this.train.width/2, carY + this.train.height/2);
                    this.ctx.rotate(car.angle);
                    this.ctx.translate(-(carX + this.train.width/2), -(carY + this.train.height/2));

                    switch(car.type) {
                        case 'engine':
                            this.drawSteamEngine(carX, carY, car.wheelRotation);
                            break;
                        case 'boxcar1':
                            this.drawBoxCar(carX, carY, '#3498db', car.wheelRotation);
                            break;
                        case 'boxcar2':
                            this.drawBoxCar(carX, carY, '#e74c3c', car.wheelRotation);
                            break;
                        case 'caboose':
                            this.drawCaboose(carX, carY, car.wheelRotation);
                            break;
                    }

                    this.ctx.restore();

                    // Draw coupler to next car
                    if (i > 0) {
                        const nextCar = this.trainCars[i - 1];
                        const nextCarX = nextCar.x - cameraX;
                        const nextCarY = nextCar.y;
                        this.drawCoupler(nextCarX - 5, nextCarY + this.train.height - 8,
                                        carX + this.train.width + 5, carY + this.train.height - 8);
                    }
                }

                // Draw smoke
                if (this.train.velocityX > 2) {
                    this.drawSmoke(this.train.x - cameraX, this.train.y);
                }
            },

            drawSteamEngine(x, y, wheelRotation) {
                const state = gameManager.gameStates.express;
                const cabColor = state.trainColor === 'blue' ? '#3498db' : '#e74c3c';

                // Main boiler
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(x + 10, y + 8, 50, 22);

                // Cab (uses selected color)
                this.ctx.fillStyle = cabColor;
                this.ctx.fillRect(x, y, 25, 25);

                // Smokestack
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(x + 44, y, 8, 15);
                this.ctx.fillRect(x + 42, y - 3, 12, 6);

                // Cow catcher
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.beginPath();
                this.ctx.moveTo(x + 60, y + 25);
                this.ctx.lineTo(x + 68, y + 32);
                this.ctx.lineTo(x + 60, y + 32);
                this.ctx.closePath();
                this.ctx.fill();

                // Windows
                this.ctx.fillStyle = '#5dade2';
                this.ctx.fillRect(x + 4, y + 5, 8, 8);
                this.ctx.fillRect(x + 14, y + 5, 8, 8);

                // Details
                this.ctx.fillStyle = '#f39c12';
                this.ctx.fillRect(x + 28, y + 12, 12, 3);
                this.ctx.fillRect(x + 15, y + 20, 30, 2);

                // Wheels
                this.drawWheel(x + 12, y + this.train.height + 5, 8, wheelRotation);
                this.drawWheel(x + 30, y + this.train.height + 5, 8, wheelRotation);
                this.drawWheel(x + 48, y + this.train.height + 5, 8, wheelRotation);
            },

            drawBoxCar(x, y, color, wheelRotation) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x + 5, y + 5, 50, 25);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(x + 3, y + 2, 54, 5);

                this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 30, y + 8);
                this.ctx.lineTo(x + 30, y + 28);
                this.ctx.stroke();

                this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                this.ctx.fillRect(x + 10, y + 12, 8, 8);
                this.ctx.fillRect(x + 42, y + 12, 8, 8);

                this.drawWheel(x + 15, y + this.train.height + 5, 7, wheelRotation);
                this.drawWheel(x + 45, y + this.train.height + 5, 7, wheelRotation);
            },

            drawCaboose(x, y, wheelRotation) {
                this.ctx.fillStyle = '#c0392b';
                this.ctx.fillRect(x + 10, y + 8, 40, 22);

                // Cupola
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillRect(x + 20, y, 20, 12);

                // Windows
                this.ctx.fillStyle = '#f39c12';
                this.ctx.fillRect(x + 23, y + 3, 6, 6);
                this.ctx.fillRect(x + 31, y + 3, 6, 6);
                this.ctx.fillRect(x + 15, y + 14, 6, 8);
                this.ctx.fillRect(x + 39, y + 14, 6, 8);

                // Platform
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.fillRect(x + 5, y + 28, 50, 3);

                this.drawWheel(x + 18, y + this.train.height + 5, 7, wheelRotation);
                this.drawWheel(x + 42, y + this.train.height + 5, 7, wheelRotation);
            },

            drawWheel(x, y, radius, rotation) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(rotation);

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = '#7f8c8d';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI) / 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(Math.cos(angle) * radius * 0.8, Math.sin(angle) * radius * 0.8);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            },

            drawCoupler(x1, y1, x2, y2) {
                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.beginPath();
                this.ctx.arc(x1, y1, 4, 0, Math.PI * 2);
                this.ctx.arc(x2, y2, 4, 0, Math.PI * 2);
                this.ctx.fill();

                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                this.ctx.beginPath();
                this.ctx.arc(midX, midY, 3, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawSmoke(x, y) {
                const time = Date.now() * 0.001;
                const isBoostActive = this.train.momentum > 4;

                for (let i = 0; i < 8; i++) {
                    const age = i * 0.2;
                    const smokeX = x + 48 - (this.train.velocityX * age * 8) + Math.sin(time + i) * 5;
                    const smokeY = y - 5 - (age * 20) + Math.cos(time + i) * 3;
                    const size = 6 + age * 4;
                    const alpha = 0.6 - age * 0.15;

                    if (isBoostActive) {
                        this.ctx.fillStyle = `rgba(255,200,100,${alpha})`;
                    } else {
                        this.ctx.fillStyle = `rgba(200,200,200,${alpha})`;
                    }

                    this.ctx.beginPath();
                    this.ctx.arc(smokeX, smokeY, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            },

            drawSpeedTrail(cameraX) {
                const trailX = this.train.x - cameraX;
                const trailY = this.train.y + this.train.height;

                const trailIntensity = Math.min(Math.abs(this.train.velocityX) / 10, 1);
                const particleCount = Math.floor(5 + trailIntensity * 5);

                for (let i = 0; i < particleCount; i++) {
                    const offset = i * 10;
                    const alpha = (0.6 - (i * 0.1)) * trailIntensity;

                    if (this.train.onGround) {
                        this.ctx.strokeStyle = `rgba(255,255,100,${Math.max(0, alpha)})`;
                        this.ctx.lineWidth = Math.max(0.5, 2 - i * 0.3);
                        this.ctx.beginPath();
                        this.ctx.moveTo(trailX - offset, trailY);
                        this.ctx.lineTo(trailX - offset - 20, trailY);
                        this.ctx.stroke();
                    } else {
                        const radius = Math.max(0.5, 3 - i * 0.5);
                        if (alpha > 0) {
                            this.ctx.fillStyle = `rgba(255,255,100,${Math.max(0, alpha)})`;
                            this.ctx.beginPath();
                            this.ctx.arc(trailX - offset, trailY + offset * 0.5, radius, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }
        };

        // ===== FIELD GOAL GAME (Behind-View Perspective) =====
        const fieldgoalGame = {
            canvas: null,
            ctx: null,
            animationId: null,
            gameRunning: false,

            // Meter state
            meters: {
                direction: {
                    value: 50,
                    speed: 2,
                    increasing: true,
                    locked: false,
                    lockedValue: null
                },
                power: {
                    value: 0,
                    speed: 2.5,
                    increasing: true,
                    locked: false,
                    lockedValue: null
                }
            },

            // Game state
            kickPhase: 'waiting',
            roundGoalsMade: 0,
            requiredGoals: 3,
            resultMessage: '',
            resultColor: '',
            showingResult: false,

            // Ball physics (3D-like for behind view)
            ball: {
                x: 400,      // Left-right on screen
                y: 400,      // Near (bottom) to far (top)
                z: 0,        // Height above ground
                vx: 0,
                vy: 0,
                vz: 0,
                scale: 1.0,
                rotation: 0,
                visible: false
            },

            // Field setup
            field: {
                distance: 20,
                goalPostWidth: 100,
                wind: 0,
                goalPostOffset: 0,
                movingGoalPosts: false,
                movingSpeed: 0
            },

            // Crowd system
            crowd: {
                rows: 5,
                dotsPerRow: 50,
                state: 'neutral',
                animOffset: 0
            },

            // Referee system
            referees: {
                left: { armState: 'down' },
                right: { armState: 'down' },
                waveFrame: 0
            },

            // Visual elements
            particles: [],
            ballRotation: 0,

            init() {
                this.canvas = document.getElementById('fieldgoalCanvas');
                this.ctx = this.canvas.getContext('2d');
            },

            showKickPhase() {
                if (!this.canvas) this.init();

                const state = gameManager.gameStates.fieldgoal;
                state.phase = 'action';
                this.roundGoalsMade = 0;
                this.resultMessage = '';
                this.showingResult = false;

                // Reset referees
                this.referees.left.armState = 'down';
                this.referees.right.armState = 'down';
                this.crowd.state = 'neutral';

                // Set difficulty based on round
                const settings = this.getDifficultySettings(state.round);
                this.field.distance = settings.distance;
                this.field.wind = settings.wind;
                this.field.goalPostWidth = settings.goalWidth;
                this.field.movingGoalPosts = settings.movingGoalPosts;
                this.field.movingSpeed = settings.movingSpeed;
                this.field.goalPostOffset = 0;
                this.meters.direction.speed = settings.meterSpeed;
                this.meters.power.speed = settings.meterSpeed * 1.0;

                // Show kick phase
                document.getElementById('fieldgoalKickPhase').classList.remove('hidden');

                // Show power meter as inactive initially
                document.getElementById('powerMeterContainer').classList.remove('active');

                // Start game after countdown
                this.showCountdown(() => {
                    this.gameRunning = true;
                    sounds.playWhistle();
                    this.startKick();
                    this.gameLoop();
                });
            },

            showCountdown(callback) {
                let count = 3;
                this.render(); // Initial render

                const countdownDiv = document.createElement('div');
                countdownDiv.id = 'fieldgoalCountdown';
                countdownDiv.style.cssText = 'position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 5em; color: #fff; font-weight: bold; z-index: 100; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);';
                countdownDiv.textContent = count;
                document.getElementById('fieldgoalKickPhase').style.position = 'relative';
                document.getElementById('fieldgoalKickPhase').appendChild(countdownDiv);

                const interval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        countdownDiv.textContent = count;
                        sounds.playButtonClick();
                    } else {
                        countdownDiv.remove();
                        callback();
                        clearInterval(interval);
                    }
                }, 700);
            },

            startKick() {
                // Reset meters
                this.meters.direction.locked = false;
                this.meters.direction.lockedValue = null;
                this.meters.direction.value = 50;
                this.meters.direction.increasing = Math.random() > 0.5;

                this.meters.power.locked = false;
                this.meters.power.lockedValue = null;
                this.meters.power.value = 0;
                this.meters.power.increasing = true;

                this.kickPhase = 'direction';
                this.ball.visible = false;
                this.resultMessage = '';
                this.showingResult = false;

                // Reset referees
                this.referees.left.armState = 'down';
                this.referees.right.armState = 'down';
                this.crowd.state = 'neutral';

                // Update status
                document.getElementById('kickStatus').textContent = 'Press SPACE to set direction';
                document.getElementById('powerMeterContainer').classList.remove('active');
                document.getElementById('directionIndicator').classList.remove('locked');
                document.getElementById('powerIndicator').classList.remove('locked');
            },

            handleKick() {
                if (!this.gameRunning || this.showingResult) return;

                if (this.kickPhase === 'direction') {
                    this.lockDirection();
                } else if (this.kickPhase === 'power') {
                    this.lockPower();
                }
            },

            lockDirection() {
                this.meters.direction.locked = true;
                this.meters.direction.lockedValue = this.meters.direction.value;
                this.kickPhase = 'power';

                document.getElementById('directionIndicator').classList.add('locked');
                document.getElementById('powerMeterContainer').classList.add('active');
                document.getElementById('kickStatus').textContent = 'Press SPACE to set power';

                sounds.playButtonClick();
            },

            lockPower() {
                this.meters.power.locked = true;
                this.meters.power.lockedValue = this.meters.power.value;
                document.getElementById('powerIndicator').classList.add('locked');
                this.kickBall();
            },

            kickBall() {
                this.kickPhase = 'flying';
                const state = gameManager.gameStates.fieldgoal;
                state.resources--;

                document.getElementById('kickStatus').textContent = '';

                // Calculate trajectory from locked values
                const directionOffset = (this.meters.direction.lockedValue - 50) / 50; // -1 to 1
                const power = this.meters.power.lockedValue / 100; // 0 to 1

                // Set ball initial position and velocity (behind view)
                this.ball = {
                    x: 400,                          // Center of screen
                    y: 420,                          // Near bottom (close to viewer)
                    z: 0,                            // On ground
                    vx: directionOffset * 4,         // Lateral movement based on direction
                    vy: -(6 + power * 4),            // Forward velocity (toward goal)
                    vz: 8 + power * 6,               // Upward velocity
                    scale: 1.0,
                    rotation: 0,
                    visible: true
                };

                this.particles = [];
                sounds.playKick();
            },

            updateBall() {
                if (this.kickPhase !== 'flying' || !this.ball.visible) return;

                // Apply physics
                this.ball.x += this.ball.vx;
                this.ball.y += this.ball.vy;
                this.ball.z += this.ball.vz;
                this.ball.vz -= 0.4; // Gravity

                // Apply wind (affects x position)
                this.ball.vx += this.field.wind * 0.03;

                // Scale ball smaller as it gets further away
                const progress = (420 - this.ball.y) / 320;
                this.ball.scale = Math.max(0.2, 1.0 - progress * 0.7);

                // Rotation for visual spin
                this.ball.rotation += 0.15;

                // Add trail particles
                if (Math.random() > 0.6) {
                    this.particles.push({
                        x: this.ball.x,
                        y: this.ball.y,
                        alpha: 0.6,
                        size: 4 * this.ball.scale
                    });
                }

                // Check if ball reached goal area (y <= 130)
                if (this.ball.y <= 130) {
                    this.checkResult();
                }

                // Check if ball hit ground before reaching goal
                if (this.ball.z < 0 && this.ball.y > 130) {
                    this.showResult('SHORT!', false);
                }
            },

            calculateDoink(directionValue) {
                const distanceFromCenter = Math.abs(directionValue - 50);
                // Yellow zone: 10-25 from center
                if (distanceFromCenter >= 10 && distanceFromCenter <= 25) {
                    const doinkChance = (distanceFromCenter - 10) / 15;
                    if (Math.random() < doinkChance * 0.5) {
                        const goesIn = Math.random() < 0.2; // 20% chance doinks in
                        return { doink: true, goesIn };
                    }
                }
                return { doink: false };
            },

            checkResult() {
                const direction = this.meters.direction.lockedValue;
                const power = this.meters.power.lockedValue;

                // Check power first
                if (power < 45) {
                    this.showResult('SHORT!', false);
                    return;
                }

                // Check direction
                const dirOffset = Math.abs(direction - 50);

                // Account for moving goal posts
                let effectiveOffset = dirOffset;
                if (this.field.movingGoalPosts) {
                    const goalShift = this.field.goalPostOffset / 3;
                    if ((direction < 50 && goalShift > 0) || (direction > 50 && goalShift < 0)) {
                        effectiveOffset += Math.abs(goalShift);
                    } else {
                        effectiveOffset -= Math.abs(goalShift);
                    }
                }

                // Account for wind
                const windEffect = this.field.wind * 3;
                if ((direction < 50 && windEffect > 0) || (direction > 50 && windEffect < 0)) {
                    effectiveOffset += Math.abs(windEffect);
                } else {
                    effectiveOffset -= Math.abs(windEffect);
                }

                effectiveOffset = Math.max(0, effectiveOffset);

                if (effectiveOffset <= 10) {
                    // Clean make
                    this.showResult('THE KICK IS GOOD!', true);
                } else if (effectiveOffset <= 25) {
                    // Check for doink
                    const doinkResult = this.calculateDoink(direction);
                    if (doinkResult.doink) {
                        sounds.playDoink();
                        this.crowd.state = 'gasping';
                        if (doinkResult.goesIn) {
                            setTimeout(() => this.showResult('DOINK... GOOD!', true), 500);
                        } else {
                            setTimeout(() => this.showResult('DOINK... NO GOOD!', false), 500);
                        }
                        return;
                    }
                    // Close miss
                    if (direction < 50) {
                        this.showResult('WIDE LEFT!', false);
                    } else {
                        this.showResult('WIDE RIGHT!', false);
                    }
                } else {
                    // Clear miss
                    if (direction < 50) {
                        this.showResult('WIDE LEFT!', false);
                    } else {
                        this.showResult('WIDE RIGHT!', false);
                    }
                }
            },

            showResult(message, isGood) {
                this.kickPhase = 'result';
                this.resultMessage = message;
                this.resultColor = isGood ? '#27ae60' : '#e74c3c';
                this.showingResult = true;
                this.ball.visible = false;

                if (isGood) {
                    this.roundGoalsMade++;
                    gameManager.gameStates.fieldgoal.totalFieldGoalsMade++;
                    this.referees.left.armState = 'up';
                    this.referees.right.armState = 'up';
                    this.crowd.state = 'cheering';
                    sounds.playCrowdCheer();
                    this.createCelebrationParticles();
                } else {
                    this.referees.left.armState = 'waving';
                    this.referees.right.armState = 'waving';
                    this.crowd.state = 'groaning';
                    sounds.playCrowdGroan();
                }

                setTimeout(() => this.resetForNextKick(), 2000);
            },

            createCelebrationParticles() {
                for (let i = 0; i < 40; i++) {
                    this.particles.push({
                        x: 400 + (Math.random() - 0.5) * 100,
                        y: 130,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 4,
                        alpha: 1,
                        size: 6 + Math.random() * 6,
                        color: ['#27ae60', '#f1c40f', '#fff', '#3498db'][Math.floor(Math.random() * 4)]
                    });
                }
            },

            resetForNextKick() {
                const state = gameManager.gameStates.fieldgoal;
                this.showingResult = false;

                if (this.roundGoalsMade >= this.requiredGoals) {
                    this.endRound(true);
                    return;
                }

                if (state.resources <= 0) {
                    this.endRound(false);
                    return;
                }

                this.startKick();
            },

            updateMeters() {
                // Direction meter oscillates during direction phase
                if (this.kickPhase === 'direction' && !this.meters.direction.locked) {
                    if (this.meters.direction.increasing) {
                        this.meters.direction.value += this.meters.direction.speed;
                        if (this.meters.direction.value >= 100) {
                            this.meters.direction.increasing = false;
                        }
                    } else {
                        this.meters.direction.value -= this.meters.direction.speed;
                        if (this.meters.direction.value <= 0) {
                            this.meters.direction.increasing = true;
                        }
                    }
                }

                // Power meter oscillates during power phase
                if (this.kickPhase === 'power' && !this.meters.power.locked) {
                    if (this.meters.power.increasing) {
                        this.meters.power.value += this.meters.power.speed;
                        if (this.meters.power.value >= 100) {
                            this.meters.power.increasing = false;
                        }
                    } else {
                        this.meters.power.value -= this.meters.power.speed;
                        if (this.meters.power.value <= 0) {
                            this.meters.power.increasing = true;
                        }
                    }
                }

                this.updateMeterDisplay();
            },

            updateMeterDisplay() {
                const dirIndicator = document.getElementById('directionIndicator');
                const powerIndicator = document.getElementById('powerIndicator');

                if (dirIndicator) {
                    dirIndicator.style.left = this.meters.direction.value + '%';
                }
                if (powerIndicator) {
                    powerIndicator.style.bottom = this.meters.power.value + '%';
                }
            },

            updateGoalPosts() {
                if (this.field.movingGoalPosts) {
                    this.field.goalPostOffset = Math.sin(Date.now() / 1000 * this.field.movingSpeed) * 40;
                }
            },

            getDifficultySettings(round) {
                return {
                    distance: 20 + (round - 1) * 10,
                    meterSpeed: 1.5 + (round - 1) * 0.35,
                    wind: round >= 4 ? (Math.random() - 0.5) * (round - 2) * 1.5 : 0,
                    goalWidth: Math.max(50, 110 - (round - 1) * 10),
                    movingGoalPosts: round >= 6,
                    movingSpeed: round >= 6 ? 0.8 + (round - 6) * 0.3 : 0
                };
            },

            endRound(success) {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }

                const state = gameManager.gameStates.fieldgoal;

                if (success) {
                    showRoundComplete({
                        'Field Goals': `${this.roundGoalsMade}/${this.requiredGoals}`,
                        'Distance': `${this.field.distance} yards`,
                        'Total Goals': state.totalFieldGoalsMade
                    });
                } else {
                    showGameOver();
                }
            },

            updateParticles() {
                this.particles = this.particles.filter(p => {
                    p.alpha -= 0.02;
                    if (p.vx !== undefined) {
                        p.x += p.vx;
                        p.y += p.vy;
                        if (p.vy !== undefined) p.vy += 0.1;
                    }
                    return p.alpha > 0;
                });

                // Update crowd animation
                if (this.crowd.state === 'cheering') {
                    this.crowd.animOffset += 0.3;
                }

                // Update referee wave animation
                if (this.referees.left.armState === 'waving') {
                    this.referees.waveFrame += 0.2;
                }
            },

            // ===== RENDERING =====
            render() {
                const ctx = this.ctx;
                const state = gameManager.gameStates.fieldgoal;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawSky(ctx);
                this.drawCrowd(ctx, state.teamColor);
                this.drawScoreboard(ctx, state);
                this.drawField(ctx);
                this.drawEndzone(ctx, state.teamColor);
                this.drawGoalPosts(ctx);
                this.drawReferees(ctx);
                this.drawBallOnTee(ctx);
                this.drawFlyingBall(ctx);
                this.drawParticles(ctx);
                this.drawWindIndicator(ctx, state);
                this.drawResultMessage(ctx);
            },

            drawSky(ctx) {
                const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.5, '#16213e');
                gradient.addColorStop(1, '#0f3460');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, 200);
            },

            drawCrowd(ctx, teamColor) {
                const color = teamColor === 'blue' ? '#3498db' : '#e74c3c';
                const darkColor = teamColor === 'blue' ? '#2980b9' : '#c0392b';

                for (let row = 0; row < this.crowd.rows; row++) {
                    const y = 30 + row * 18;
                    const rowWidth = 700 - row * 40;
                    const startX = (this.canvas.width - rowWidth) / 2;
                    const dotCount = Math.floor(rowWidth / 14);

                    for (let i = 0; i < dotCount; i++) {
                        const x = startX + i * 14 + (row % 2) * 7;
                        let bounceY = 0;

                        if (this.crowd.state === 'cheering') {
                            bounceY = Math.sin((i + this.crowd.animOffset) * 0.5) * 4;
                        } else if (this.crowd.state === 'groaning') {
                            bounceY = 3;
                        }

                        ctx.fillStyle = (i + row) % 3 === 0 ? darkColor : color;
                        ctx.beginPath();
                        ctx.arc(x, y + bounceY, 5 - row * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            },

            drawScoreboard(ctx, state) {
                // Scoreboard background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(200, 5, 400, 50);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 2;
                ctx.strokeRect(200, 5, 400, 50);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';

                // Stats line
                ctx.fillText(`${this.field.distance} YARDS`, 280, 25);
                ctx.fillText(`${this.roundGoalsMade}/3 GOALS`, 400, 25);
                ctx.fillText(`${state.resources} BALLS`, 520, 25);

                // Round
                ctx.fillStyle = '#f1c40f';
                ctx.fillText(`ROUND ${state.round}`, 400, 45);
            },

            drawField(ctx) {
                // Field with perspective (trapezoid)
                ctx.fillStyle = '#1e7d32';
                ctx.beginPath();
                ctx.moveTo(50, 450);   // Bottom left
                ctx.lineTo(750, 450);  // Bottom right
                ctx.lineTo(550, 180);  // Top right
                ctx.lineTo(250, 180);  // Top left
                ctx.closePath();
                ctx.fill();

                // Yard lines with perspective
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const progress = i / 8;
                    const y = 450 - progress * 270;
                    const leftX = 50 + progress * 200;
                    const rightX = 750 - progress * 200;

                    ctx.beginPath();
                    ctx.moveTo(leftX, y);
                    ctx.lineTo(rightX, y);
                    ctx.stroke();
                }
            },

            drawEndzone(ctx, teamColor) {
                const color = teamColor === 'blue' ? '#2980b9' : '#c0392b';

                // Endzone (behind goal posts)
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(250, 180);
                ctx.lineTo(550, 180);
                ctx.lineTo(530, 140);
                ctx.lineTo(270, 140);
                ctx.closePath();
                ctx.fill();

                // Endzone text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('END ZONE', 400, 168);
            },

            drawGoalPosts(ctx) {
                const centerX = 400 + this.field.goalPostOffset;
                const width = this.field.goalPostWidth;
                const crossbarY = 130;

                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';

                // Left post
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, 180);
                ctx.lineTo(centerX - width/2, crossbarY);
                ctx.stroke();

                // Right post
                ctx.beginPath();
                ctx.moveTo(centerX + width/2, 180);
                ctx.lineTo(centerX + width/2, crossbarY);
                ctx.stroke();

                // Crossbar
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, crossbarY);
                ctx.lineTo(centerX + width/2, crossbarY);
                ctx.stroke();

                // Upper extensions
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX - width/2, crossbarY);
                ctx.lineTo(centerX - width/2 - 5, crossbarY - 50);
                ctx.moveTo(centerX + width/2, crossbarY);
                ctx.lineTo(centerX + width/2 + 5, crossbarY - 50);
                ctx.stroke();
            },

            drawReferees(ctx) {
                this.drawReferee(ctx, 200, 175, this.referees.left);
                this.drawReferee(ctx, 600, 175, this.referees.right);
            },

            drawReferee(ctx, x, y, ref) {
                // Body (black and white stripes)
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(x - 6, y, 12, 20);

                // Head
                ctx.fillStyle = '#fdbf6f';
                ctx.beginPath();
                ctx.arc(x, y - 6, 6, 0, Math.PI * 2);
                ctx.fill();

                // Arms based on state
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;

                if (ref.armState === 'up') {
                    // Arms raised (touchdown/good signal)
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 5);
                    ctx.lineTo(x - 15, y - 15);
                    ctx.moveTo(x + 6, y + 5);
                    ctx.lineTo(x + 15, y - 15);
                    ctx.stroke();
                } else if (ref.armState === 'waving') {
                    // Arms waving (no good signal)
                    const wave = Math.sin(this.referees.waveFrame) * 10;
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 5);
                    ctx.lineTo(x - 18 + wave, y);
                    ctx.moveTo(x + 6, y + 5);
                    ctx.lineTo(x + 18 - wave, y);
                    ctx.stroke();
                } else {
                    // Arms down
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 5);
                    ctx.lineTo(x - 10, y + 15);
                    ctx.moveTo(x + 6, y + 5);
                    ctx.lineTo(x + 10, y + 15);
                    ctx.stroke();
                }
            },

            drawBallOnTee(ctx) {
                if (this.kickPhase === 'direction' || this.kickPhase === 'power') {
                    // Tee
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.moveTo(390, 415);
                    ctx.lineTo(410, 415);
                    ctx.lineTo(405, 405);
                    ctx.lineTo(395, 405);
                    ctx.closePath();
                    ctx.fill();

                    // Ball on tee
                    this.drawFootball(ctx, 400, 395, 1.0, 0);
                }
            },

            drawFlyingBall(ctx) {
                if (this.ball.visible) {
                    // Calculate screen position based on 3D coords
                    const screenY = this.ball.y - this.ball.z * 0.5;
                    this.drawFootball(ctx, this.ball.x, screenY, this.ball.scale, this.ball.rotation);
                }
            },

            drawFootball(ctx, x, y, scale, rotation) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                // Football shape
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = '#5d3a1a';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Laces
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, 0);
                ctx.lineTo(6, 0);
                ctx.stroke();

                // Cross laces
                for (let i = -4; i <= 4; i += 4) {
                    ctx.beginPath();
                    ctx.moveTo(i, -4);
                    ctx.lineTo(i, 4);
                    ctx.stroke();
                }

                ctx.restore();
            },

            drawParticles(ctx) {
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color || '#8B4513';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            },

            drawWindIndicator(ctx, state) {
                if (state.round >= 4 && this.field.wind !== 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(650, 60, 140, 35);

                    ctx.fillStyle = '#87CEEB';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('WIND', 720, 75);

                    const windDir = this.field.wind > 0 ? '‚Üí' : '‚Üê';
                    const windStrength = Math.abs(this.field.wind).toFixed(1);
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(`${windDir.repeat(Math.min(3, Math.ceil(Math.abs(this.field.wind))))} ${windStrength}`, 720, 92);
                }
            },

            drawResultMessage(ctx) {
                if (this.showingResult && this.resultMessage) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(150, 200, 500, 80);

                    ctx.fillStyle = this.resultColor;
                    ctx.font = 'bold 40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.resultMessage, 400, 255);
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.updateMeters();
                this.updateGoalPosts();
                this.updateBall();
                this.updateParticles();
                this.render();

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            handleKeyPress(e) {
                if (!this.gameRunning) return;

                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    this.handleKick();
                }
            }
        };

        // ===== MINI GOLF GAME =====
        const minigolfGame = {
            canvas: null,
            ctx: null,
            animationId: null,
            gameRunning: false,

            // Ball state
            ball: {
                x: 400,
                y: 500,
                vx: 0,
                vy: 0,
                radius: 8,
                moving: false
            },

            // Hole state
            hole: {
                x: 400,
                y: 100,
                radius: 12
            },

            // Putter state
            putter: {
                angle: -Math.PI / 2,  // Pointing up initially
                length: 50
            },

            // Power meter
            power: {
                value: 0,
                charging: false,
                maxPower: 12
            },

            // Course obstacles
            walls: [],
            bumpers: [],      // { x, y, radius }
            sandTraps: [],    // { x, y, width, height }

            // Ball-in-hole animation state
            sinkingBall: {
                active: false,
                startX: 0,
                startY: 0,
                angle: 0,
                progress: 0
            },

            // 18 Course definitions
            courses: [
                // === BEGINNER (1-6) ===
                // Hole 1: Straight Shot
                { ball: {x:400,y:520}, hole: {x:400,y:100}, walls: [], bumpers: [], sandTraps: [] },
                // Hole 2: Slight Left
                { ball: {x:400,y:520}, hole: {x:250,y:100}, walls: [], bumpers: [], sandTraps: [] },
                // Hole 3: Slight Right
                { ball: {x:400,y:520}, hole: {x:550,y:100}, walls: [], bumpers: [], sandTraps: [] },
                // Hole 4: First Wall
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [{x1:300,y1:300,x2:500,y2:300}], bumpers: [], sandTraps: [] },
                // Hole 5: The Corridor
                { ball: {x:200,y:520}, hole: {x:200,y:100},
                  walls: [{x1:300,y1:100,x2:300,y2:450}], bumpers: [], sandTraps: [] },
                // Hole 6: Bumper Intro
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [], bumpers: [{x:400,y:300,radius:25}], sandTraps: [] },

                // === INTERMEDIATE (7-12) ===
                // Hole 7: Zigzag
                { ball: {x:200,y:520}, hole: {x:600,y:100},
                  walls: [{x1:350,y1:200,x2:350,y2:400}, {x1:450,y1:300,x2:450,y2:500}],
                  bumpers: [], sandTraps: [] },
                // Hole 8: Bumper Bounce
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [], bumpers: [{x:300,y:300,radius:25},{x:500,y:300,radius:25}], sandTraps: [] },
                // Hole 9: The L-Shape
                { ball: {x:600,y:520}, hole: {x:200,y:100},
                  walls: [{x1:350,y1:100,x2:350,y2:350}, {x1:350,y1:350,x2:600,y2:350}],
                  bumpers: [], sandTraps: [] },
                // Hole 10: Sand Intro
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [], bumpers: [], sandTraps: [{x:350,y:250,width:100,height:100}] },
                // Hole 11: Bumper Alley
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [],
                  bumpers: [{x:300,y:300,radius:20},{x:400,y:300,radius:20},{x:500,y:300,radius:20}],
                  sandTraps: [] },
                // Hole 12: Split Path
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [{x1:400,y1:200,x2:400,y2:400}],
                  bumpers: [], sandTraps: [] },

                // === ADVANCED (13-18) ===
                // Hole 13: Sand Trap Run
                { ball: {x:200,y:520}, hole: {x:600,y:100},
                  walls: [], bumpers: [],
                  sandTraps: [{x:300,y:200,width:200,height:60},{x:400,y:350,width:200,height:60}] },
                // Hole 14: Pinball
                { ball: {x:400,y:520}, hole: {x:400,y:100},
                  walls: [],
                  bumpers: [{x:250,y:200,radius:22},{x:550,y:200,radius:22},
                            {x:300,y:350,radius:22},{x:500,y:350,radius:22}],
                  sandTraps: [] },
                // Hole 15: The Maze
                { ball: {x:150,y:520}, hole: {x:650,y:100},
                  walls: [{x1:250,y1:100,x2:250,y2:350},{x1:400,y1:250,x2:400,y2:520},
                          {x1:550,y1:100,x2:550,y2:400}],
                  bumpers: [], sandTraps: [] },
                // Hole 16: Beach Hazard
                { ball: {x:400,y:520}, hole: {x:400,y:150},
                  walls: [], bumpers: [],
                  sandTraps: [{x:300,y:100,width:200,height:150}] },
                // Hole 17: Obstacle Course
                { ball: {x:600,y:520}, hole: {x:200,y:100},
                  walls: [{x1:350,y1:200,x2:350,y2:350}],
                  bumpers: [{x:500,y:250,radius:20},{x:250,y:400,radius:20}],
                  sandTraps: [{x:400,y:400,width:80,height:80}] },
                // Hole 18: Championship
                { ball: {x:400,y:520}, hole: {x:600,y:80},
                  walls: [{x1:200,y1:200,x2:350,y2:200},{x1:450,y1:350,x2:600,y2:350},
                          {x1:300,y1:100,x2:300,y2:200}],
                  bumpers: [{x:400,y:250,radius:25},{x:550,y:450,radius:20}],
                  sandTraps: [{x:450,y:150,width:80,height:80}] }
            ],

            // Game tracking
            strokesUsed: 0,

            init() {
                this.canvas = document.getElementById('minigolfCanvas');
                this.ctx = this.canvas.getContext('2d');
            },

            startPuttPhase() {
                if (!this.canvas) this.init();
                const state = gameManager.gameStates.minigolf;

                // Setup hole based on round
                this.setupHole(state.round);
                this.strokesUsed = 0;

                document.getElementById('minigolfPuttPhase').classList.remove('hidden');
                this.updateStatus();
                this.gameRunning = true;
                this.gameLoop();
            },

            setupHole(round) {
                // Get course index (1-18, then repeat)
                const courseIndex = ((round - 1) % 18);
                const course = this.courses[courseIndex];

                // Position ball from course definition
                this.ball.x = course.ball.x;
                this.ball.y = course.ball.y;
                this.ball.vx = 0;
                this.ball.vy = 0;
                this.ball.moving = false;

                // Position hole from course definition
                this.hole.x = course.hole.x;
                this.hole.y = course.hole.y;

                // Load obstacles from course definition
                this.walls = this.generateBorderWalls().concat(course.walls || []);
                this.bumpers = course.bumpers || [];
                this.sandTraps = course.sandTraps || [];

                // Reset animation state
                this.sinkingBall.active = false;

                // Reset putter and power
                this.putter.angle = -Math.PI / 2;
                this.power.value = 0;
                this.power.charging = false;
            },

            generateBorderWalls() {
                const left = 100, right = 700, top = 50, bottom = 570;
                return [
                    { x1: left, y1: top, x2: right, y2: top },       // Top
                    { x1: left, y1: bottom, x2: right, y2: bottom }, // Bottom
                    { x1: left, y1: top, x2: left, y2: bottom },     // Left
                    { x1: right, y1: top, x2: right, y2: bottom }    // Right
                ];
            },

            checkBumperCollisions() {
                for (const bumper of this.bumpers) {
                    const dx = this.ball.x - bumper.x;
                    const dy = this.ball.y - bumper.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = this.ball.radius + bumper.radius;

                    if (dist < minDist && dist > 0) {
                        // Normalize and bounce
                        const nx = dx / dist;
                        const ny = dy / dist;

                        // Push ball out
                        this.ball.x = bumper.x + nx * minDist;
                        this.ball.y = bumper.y + ny * minDist;

                        // Reflect velocity with boost (bumper effect)
                        const dot = this.ball.vx * nx + this.ball.vy * ny;
                        this.ball.vx = (this.ball.vx - 2 * dot * nx) * 1.1;
                        this.ball.vy = (this.ball.vy - 2 * dot * ny) * 1.1;

                        sounds.playButtonClick();
                    }
                }
            },

            checkSandTrap() {
                for (const trap of this.sandTraps) {
                    if (this.ball.x > trap.x &&
                        this.ball.x < trap.x + trap.width &&
                        this.ball.y > trap.y &&
                        this.ball.y < trap.y + trap.height) {
                        // Heavy friction in sand
                        this.ball.vx *= 0.92;
                        this.ball.vy *= 0.92;
                        return true;
                    }
                }
                return false;
            },

            startSinkAnimation() {
                this.sinkingBall.active = true;
                this.sinkingBall.startX = this.ball.x;
                this.sinkingBall.startY = this.ball.y;
                this.sinkingBall.angle = Math.atan2(
                    this.ball.y - this.hole.y,
                    this.ball.x - this.hole.x
                );
                this.sinkingBall.progress = 0;
                this.ball.moving = true;
            },

            updateSinkAnimation() {
                this.sinkingBall.progress += 0.03;

                if (this.sinkingBall.progress >= 1) {
                    // Animation complete - ball is in hole
                    this.ball.x = this.hole.x;
                    this.ball.y = this.hole.y;
                    this.sinkingBall.active = false;
                    this.ballInHole();
                    return;
                }

                // Spiral parameters
                const p = this.sinkingBall.progress;
                const startDist = Math.sqrt(
                    Math.pow(this.sinkingBall.startX - this.hole.x, 2) +
                    Math.pow(this.sinkingBall.startY - this.hole.y, 2)
                );

                // Shrinking radius with rotation
                const currentRadius = startDist * (1 - p);
                const rotations = 1.5;
                const currentAngle = this.sinkingBall.angle + (p * rotations * Math.PI * 2);

                // Update ball position along spiral
                this.ball.x = this.hole.x + Math.cos(currentAngle) * currentRadius;
                this.ball.y = this.hole.y + Math.sin(currentAngle) * currentRadius;
            },

            gameLoop() {
                if (!this.gameRunning) return;

                this.update();
                this.render();

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            update() {
                // Update power if charging
                if (this.power.charging && !this.ball.moving) {
                    this.power.value = Math.min(this.power.value + 0.25, this.power.maxPower);
                    this.updatePowerMeter();
                }

                // Update ball physics if moving
                if (this.ball.moving) {
                    this.updateBallPhysics();
                }
            },

            updatePowerMeter() {
                const fill = document.getElementById('minigolfPowerFill');
                if (fill) {
                    const percent = (this.power.value / this.power.maxPower) * 100;
                    fill.style.height = (100 - percent) + '%';
                }
            },

            updateBallPhysics() {
                // Check for spiral animation
                if (this.sinkingBall.active) {
                    this.updateSinkAnimation();
                    return;
                }

                // Apply velocity
                this.ball.x += this.ball.vx;
                this.ball.y += this.ball.vy;

                // Apply friction (reduced if in sand)
                const inSand = this.checkSandTrap();
                if (!inSand) {
                    this.ball.vx *= 0.985;
                    this.ball.vy *= 0.985;
                }

                // Collisions
                this.checkWallCollisions();
                this.checkBumperCollisions();

                // Check if ball stopped
                const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                if (speed < 0.15) {
                    this.ball.vx = 0;
                    this.ball.vy = 0;
                    this.ball.moving = false;
                    this.checkHoleResult();
                }

                // Check if ball entering hole (start spiral animation)
                if (speed < 3) {
                    const dx = this.ball.x - this.hole.x;
                    const dy = this.ball.y - this.hole.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < this.hole.radius) {
                        this.startSinkAnimation();
                    }
                }
            },

            checkWallCollisions() {
                const r = this.ball.radius;

                // Border collisions
                if (this.ball.x - r < 100) {
                    this.ball.x = 100 + r;
                    this.ball.vx *= -0.7;
                    sounds.playButtonClick();
                }
                if (this.ball.x + r > 700) {
                    this.ball.x = 700 - r;
                    this.ball.vx *= -0.7;
                    sounds.playButtonClick();
                }
                if (this.ball.y - r < 50) {
                    this.ball.y = 50 + r;
                    this.ball.vy *= -0.7;
                    sounds.playButtonClick();
                }
                if (this.ball.y + r > 570) {
                    this.ball.y = 570 - r;
                    this.ball.vy *= -0.7;
                    sounds.playButtonClick();
                }

                // Obstacle wall collisions (simplified - horizontal/vertical only)
                for (const wall of this.walls) {
                    // Skip border walls (already handled)
                    if (wall.x1 === 100 && wall.x2 === 100) continue;
                    if (wall.x1 === 700 && wall.x2 === 700) continue;
                    if (wall.y1 === 50 && wall.y2 === 50) continue;
                    if (wall.y1 === 570 && wall.y2 === 570) continue;

                    // Horizontal wall
                    if (wall.y1 === wall.y2) {
                        const minX = Math.min(wall.x1, wall.x2);
                        const maxX = Math.max(wall.x1, wall.x2);
                        if (this.ball.x >= minX && this.ball.x <= maxX) {
                            if (Math.abs(this.ball.y - wall.y1) < r + 4) {
                                if (this.ball.vy > 0 && this.ball.y < wall.y1) {
                                    this.ball.y = wall.y1 - r - 4;
                                    this.ball.vy *= -0.7;
                                    sounds.playButtonClick();
                                } else if (this.ball.vy < 0 && this.ball.y > wall.y1) {
                                    this.ball.y = wall.y1 + r + 4;
                                    this.ball.vy *= -0.7;
                                    sounds.playButtonClick();
                                }
                            }
                        }
                    }
                    // Vertical wall
                    if (wall.x1 === wall.x2) {
                        const minY = Math.min(wall.y1, wall.y2);
                        const maxY = Math.max(wall.y1, wall.y2);
                        if (this.ball.y >= minY && this.ball.y <= maxY) {
                            if (Math.abs(this.ball.x - wall.x1) < r + 4) {
                                if (this.ball.vx > 0 && this.ball.x < wall.x1) {
                                    this.ball.x = wall.x1 - r - 4;
                                    this.ball.vx *= -0.7;
                                    sounds.playButtonClick();
                                } else if (this.ball.vx < 0 && this.ball.x > wall.x1) {
                                    this.ball.x = wall.x1 + r + 4;
                                    this.ball.vx *= -0.7;
                                    sounds.playButtonClick();
                                }
                            }
                        }
                    }
                }
            },

            checkHoleResult() {
                const dx = this.ball.x - this.hole.x;
                const dy = this.ball.y - this.hole.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.hole.radius + this.ball.radius) {
                    this.ballInHole();
                } else {
                    // Ball stopped but not in hole - check if strokes remaining
                    this.updateStatus();
                    const state = gameManager.gameStates.minigolf;
                    if (state.resources <= 0) {
                        setTimeout(() => this.endRound(false), 500);
                    }
                }
            },

            ballInHole() {
                const state = gameManager.gameStates.minigolf;
                state.totalHolesCompleted++;

                this.ball.moving = false;
                this.gameRunning = false;

                sounds.playCorrect();

                // Show success message briefly then end round
                const status = document.getElementById('puttStatus');
                status.textContent = 'üéâ HOLE IN ' + this.strokesUsed + '!';

                setTimeout(() => {
                    this.endRound(true);
                }, 1500);
            },

            putt() {
                const state = gameManager.gameStates.minigolf;
                if (state.resources <= 0 || this.ball.moving) return;

                // Use a stroke
                state.resources--;
                this.strokesUsed++;

                // Calculate velocity from angle and power
                const speed = this.power.value;
                this.ball.vx = Math.cos(this.putter.angle) * speed;
                this.ball.vy = Math.sin(this.putter.angle) * speed;
                this.ball.moving = true;

                // Reset power
                this.power.value = 0;
                this.power.charging = false;
                this.updatePowerMeter();

                sounds.playButtonClick();
                this.updateStatus();
            },

            updateStatus() {
                const state = gameManager.gameStates.minigolf;
                const status = document.getElementById('puttStatus');
                if (this.ball.moving) {
                    status.textContent = '...rolling...';
                } else {
                    status.textContent = `Hole ${state.round} | Strokes: ${state.resources} | ‚Üê ‚Üí aim, hold SPACE for power`;
                }
            },

            endRound(success) {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                document.getElementById('minigolfPuttPhase').classList.add('hidden');
                document.getElementById('minigolfGame').style.display = 'none';
                document.getElementById('sharedGameContainer').style.display = 'block';

                if (success) {
                    showRoundComplete({
                        'Strokes Used': this.strokesUsed,
                        'Hole': gameManager.gameStates.minigolf.round
                    });
                } else {
                    showGameOver();
                }
            },

            render() {
                const ctx = this.ctx;
                const state = gameManager.gameStates.minigolf;

                // Clear canvas
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grass background
                this.drawGreen(ctx);

                // Draw sand traps (under everything)
                this.drawSandTraps(ctx);

                // Draw walls/obstacles
                this.drawWalls(ctx);

                // Draw bumpers
                this.drawBumpers(ctx);

                // Draw hole
                this.drawHole(ctx);

                // Draw ball (smaller if sinking)
                if (this.sinkingBall.active) {
                    const scale = 1 - (this.sinkingBall.progress * 0.5);
                    this.drawBall(ctx, state.ballColor, scale);
                } else {
                    this.drawBall(ctx, state.ballColor);
                }

                // Draw putter (only when ball not moving)
                if (!this.ball.moving) {
                    this.drawPutter(ctx);
                }

                // Draw HUD
                this.drawHUD(ctx, state);
            },

            drawGreen(ctx) {
                // Outer area
                ctx.fillStyle = '#1a472a';
                ctx.fillRect(0, 0, 800, 600);

                // Putting green
                ctx.fillStyle = '#228B22';
                ctx.fillRect(100, 50, 600, 520);

                // Subtle green texture
                ctx.fillStyle = 'rgba(50, 160, 50, 0.3)';
                for (let i = 0; i < 20; i++) {
                    const x = 100 + Math.random() * 600;
                    const y = 50 + Math.random() * 520;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawWalls(ctx) {
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';

                for (const wall of this.walls) {
                    ctx.beginPath();
                    ctx.moveTo(wall.x1, wall.y1);
                    ctx.lineTo(wall.x2, wall.y2);
                    ctx.stroke();
                }
            },

            drawSandTraps(ctx) {
                for (const trap of this.sandTraps) {
                    // Sand fill
                    ctx.fillStyle = '#D2B48C';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Border
                    ctx.strokeStyle = '#8B7355';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(trap.x, trap.y, trap.width, trap.height);
                }
            },

            drawBumpers(ctx) {
                for (const bumper of this.bumpers) {
                    // Outer ring (red)
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner highlight (orange)
                    ctx.fillStyle = '#f39c12';
                    ctx.beginPath();
                    ctx.arc(bumper.x, bumper.y, bumper.radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    // Shine effect
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.beginPath();
                    ctx.arc(bumper.x - bumper.radius * 0.3, bumper.y - bumper.radius * 0.3,
                            bumper.radius * 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Border
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            },

            drawHole(ctx) {
                // Hole shadow/cup
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.hole.x, this.hole.y, this.hole.radius, 0, Math.PI * 2);
                ctx.fill();

                // Flag pole
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.hole.x, this.hole.y);
                ctx.lineTo(this.hole.x, this.hole.y - 45);
                ctx.stroke();

                // Flag
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(this.hole.x, this.hole.y - 45);
                ctx.lineTo(this.hole.x + 20, this.hole.y - 38);
                ctx.lineTo(this.hole.x, this.hole.y - 30);
                ctx.closePath();
                ctx.fill();
            },

            drawBall(ctx, colorId, scale = 1) {
                const colors = { white: '#ffffff', orange: '#ff6b35' };
                const color = colors[colorId] || '#ffffff';
                const r = this.ball.radius * scale;

                // Ball shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(this.ball.x + 2 * scale, this.ball.y + 2 * scale, r, r * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ball
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.beginPath();
                ctx.arc(this.ball.x - 2 * scale, this.ball.y - 2 * scale, 3 * scale, 0, Math.PI * 2);
                ctx.fill();
            },

            drawPutter(ctx) {
                // Direction line (dotted)
                const lineLen = 80;
                const dirX = this.ball.x + Math.cos(this.putter.angle) * lineLen;
                const dirY = this.ball.y + Math.sin(this.putter.angle) * lineLen;

                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(this.ball.x, this.ball.y);
                ctx.lineTo(dirX, dirY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Putter (behind ball)
                const putterX = this.ball.x - Math.cos(this.putter.angle) * 15;
                const putterY = this.ball.y - Math.sin(this.putter.angle) * 15;
                const putterEndX = this.ball.x - Math.cos(this.putter.angle) * (15 + this.putter.length);
                const putterEndY = this.ball.y - Math.sin(this.putter.angle) * (15 + this.putter.length);

                // Putter shaft
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(putterX, putterY);
                ctx.lineTo(putterEndX, putterEndY);
                ctx.stroke();

                // Putter head
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(putterX, putterY, 6, 0, Math.PI * 2);
                ctx.fill();
            },

            drawHUD(ctx, state) {
                // Background bar
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, 800, 40);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Hole ${state.round}`, 20, 28);

                ctx.textAlign = 'right';
                ctx.fillText(`Strokes: ${state.resources}`, 780, 28);

                ctx.textAlign = 'center';
                ctx.fillText(`‚õ≥ Math Mini Golf`, 400, 28);
            },

            handleKeyDown(e) {
                if (!this.gameRunning) return;

                const rotateSpeed = 0.06;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (!this.ball.moving) {
                        this.putter.angle -= rotateSpeed;
                    }
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!this.ball.moving) {
                        this.putter.angle += rotateSpeed;
                    }
                } else if (e.key === ' ') {
                    e.preventDefault();
                    if (!this.ball.moving && !this.power.charging) {
                        this.power.charging = true;
                        this.power.value = 0;
                    }
                }
            },

            handleKeyUp(e) {
                if (e.key === ' ' && this.power.charging) {
                    e.preventDefault();
                    this.power.charging = false;
                    if (this.power.value > 0.5) {
                        this.putt();
                    } else {
                        this.power.value = 0;
                        this.updatePowerMeter();
                    }
                }
            },

            cleanup() {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        };

        // ===== MOTORCYCLE RACING GAME =====
        const motorcycleGame = {
            canvas: null,
            ctx: null,
            animationId: null,
            gameRunning: false,

            // Bike state
            bike: {
                x: 400,
                y: 450,
                width: 30,
                height: 50,
                speed: 5,
                lateralSpeed: 0,
                jumping: false,
                jumpScale: 1.0,
                jumpTimer: 0
            },

            // Track state
            track: {
                scrollY: 0,
                roadCenterX: 400,
                roadWidth: 300,
                sandWidth: 80,
                segments: [],
                segmentLength: 100,
                curveIntensity: 0.5
            },

            // Ramps on track
            ramps: [],

            // Game tracking
            distance: 0,
            targetDistance: 1000,
            timeRemaining: 30,
            timerInterval: null,

            // Boost state
            boost: {
                active: false,
                timer: 0,
                duration: 0,
                multiplier: 1.0,
                targetMultiplier: 1.0,  // For smooth ramping
                rampSpeed: 0.03         // How fast to ramp up/down
            },

            init() {
                this.canvas = document.getElementById('motorcycleCanvas');
                this.ctx = this.canvas.getContext('2d');
            },

            startRacePhase() {
                const state = gameManager.gameStates.motorcycle;

                // Hide shared container, show motorcycle game
                document.getElementById('sharedGameContainer').style.display = 'none';
                document.getElementById('motorcycleGame').style.display = 'block';
                document.getElementById('motorcycleRacePhase').classList.remove('hidden');

                this.init();
                this.setupTrack(state.round);
                this.resetBike();
                this.distance = 0;
                this.boost = { active: false, timer: 0, duration: 0, multiplier: 1.0, targetMultiplier: 1.0, rampSpeed: 0.03 };

                // Timer in milliseconds for precision
                this.timeRemaining = 30000;
                this.lastFrameTime = performance.now();

                this.gameRunning = true;
                sounds.startEngine();
                this.gameLoop();
            },

            resetBike() {
                this.bike = {
                    x: 400,
                    y: 450,
                    width: 30,
                    height: 50,
                    speed: 5,
                    lateralSpeed: 0,
                    jumping: false,
                    jumpScale: 1.0,
                    jumpTimer: 0,
                    lean: 0,           // Lean angle for steering
                    wheelRotation: 0,  // Wheel spin animation
                    trail: []          // Trail particles for boost
                };
                this.screenShake = { x: 0, y: 0, intensity: 0 };
            },

            setupTrack(round) {
                // Set target distance (increases each round)
                // Base speed 5 * 60fps = 300 units/sec, so 9000 = 30 seconds
                // Each round adds 1500m, requiring boosts to finish in time
                this.targetDistance = 9000 + (round - 1) * 1500;

                // Set curve intensity (increases each round)
                this.track.curveIntensity = 0.3 + (round - 1) * 0.15;

                // Generate road segments with curves
                this.generateTrackSegments();

                // Place ramps on track
                this.generateRamps(round);
            },

            generateTrackSegments() {
                this.track.segments = [];
                let currentX = 400;

                for (let i = 0; i < 300; i++) {
                    // Sine wave for road curves
                    const curveOffset = Math.sin(i * 0.08) * this.track.curveIntensity * 150;
                    currentX = 400 + curveOffset;

                    this.track.segments.push({
                        y: i * this.track.segmentLength,
                        centerX: currentX
                    });
                }
            },

            generateRamps(round) {
                this.ramps = [];
                // More ramps spread across the longer track
                const rampCount = 4 + round;
                const spacing = Math.floor(this.targetDistance / (rampCount + 1));

                for (let i = 0; i < rampCount; i++) {
                    this.ramps.push({
                        y: spacing * (i + 1) + (Math.random() - 0.5) * 300,
                        offsetX: (Math.random() - 0.5) * 100,
                        width: 60,
                        height: 40,
                        hit: false
                    });
                }
            },

            gameLoop() {
                if (!this.gameRunning) return;

                // Calculate delta time for accurate timing
                const now = performance.now();
                const deltaTime = now - this.lastFrameTime;
                this.lastFrameTime = now;

                // Update countdown timer
                this.timeRemaining -= deltaTime;
                if (this.timeRemaining <= 0) {
                    this.timeRemaining = 0;
                    this.endRound(false);
                    return;
                }

                this.update();
                this.render();

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            update() {
                // Update boost timer and smooth ramping
                if (this.boost.active) {
                    this.boost.timer -= 16;
                    if (this.boost.timer <= 0) {
                        this.boost.active = false;
                        this.boost.targetMultiplier = 1.0;  // Start ramping down
                    }
                }

                // Smooth ramp multiplier toward target
                if (this.boost.multiplier < this.boost.targetMultiplier) {
                    this.boost.multiplier = Math.min(this.boost.multiplier + this.boost.rampSpeed, this.boost.targetMultiplier);
                } else if (this.boost.multiplier > this.boost.targetMultiplier) {
                    this.boost.multiplier = Math.max(this.boost.multiplier - this.boost.rampSpeed, this.boost.targetMultiplier);
                }

                // Update jump animation
                if (this.bike.jumping) {
                    this.bike.jumpTimer -= 16;
                    // Scale up then down during jump
                    const progress = 1 - (this.bike.jumpTimer / 1000);
                    this.bike.jumpScale = 1.0 + 0.5 * Math.sin(progress * Math.PI);

                    if (this.bike.jumpTimer <= 0) {
                        this.bike.jumping = false;
                        this.bike.jumpScale = 1.0;
                    }
                }

                // Calculate current speed
                let speed = this.bike.speed * this.boost.multiplier;

                // Update engine sound based on speed
                sounds.updateEngine(speed);

                // Check terrain under bike (only if not jumping)
                if (!this.bike.jumping) {
                    const terrain = this.getTerrainAtBike();
                    if (terrain === 'sand') {
                        speed *= 0.5;
                    } else if (terrain === 'edge') {
                        this.crash();
                        return;
                    }
                }

                // Update distance
                this.distance += speed;

                // Scroll track
                this.track.scrollY += speed;

                // Check for ramp collisions
                if (!this.bike.jumping) {
                    this.checkRampCollisions();
                }

                // Check win condition
                if (this.distance >= this.targetDistance) {
                    this.endRound(true);
                }

                // Update wheel rotation based on speed
                this.bike.wheelRotation += speed * 0.3;

                // Update trail particles when boosting
                if (this.boost.active || this.boost.multiplier > 1.1) {
                    this.bike.trail.push({
                        x: this.bike.x + (Math.random() - 0.5) * 10,
                        y: this.bike.y + 25,
                        life: 20,
                        size: 3 + Math.random() * 3
                    });
                }
                // Fade and remove old trail particles
                this.bike.trail = this.bike.trail.filter(p => {
                    p.life--;
                    p.y += 2;
                    return p.life > 0;
                });

                // Update screen shake
                if (this.screenShake.intensity > 0) {
                    this.screenShake.x = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.y = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.intensity *= 0.9;
                    if (this.screenShake.intensity < 0.5) {
                        this.screenShake.intensity = 0;
                        this.screenShake.x = 0;
                        this.screenShake.y = 0;
                    }
                }
            },

            getTerrainAtBike() {
                // Find current road segment
                const segmentIndex = Math.floor(this.distance / this.track.segmentLength);
                const segment = this.track.segments[segmentIndex % this.track.segments.length];

                const roadLeft = segment.centerX - this.track.roadWidth / 2;
                const roadRight = segment.centerX + this.track.roadWidth / 2;
                const sandLeft = roadLeft - this.track.sandWidth;
                const sandRight = roadRight + this.track.sandWidth;

                if (this.bike.x >= roadLeft && this.bike.x <= roadRight) {
                    return 'road';
                } else if (this.bike.x >= sandLeft && this.bike.x <= sandRight) {
                    return 'sand';
                } else {
                    return 'edge';
                }
            },

            checkRampCollisions() {
                for (const ramp of this.ramps) {
                    const distanceToRamp = ramp.y - this.distance;
                    // Ramp peak screen Y = 600 - distanceToRamp - 10
                    // Bike front is at screen Y = 430 (bike.y - 20)
                    // Trigger when bike front reaches ramp peak: distanceToRamp ‚âà 160
                    if (distanceToRamp > 140 && distanceToRamp < 180) {
                        // Check X collision with ramp
                        const segmentIndex = Math.floor(ramp.y / this.track.segmentLength);
                        const segment = this.track.segments[segmentIndex % this.track.segments.length];
                        const rampX = segment.centerX + ramp.offsetX;

                        if (Math.abs(this.bike.x - rampX) < 40 && !ramp.hit) {
                            ramp.hit = true;
                            this.triggerJump();
                        }
                    }
                }
            },

            triggerJump() {
                this.bike.jumping = true;
                this.bike.jumpTimer = 1000;

                // If turbo is active during jump, extend to superboost
                if (this.boost.active) {
                    this.boost.timer = 2000;  // 2 second superboost
                    this.boost.targetMultiplier = 2.2;
                } else {
                    // Normal ramp boost
                    this.boost.active = true;
                    this.boost.timer = 1000;  // 1 second boost
                    this.boost.targetMultiplier = 1.8;
                }

                sounds.playCorrect();
            },

            activateTurbo() {
                const state = gameManager.gameStates.motorcycle;
                if (state.resources <= 0 || this.boost.active) return;

                state.resources--;
                this.boost.active = true;
                this.boost.timer = 1000;  // 1 second turbo boost
                this.boost.targetMultiplier = 1.8;

                sounds.playButtonClick();
            },

            crash() {
                this.gameRunning = false;
                sounds.playIncorrect();
                setTimeout(() => this.endRound(false), 500);
            },

            endRound(success) {
                this.gameRunning = false;
                sounds.stopEngine();
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                const state = gameManager.gameStates.motorcycle;
                state.totalDistanceTraveled += Math.floor(this.distance);

                // Hide motorcycle game, show shared container
                document.getElementById('motorcycleRacePhase').classList.add('hidden');
                document.getElementById('motorcycleGame').style.display = 'none';
                document.getElementById('sharedGameContainer').style.display = 'block';

                if (success) {
                    const secondsLeft = (this.timeRemaining / 1000).toFixed(1);
                    showRoundComplete({
                        'Distance': Math.floor(this.distance) + 'm',
                        'Time Left': secondsLeft + 's',
                        'Track': state.round
                    });
                } else {
                    showGameOver();
                }
            },

            render() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, 800, 600);

                // Apply screen shake
                ctx.save();
                ctx.translate(this.screenShake.x, this.screenShake.y);

                this.drawTrack(ctx);
                this.drawFinishLine(ctx);
                this.drawRamps(ctx);
                this.drawTrail(ctx);
                this.drawBike(ctx);
                this.drawSpeedLines(ctx);

                ctx.restore();

                // HUD drawn without shake
                this.drawHUD(ctx);
                this.drawSpeedometer(ctx);
            },

            drawTrail(ctx) {
                for (const p of this.bike.trail) {
                    const alpha = p.life / 20;
                    ctx.fillStyle = `rgba(255, 150, 50, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawSpeedLines(ctx) {
                const speed = this.bike.speed * this.boost.multiplier;
                if (speed < 7) return;  // Only show at higher speeds

                const intensity = (speed - 7) / 8;  // 0 to 1 based on speed
                const lineCount = Math.floor(intensity * 10) + 3;

                ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.4})`;
                ctx.lineWidth = 2;

                for (let i = 0; i < lineCount; i++) {
                    const side = i % 2 === 0 ? -1 : 1;
                    const x = side === -1 ? 20 + Math.random() * 60 : 720 + Math.random() * 60;
                    const y = 100 + Math.random() * 400;
                    const len = 30 + Math.random() * 50 * intensity;

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + len);
                    ctx.stroke();
                }
            },

            drawTrack(ctx) {
                // Draw track segments from bottom to top
                for (let screenY = 600; screenY >= -100; screenY -= 10) {
                    const worldY = this.distance + (600 - screenY);
                    const segmentIndex = Math.floor(worldY / this.track.segmentLength);
                    const segment = this.track.segments[segmentIndex % this.track.segments.length];

                    const centerX = segment.centerX;
                    const roadHalf = this.track.roadWidth / 2;
                    const sandHalf = roadHalf + this.track.sandWidth;

                    // Edge (grass/barrier)
                    ctx.fillStyle = '#2d5016';
                    ctx.fillRect(0, screenY, 800, 12);

                    // Sand
                    ctx.fillStyle = '#d4a84b';
                    ctx.fillRect(centerX - sandHalf, screenY, this.track.sandWidth, 12);
                    ctx.fillRect(centerX + roadHalf, screenY, this.track.sandWidth, 12);

                    // Road
                    ctx.fillStyle = '#444';
                    ctx.fillRect(centerX - roadHalf, screenY, this.track.roadWidth, 12);

                    // Road markings (dashed center line)
                    if (Math.floor(worldY / 40) % 2 === 0) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(centerX - 2, screenY, 4, 10);
                    }
                }
            },

            drawFinishLine(ctx) {
                // Draw checkered finish line at target distance
                const finishY = this.targetDistance;
                const screenY = 600 - (finishY - this.distance);

                // Only draw if visible on screen
                if (screenY < -50 || screenY > 700) return;

                const segmentIndex = Math.floor(finishY / this.track.segmentLength);
                const segment = this.track.segments[segmentIndex % this.track.segments.length];
                const centerX = segment.centerX;
                const roadHalf = this.track.roadWidth / 2;

                // Draw checkered pattern
                const squareSize = 20;
                const rows = 3;

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < Math.ceil(this.track.roadWidth / squareSize); col++) {
                        const isWhite = (row + col) % 2 === 0;
                        ctx.fillStyle = isWhite ? '#fff' : '#000';
                        const x = centerX - roadHalf + col * squareSize;
                        const y = screenY + row * squareSize - squareSize;
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }

                // "FINISH" banner above
                if (screenY > 80) {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(centerX - 80, screenY - 70, 160, 30);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üèÅ FINISH üèÅ', centerX, screenY - 50);
                }
            },

            drawRamps(ctx) {
                for (const ramp of this.ramps) {
                    const screenY = 600 - (ramp.y - this.distance);
                    if (screenY < -50 || screenY > 650) continue;

                    const segmentIndex = Math.floor(ramp.y / this.track.segmentLength);
                    const segment = this.track.segments[segmentIndex % this.track.segments.length];
                    const rampX = segment.centerX + ramp.offsetX;

                    // Draw ramp
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.moveTo(rampX - 30, screenY + 20);
                    ctx.lineTo(rampX, screenY - 10);
                    ctx.lineTo(rampX + 30, screenY + 20);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#d35400';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            },

            drawBike(ctx) {
                const state = gameManager.gameStates.motorcycle;
                const colors = { red: '#e74c3c', blue: '#3498db' };
                const color = colors[state.bikeColor] || '#e74c3c';
                const darkerColor = state.bikeColor === 'blue' ? '#2980b9' : '#c0392b';

                ctx.save();
                ctx.translate(this.bike.x, this.bike.y);
                ctx.scale(this.bike.jumpScale, this.bike.jumpScale);
                ctx.rotate(this.bike.lean);  // Lean animation

                // Shadow when jumping
                if (this.bike.jumping) {
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(5, 35, 22, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // === IMPROVED MOTORCYCLE DESIGN ===

                // Front wheel with tread animation (overhead view - treads move forward)
                ctx.save();
                ctx.translate(0, -18);
                // Wheel base
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Tread marks scrolling forward (use wheelRotation as vertical offset)
                ctx.save();
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.clip();
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                const treadSpacing = 4;
                const treadOffset = (this.bike.wheelRotation * 5) % treadSpacing;
                for (let y = -8 + treadOffset; y <= 8; y += treadSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(-8, y);
                    ctx.lineTo(8, y);
                    ctx.stroke();
                }
                ctx.restore();
                ctx.restore();

                // Rear wheel with tread animation
                ctx.save();
                ctx.translate(0, 20);
                // Wheel base
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.ellipse(0, 0, 9, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                // Tread marks scrolling forward
                ctx.save();
                ctx.beginPath();
                ctx.ellipse(0, 0, 9, 6, 0, 0, Math.PI * 2);
                ctx.clip();
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                for (let y = -10 + treadOffset; y <= 10; y += treadSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(-9, y);
                    ctx.lineTo(9, y);
                    ctx.stroke();
                }
                ctx.restore();
                ctx.restore();

                // Bike frame/body (rounded)
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(-10, -12);
                ctx.quadraticCurveTo(-12, 0, -10, 15);
                ctx.lineTo(-6, 18);
                ctx.lineTo(6, 18);
                ctx.lineTo(10, 15);
                ctx.quadraticCurveTo(12, 0, 10, -12);
                ctx.lineTo(6, -15);
                ctx.lineTo(-6, -15);
                ctx.closePath();
                ctx.fill();

                // Fuel tank (darker accent)
                ctx.fillStyle = darkerColor;
                ctx.beginPath();
                ctx.ellipse(0, 2, 7, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Windshield
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.moveTo(-6, -14);
                ctx.quadraticCurveTo(0, -20, 6, -14);
                ctx.lineTo(4, -10);
                ctx.lineTo(-4, -10);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Handlebars
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-12, -8);
                ctx.lineTo(-8, -10);
                ctx.moveTo(8, -10);
                ctx.lineTo(12, -8);
                ctx.stroke();

                // Exhaust pipe
                ctx.fillStyle = '#666';
                ctx.fillRect(8, 10, 6, 3);
                ctx.fillStyle = '#888';
                ctx.fillRect(12, 9, 4, 5);

                // === RIDER SILHOUETTE ===
                // Helmet
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(0, -6, 6, 0, Math.PI * 2);
                ctx.fill();
                // Visor
                ctx.fillStyle = '#4a90d9';
                ctx.beginPath();
                ctx.arc(0, -5, 4, -0.3, Math.PI + 0.3);
                ctx.fill();
                // Body hunched over
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(0, 4, 5, 7, 0, 0, Math.PI * 2);
                ctx.fill();

                // Boost flames (improved)
                if (this.boost.multiplier > 1.1) {
                    const flameIntensity = (this.boost.multiplier - 1) / 1.5;
                    // Orange core
                    ctx.fillStyle = `rgba(255, 150, 50, ${flameIntensity})`;
                    ctx.beginPath();
                    ctx.moveTo(-6, 22);
                    ctx.lineTo(0, 35 + Math.random() * 15 * flameIntensity);
                    ctx.lineTo(6, 22);
                    ctx.fill();
                    // Yellow inner
                    ctx.fillStyle = `rgba(255, 220, 100, ${flameIntensity * 0.8})`;
                    ctx.beginPath();
                    ctx.moveTo(-3, 22);
                    ctx.lineTo(0, 28 + Math.random() * 10 * flameIntensity);
                    ctx.lineTo(3, 22);
                    ctx.fill();
                }

                ctx.restore();
            },

            drawHUD(ctx) {
                const state = gameManager.gameStates.motorcycle;

                // Background bar
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, 800, 50);

                // Time - show milliseconds when under 10 seconds for drama
                const seconds = this.timeRemaining / 1000;
                const isLowTime = seconds <= 10;

                // Flash effect when very low
                const flash = seconds <= 5 && Math.floor(Date.now() / 200) % 2 === 0;
                ctx.fillStyle = isLowTime ? (flash ? '#ff6b6b' : '#e74c3c') : '#fff';
                ctx.font = isLowTime ? 'bold 28px Arial' : 'bold 24px Arial';
                ctx.textAlign = 'left';

                let timeText;
                if (isLowTime) {
                    // Show with 1 decimal place for milliseconds drama
                    timeText = `‚è±Ô∏è ${seconds.toFixed(1)}s`;
                } else {
                    timeText = `‚è±Ô∏è ${Math.ceil(seconds)}s`;
                }
                ctx.fillText(timeText, 20, 35);

                // Distance / Target
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                const progress = Math.min(this.distance / this.targetDistance, 1);
                ctx.fillText(`${Math.floor(this.distance)}m / ${this.targetDistance}m`, 400, 35);

                // Progress bar
                ctx.fillStyle = '#333';
                ctx.fillRect(250, 42, 300, 6);
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(250, 42, 300 * progress, 6);

                // Turbos remaining
                ctx.fillStyle = '#f39c12';
                ctx.textAlign = 'right';
                ctx.fillText(`‚ö° ${state.resources}`, 780, 35);
            },

            drawSpeedometer(ctx) {
                const centerX = 720;
                const centerY = 520;
                const radius = 50;

                // Background circle
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius + 5, 0, Math.PI * 2);
                ctx.fill();

                // Speed arc background
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0.75 * Math.PI, 0.25 * Math.PI);
                ctx.stroke();

                // Speed arc fill
                const speed = this.bike.speed * this.boost.multiplier;
                const maxSpeed = 15;
                const speedRatio = Math.min(speed / maxSpeed, 1);
                const endAngle = 0.75 * Math.PI + speedRatio * 1.5 * Math.PI;

                ctx.strokeStyle = speed > 10 ? '#e74c3c' : '#27ae60';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0.75 * Math.PI, endAngle);
                ctx.stroke();

                // Speed text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.floor(speed * 10) + '', centerX, centerY + 5);
                ctx.font = '10px Arial';
                ctx.fillText('km/h', centerX, centerY + 18);
            },

            handleKeyDown(e) {
                if (!this.gameRunning) return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    this.bike.x -= 8;
                    this.bike.lean = -0.2;  // Lean left
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    this.bike.x += 8;
                    this.bike.lean = 0.2;   // Lean right
                } else if (e.key === ' ') {
                    e.preventDefault();
                    this.activateTurbo();
                }
            },

            handleKeyUp(e) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    this.bike.lean = 0;  // Return to upright
                }
            },

            cleanup() {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                sounds.stopEngine();
            }
        };

        // ===== SNOWBALL THROWING GAME =====
        const snowballGame = {
            canvas: null,
            ctx: null,
            animationId: null,
            gameRunning: false,

            // Slingshot state
            slingshot: {
                x: 400,
                y: 520,
                direction: 0,
                loft: 0.5,
                power: 0,
                charging: false
            },

            // Active snowball in flight (bezier curve animation)
            snowball: {
                active: false,
                t: 0,                    // Bezier parameter (0 to 1)
                flightDuration: 0,       // Total flight time in ms
                elapsedTime: 0,          // Time since throw
                start: { x: 0, y: 0 },   // Starting position
                control: { x: 0, y: 0 }, // Bezier control point
                end: { x: 0, y: 0 },     // Target position (exact landing spot)
                x: 0,                    // Current render position
                y: 0
            },

            // 5 Snowman targets
            snowmen: [],

            // Particle systems
            particles: [],
            splatMarks: [],
            fallingSnow: [],

            // Round state
            snowmenHitThisRound: 0,
            requiredHits: 3,
            timeRemaining: 30000,
            lastTime: 0,

            // Difficulty settings
            difficulty: {
                popBack: true,
                ducking: false,
                duckVisibleTime: 2000,
                duckHiddenTime: 1500,
                availableTargets: [1, 2, 3, 4, 5]
            },

            init() {
                this.canvas = document.getElementById('snowballCanvas');
                this.ctx = this.canvas.getContext('2d');
                // Initialize falling snow
                this.fallingSnow = [];
                for (let i = 0; i < 50; i++) {
                    this.fallingSnow.push({
                        x: Math.random() * 800,
                        y: Math.random() * 600,
                        size: Math.random() * 3 + 1,
                        speed: Math.random() * 1 + 0.5
                    });
                }
            },

            startThrowPhase() {
                this.init();
                const state = gameManager.gameStates.snowball;

                this.setupDifficulty(state.round);
                this.resetSnowmen();
                this.snowmenHitThisRound = 0;
                this.timeRemaining = 30000;
                this.particles = [];
                this.splatMarks = [];
                this.resetSlingshot();
                this.snowball.active = false;

                document.getElementById('snowballThrowPhase').classList.remove('hidden');
                document.getElementById('snowballGame').style.display = 'block';
                document.getElementById('sharedGameContainer').style.display = 'none';

                this.gameRunning = true;
                this.lastTime = performance.now();
                this.gameLoop();
            },

            setupDifficulty(round) {
                switch(round) {
                    case 1:
                        this.difficulty = { popBack: true, ducking: false, duckVisibleTime: 2000, duckHiddenTime: 1500, availableTargets: [1,2,3,4,5] };
                        break;
                    case 2:
                        this.difficulty = { popBack: false, ducking: false, duckVisibleTime: 2000, duckHiddenTime: 1500, availableTargets: [1,2,3,4,5] };
                        break;
                    case 3:
                        this.difficulty = { popBack: false, ducking: true, duckVisibleTime: 2000, duckHiddenTime: 1500, availableTargets: [1,2,3,4,5] };
                        break;
                    case 4:
                        this.difficulty = { popBack: false, ducking: true, duckVisibleTime: 1800, duckHiddenTime: 1200, availableTargets: [1,2,4,5] };
                        break;
                    default:
                        this.difficulty = { popBack: false, ducking: true, duckVisibleTime: 1500, duckHiddenTime: 1000, availableTargets: [1,4,5] };
                }
            },

            resetSnowmen() {
                // Fort at (120, 350), Igloo at (520, 370), Tree at (680, 330) - all moved up 50px

                this.snowmen = [
                    {
                        // Tower snowman - on fort tower, head/body exposed above tower top
                        // Tower top is at y=350-100=250. Position snowman so head is above that
                        id: 1, x: 75, y: 280, name: 'Fort Tower',
                        scale: 0.85,  // Same size as wall snowman
                        showPos: { x: 75, y: 280 },
                        hidePos: { x: 75, y: 320 },  // Duck behind tower
                        hit: false, visible: true, ducking: false, duckTimer: Math.random() * 2000
                    },
                    {
                        // Wall snowman - on fort wall, head/body exposed, base behind
                        // Wall top is at y=350-18=332. Position so body visible above
                        id: 2, x: 150, y: 315, name: 'Fort Wall',
                        scale: 0.85,  // Same size as tower snowman
                        showPos: { x: 150, y: 315 },
                        hidePos: { x: 120, y: 350 },  // Duck behind wall
                        hit: false, visible: true, ducking: false, duckTimer: Math.random() * 2000
                    },
                    {
                        // Front snowman - big, in foreground, no cover
                        id: 3, x: 320, y: 450, name: 'Ground',
                        scale: 1.3,  // Largest snowman
                        showPos: { x: 320, y: 450 },
                        hidePos: { x: 320, y: 450 },  // No cover
                        hit: false, visible: true, ducking: false, duckTimer: Math.random() * 2000,
                        hideShadow: false
                    },
                    {
                        // Igloo snowman - LEFT side of igloo so visible
                        // Igloo dome at (520, 370). Put snowman to the left at x~455
                        id: 4, x: 455, y: 340, name: 'Igloo',
                        scale: 0.85,
                        showPos: { x: 455, y: 340 },
                        hidePos: { x: 490, y: 370 },  // Duck behind igloo dome
                        hit: false, visible: true, ducking: false, duckTimer: Math.random() * 2000,
                        hideShadow: false
                    },
                    {
                        // Tree snowman - half covered, peeking from RIGHT side
                        // Tree at (680, 330). Put snowman to right at x~735
                        id: 5, x: 735, y: 330, name: 'Tree',
                        scale: 0.8,
                        showPos: { x: 735, y: 330 },
                        hidePos: { x: 700, y: 350 },  // Duck behind tree
                        hit: false, visible: true, ducking: false, duckTimer: Math.random() * 2000
                    }
                ];
            },

            resetSlingshot() {
                this.slingshot.direction = 0;
                this.slingshot.loft = 0.5;
                this.slingshot.power = 0;
                this.slingshot.charging = false;
                this.slingshot.lockedAngle = null;  // Angle locked when space pressed
            },

            // Get aim angle from direction: -1 to +1 maps to 165¬∞ to 15¬∞
            getAimAngle() {
                // direction: -1 ‚Üí aims at 15¬∞ (far right, just above horizontal)
                // direction: 0 ‚Üí aims at 90¬∞ (straight up)
                // direction: +1 ‚Üí aims at 165¬∞ (far left, just above horizontal)
                // Offset of 75¬∞ (5œÄ/12) from vertical gives 15¬∞-165¬∞ range
                return -Math.PI/2 - this.slingshot.direction * (5 * Math.PI / 12);
            },

            // Get target position based on locked angle (if charging) or current aim angle
            // Distance extends from 50px to 500px as power increases
            getTargetPosition() {
                // Use locked angle if charging, otherwise current aim angle
                const angle = this.slingshot.charging && this.slingshot.lockedAngle !== null
                    ? this.slingshot.lockedAngle
                    : this.getAimAngle();

                // Distance: 50px (min) to 500px (max) based on power
                const minDistance = 50;
                const maxDistance = 400;
                const distance = minDistance + this.slingshot.power * (maxDistance - minDistance);

                // Use slingshot.y - 30 to match the actual launch point in calculateTrajectoryArc()
                return {
                    x: this.slingshot.x + Math.cos(angle) * distance,
                    y: (this.slingshot.y - 30) + Math.sin(angle) * distance
                };
            },

            // Calculate bezier trajectory arc from slingshot to target
            calculateTrajectoryArc() {
                const start = { x: this.slingshot.x, y: this.slingshot.y - 30 };
                const end = this.getTargetPosition();

                // Control point: midpoint raised by loft amount
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                // Loft adjusts arc height (50-200px above midpoint), but NOT landing position
                const arcHeight = 50 + this.slingshot.loft * 150;

                const control = { x: midX, y: midY - arcHeight };

                // Generate quadratic bezier curve points
                const points = [];
                for (let t = 0; t <= 1; t += 0.02) {
                    const x = (1-t)*(1-t)*start.x + 2*(1-t)*t*control.x + t*t*end.x;
                    const y = (1-t)*(1-t)*start.y + 2*(1-t)*t*control.y + t*t*end.y;
                    points.push({ x, y });
                }

                return { points, start, control, end };
            },

            gameLoop() {
                if (!this.gameRunning) return;

                const now = performance.now();
                const delta = now - this.lastTime;
                this.lastTime = now;

                this.update(delta);
                this.render();

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            update(delta) {
                this.timeRemaining -= delta;
                if (this.timeRemaining <= 0) {
                    this.endRound(false);
                    return;
                }

                if (this.difficulty.ducking) {
                    this.updateDuckingSnowmen(delta);
                }

                if (this.snowball.active) {
                    this.updateSnowball(delta);
                }

                if (this.slingshot.charging) {
                    // Power charges at constant rate (fills in ~1.5 seconds)
                    this.slingshot.power = Math.min(1, this.slingshot.power + delta / 1500);

                    // Auto-release at max power
                    if (this.slingshot.power >= 1) {
                        this.throwSnowball();
                        this.slingshot.charging = false;
                        this.slingshot.power = 0;
                        this.slingshot.lockedAngle = null;
                    }
                }

                this.updateParticles(delta);
                this.updateFallingSnow();

                if (this.snowmenHitThisRound >= this.requiredHits) {
                    this.endRound(true);
                    return;
                }

                const state = gameManager.gameStates.snowball;
                if (state.resources <= 0 && !this.snowball.active && this.snowmenHitThisRound < this.requiredHits) {
                    setTimeout(() => this.endRound(false), 500);
                }
            },

            updateDuckingSnowmen(delta) {
                const lerpSpeed = 0.008;  // Animation speed for duck/show transitions

                for (const snowman of this.snowmen) {
                    if (snowman.hit || !this.difficulty.availableTargets.includes(snowman.id)) continue;

                    snowman.duckTimer -= delta;
                    if (snowman.duckTimer <= 0) {
                        snowman.ducking = !snowman.ducking;
                        snowman.visible = true;  // Always visible during animation
                        snowman.duckTimer = snowman.ducking ? this.difficulty.duckHiddenTime : this.difficulty.duckVisibleTime;
                    }

                    // Animate position between show and hide positions
                    const targetPos = snowman.ducking ? snowman.hidePos : snowman.showPos;
                    const dx = targetPos.x - snowman.x;
                    const dy = targetPos.y - snowman.y;

                    // Lerp toward target position
                    snowman.x += dx * lerpSpeed * delta;
                    snowman.y += dy * lerpSpeed * delta;

                    // Snap when close enough
                    if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
                        snowman.x = targetPos.x;
                        snowman.y = targetPos.y;
                        // If fully ducked behind cover, become invisible (unhittable)
                        if (snowman.ducking) {
                            snowman.visible = false;
                        }
                    }
                }
            },

            updateSnowball(delta) {
                // Bezier animation: advance t based on elapsed time
                this.snowball.elapsedTime += delta;
                // Allow t to go beyond 1 for continued flight
                this.snowball.t = this.snowball.elapsedTime / this.snowball.flightDuration;

                // Quadratic bezier interpolation (works for t > 1 to extrapolate)
                const t = this.snowball.t;
                const s = this.snowball.start;
                const c = this.snowball.control;
                const e = this.snowball.end;

                this.snowball.x = (1-t)*(1-t)*s.x + 2*(1-t)*t*c.x + t*t*e.x;
                this.snowball.y = (1-t)*(1-t)*s.y + 2*(1-t)*t*c.y + t*t*e.y;

                // Check if snowball went off-screen - disappear silently
                if (this.snowball.x < -20 || this.snowball.x > 820 ||
                    this.snowball.y < -20 || this.snowball.y > 620) {
                    this.snowball.active = false;
                    return;
                }

                // At landing (t >= 1), check if we hit a snowman at the landing spot
                if (this.snowball.t >= 1) {
                    // First check snowman collision - snowball lands where target showed
                    for (const snowman of this.snowmen) {
                        if (!snowman.hit && snowman.visible && this.difficulty.availableTargets.includes(snowman.id)) {
                            const dist = Math.hypot(this.snowball.x - snowman.x, this.snowball.y - snowman.y);
                            const hitRadius = 40 * snowman.scale;  // Scaled hitbox
                            if (dist < hitRadius) {
                                this.hitSnowman(snowman);
                                return;
                            }
                        }
                    }

                    // No snowman hit - ball landed and missed
                    this.snowballMiss();
                    return;
                }
            },

            checkStructureCollision() {
                const x = this.snowball.x;
                const y = this.snowball.y;

                // Snow fort collision - Fort at (120, 350) - moved up 50px
                // Tower: x=50-70, y=250-350. Wall: x=50-190, y=350-410
                if ((x >= 45 && x <= 195 && y >= 230 && y <= 420)) {
                    this.snowballMiss();
                    return true;
                }

                // Igloo collision - dome at (520, 370) with radius ~70 - moved up 50px
                const iglooDistX = x - 520;
                const iglooDistY = y - 370;
                if (iglooDistX * iglooDistX + (iglooDistY * 1.5) * (iglooDistY * 1.5) < 75 * 75 && y < 370) {
                    this.snowballMiss();
                    return true;
                }

                // Pine tree collision - Tree at (680, 330), larger tree shape - moved up 50px
                // Tree extends from about x=610 to x=750, y=210 to y=380
                if (x >= 605 && x <= 755 && y >= 200 && y <= 390) {
                    this.snowballMiss();
                    return true;
                }

                return false;
            },

            updateParticles(delta) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life -= delta;
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                // Splat marks now persist until round end (no fade)
            },

            updateFallingSnow() {
                for (const flake of this.fallingSnow) {
                    flake.y += flake.speed;
                    flake.x += Math.sin(flake.y / 30) * 0.5;
                    if (flake.y > 600) {
                        flake.y = -10;
                        flake.x = Math.random() * 800;
                    }
                }
            },

            hitSnowman(snowman) {
                snowman.hit = true;
                this.snowmenHitThisRound++;

                const state = gameManager.gameStates.snowball;
                state.totalSnowmenHit++;

                this.createHitParticles(snowman.x, snowman.y);
                sounds.playCorrect();

                if (this.difficulty.popBack) {
                    setTimeout(() => {
                        snowman.hit = false;
                        snowman.visible = true;
                        snowman.ducking = false;
                        // Reset to show position
                        snowman.x = snowman.showPos.x;
                        snowman.y = snowman.showPos.y;
                        snowman.duckTimer = Math.random() * 2000 + 1000;
                    }, 1500);
                }

                this.snowball.active = false;
            },

            snowballMiss() {
                const x = this.snowball.x;
                const y = this.snowball.y;

                // If snowball is off-screen, just disappear (no splat)
                if (x < 0 || x > 800 || y < 0 || y > 600) {
                    this.snowball.active = false;
                    return;
                }

                // On-screen miss - create splat mark
                this.splatMarks.push({
                    x: x,
                    y: y,
                    alpha: 1
                });
                this.createMissParticles(x, y);
                this.snowball.active = false;
            },

            throwSnowball() {
                const state = gameManager.gameStates.snowball;
                if (state.resources <= 0 || this.snowball.active) return;

                state.resources--;

                // Calculate bezier curve for flight
                const trajectory = this.calculateTrajectoryArc();

                // Set up bezier animation
                this.snowball.active = true;
                this.snowball.t = 0;
                this.snowball.start = trajectory.start;
                this.snowball.control = trajectory.control;
                this.snowball.end = trajectory.end;
                // Flight duration based on loft (arc height): lower arc = faster
                // Loft 0 (low arc) ‚Üí 500ms, Loft 1 (high arc) ‚Üí 1200ms
                this.snowball.flightDuration = 500 + this.slingshot.loft * 700;
                this.snowball.elapsedTime = 0;
                this.snowball.x = trajectory.start.x;
                this.snowball.y = trajectory.start.y;

                sounds.playButtonClick();
            },

            createHitParticles(x, y) {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 3,
                        size: Math.random() * 6 + 2,
                        life: 800
                    });
                }
            },

            createMissParticles(x, y) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 3,
                        size: Math.random() * 4 + 1,
                        life: 500
                    });
                }
            },

            endRound(success) {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                document.getElementById('snowballThrowPhase').classList.add('hidden');
                document.getElementById('snowballGame').style.display = 'none';
                document.getElementById('sharedGameContainer').style.display = 'block';

                const state = gameManager.gameStates.snowball;

                if (success) {
                    showRoundComplete({
                        'Snowmen Hit': this.snowmenHitThisRound,
                        'Time Left': Math.ceil(this.timeRemaining / 1000) + 's',
                        'Round': state.round
                    });
                } else {
                    showGameOver();
                }
            },

            handleKeyDown(e) {
                if (!this.gameRunning) return;

                if (e.key === 'ArrowLeft' && !this.slingshot.charging) {
                    e.preventDefault();
                    // Left arrow ‚Üí aim left (increase direction toward +1)
                    // Only allowed when NOT charging (direction locked during charge)
                    this.slingshot.direction = Math.min(1, this.slingshot.direction + 0.08);
                } else if (e.key === 'ArrowRight' && !this.slingshot.charging) {
                    e.preventDefault();
                    // Right arrow ‚Üí aim right (decrease direction toward -1)
                    // Only allowed when NOT charging (direction locked during charge)
                    this.slingshot.direction = Math.max(-1, this.slingshot.direction - 0.08);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    // Up/down can adjust loft anytime (affects arc height, not landing)
                    this.slingshot.loft = Math.min(1, this.slingshot.loft + 0.08);
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.slingshot.loft = Math.max(0, this.slingshot.loft - 0.08);
                } else if (e.key === ' ' && !this.slingshot.charging && !this.snowball.active) {
                    e.preventDefault();
                    // Lock the current aim angle when starting to charge
                    this.slingshot.lockedAngle = this.getAimAngle();
                    this.slingshot.charging = true;
                    this.slingshot.power = 0;
                }
            },

            handleKeyUp(e) {
                if (e.key === ' ' && this.slingshot.charging) {
                    e.preventDefault();
                    // IMPORTANT: Call throwSnowball() BEFORE resetting charging/power
                    // so getTargetPosition() uses the correct power value
                    this.throwSnowball();
                    this.slingshot.charging = false;
                    this.slingshot.power = 0;
                    this.slingshot.lockedAngle = null;  // Clear locked angle after throw
                }
            },

            render() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, 800, 600);

                this.drawBackgroundBase(ctx);
                this.drawSplatMarks(ctx);
                this.drawSnowmen(ctx);        // Snowmen drawn BEHIND elements
                this.drawElements(ctx);        // Fort, igloo, tree drawn IN FRONT
                this.drawSlingshot(ctx);
                this.drawTrajectory(ctx);
                this.drawSnowball(ctx);
                this.drawParticles(ctx);
                this.drawFallingSnowRender(ctx);
                this.drawHUD(ctx);
            },

            drawBackgroundBase(ctx) {
                // Sky gradient
                const skyGrad = ctx.createLinearGradient(0, 0, 0, 450);
                skyGrad.addColorStop(0, '#5BA3D9');
                skyGrad.addColorStop(0.6, '#87CEEB');
                skyGrad.addColorStop(1, '#B0E0E6');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, 800, 450);

                // Sun with glow
                const sunX = 680, sunY = 80;
                const sunGlow = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 80);
                sunGlow.addColorStop(0, 'rgba(255, 250, 200, 1)');
                sunGlow.addColorStop(0.3, 'rgba(255, 245, 180, 0.6)');
                sunGlow.addColorStop(1, 'rgba(255, 245, 180, 0)');
                ctx.fillStyle = sunGlow;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 80, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF5B8';
                ctx.beginPath();
                ctx.arc(sunX, sunY, 28, 0, Math.PI * 2);
                ctx.fill();

                // Clouds
                this.drawCloud(ctx, 120, 90, 1.0);
                this.drawCloud(ctx, 350, 60, 0.7);
                this.drawCloud(ctx, 550, 110, 0.85);

                // Distant mountains (back layer - lighter) - extend higher for new fence position
                ctx.fillStyle = '#C8D8E8';
                ctx.beginPath();
                ctx.moveTo(0, 200);
                ctx.lineTo(100, 140);
                ctx.lineTo(200, 180);
                ctx.lineTo(320, 110);
                ctx.lineTo(450, 170);
                ctx.lineTo(550, 130);
                ctx.lineTo(680, 185);
                ctx.lineTo(800, 145);
                ctx.lineTo(800, 200);
                ctx.closePath();
                ctx.fill();

                // Closer mountains (front layer - darker)
                ctx.fillStyle = '#A8C0D5';
                ctx.beginPath();
                ctx.moveTo(0, 200);
                ctx.lineTo(80, 155);
                ctx.lineTo(180, 190);
                ctx.lineTo(280, 145);
                ctx.lineTo(400, 195);
                ctx.lineTo(500, 155);
                ctx.lineTo(620, 195);
                ctx.lineTo(720, 160);
                ctx.lineTo(800, 190);
                ctx.lineTo(800, 200);
                ctx.closePath();
                ctx.fill();

                // Tiny snowman on the mountains (far background)
                this.drawTinySnowman(ctx, 335, 115);

                // Solid wooden backyard fence (moved back, top at ~200)
                this.drawWoodenFence(ctx);

                // Snow ground with texture
                ctx.fillStyle = '#f0f8ff';
                ctx.fillRect(0, 280, 800, 320);

                // Snow texture/sparkle on ground
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 15; i++) {
                    const sx = 50 + i * 50 + Math.sin(i * 1.5) * 20;
                    const sy = 320 + Math.cos(i * 2) * 15;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawTinySnowman(ctx, x, y) {
                // Teeny tiny snowman in the distance
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y + 4, 4, 0, Math.PI * 2);  // Body
                ctx.arc(x, y, 3, 0, Math.PI * 2);      // Head
                ctx.fill();
                // Tiny hat
                ctx.fillStyle = '#333';
                ctx.fillRect(x - 2, y - 5, 4, 2);
                ctx.fillRect(x - 1, y - 8, 2, 3);
            },

            drawCloud(ctx, x, y, scale) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                const s = scale;
                ctx.beginPath();
                ctx.arc(x, y, 25 * s, 0, Math.PI * 2);
                ctx.arc(x + 30 * s, y - 10 * s, 30 * s, 0, Math.PI * 2);
                ctx.arc(x + 60 * s, y, 25 * s, 0, Math.PI * 2);
                ctx.arc(x + 35 * s, y + 10 * s, 20 * s, 0, Math.PI * 2);
                ctx.fill();
            },

            drawWoodenFence(ctx) {
                const fenceTop = 200;  // Top of fence at 2/3 up screen
                const fenceBottom = 280;  // Shorter fence since it's farther away
                const fenceHeight = fenceBottom - fenceTop;
                const plankWidth = 35;  // Narrower planks for perspective

                // Fence planks (vertical boards)
                for (let x = 0; x < 800; x += plankWidth) {
                    // Main plank
                    const plankGrad = ctx.createLinearGradient(x, 0, x + plankWidth, 0);
                    plankGrad.addColorStop(0, '#8B5A2B');
                    plankGrad.addColorStop(0.3, '#A0522D');
                    plankGrad.addColorStop(0.7, '#8B4513');
                    plankGrad.addColorStop(1, '#654321');
                    ctx.fillStyle = plankGrad;
                    ctx.fillRect(x, fenceTop, plankWidth - 2, fenceHeight);

                    // Pointed top
                    ctx.beginPath();
                    ctx.moveTo(x, fenceTop);
                    ctx.lineTo(x + (plankWidth - 2) / 2, fenceTop - 12);
                    ctx.lineTo(x + plankWidth - 2, fenceTop);
                    ctx.closePath();
                    ctx.fill();

                    // Wood grain lines
                    ctx.strokeStyle = 'rgba(101, 67, 33, 0.4)';
                    ctx.lineWidth = 1;
                    for (let gy = fenceTop + 15; gy < fenceBottom - 8; gy += 20) {
                        ctx.beginPath();
                        ctx.moveTo(x + 3, gy);
                        ctx.bezierCurveTo(x + 10, gy + 2, x + 20, gy - 1, x + plankWidth - 5, gy + 1);
                        ctx.stroke();
                    }

                    // Gap shadow between planks
                    ctx.fillStyle = '#3D2817';
                    ctx.fillRect(x + plankWidth - 2, fenceTop - 12, 2, fenceHeight + 12);
                }

                // Horizontal rail (back support)
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, fenceTop + 20, 800, 8);
                ctx.fillRect(0, fenceBottom - 25, 800, 8);
            },

            drawElements(ctx) {
                // Snow fort (left side) - covers snowmen 1 & 2
                this.drawSnowFort(ctx, 120, 350);

                // Igloo (center-right) - covers snowman 4
                this.drawIgloo(ctx, 520, 370);

                // Pine tree (far right) - covers snowman 5
                this.drawPineTree(ctx, 680, 330);
            },

            drawSnowFort(ctx, x, y) {
                // Create gradient for snow blocks
                const snowGrad = ctx.createLinearGradient(x - 70, 0, x + 70, 0);
                snowGrad.addColorStop(0, '#dce8f0');
                snowGrad.addColorStop(0.5, '#f0f8ff');
                snowGrad.addColorStop(1, '#e0ecf4');

                ctx.strokeStyle = '#b8c8d8';
                ctx.lineWidth = 2;

                // Tower (aligned with left edge of base wall)
                const towerGrad = ctx.createLinearGradient(x - 75, 0, x - 25, 0);
                towerGrad.addColorStop(0, '#d0e0ec');
                towerGrad.addColorStop(0.6, '#e8f4f8');
                towerGrad.addColorStop(1, '#d8e8f0');
                ctx.fillStyle = towerGrad;

                // Tower - left edge at x-70 (same as wall)
                ctx.fillRect(x - 70, y - 80, 50, 80);
                ctx.strokeRect(x - 70, y - 80, 50, 80);
                ctx.fillRect(x - 75, y - 100, 60, 20);
                ctx.strokeRect(x - 75, y - 100, 60, 20);

                // Tower crenellations
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(x - 70 + i * 32, y - 115, 20, 15);
                    ctx.strokeRect(x - 70 + i * 32, y - 115, 20, 15);
                }

                // Tower shadow (right side)
                ctx.fillStyle = 'rgba(180, 200, 220, 0.4)';
                ctx.fillRect(x - 30, y - 80, 10, 80);

                // Main wall (base)
                ctx.fillStyle = snowGrad;
                ctx.fillRect(x - 70, y, 140, 60);
                ctx.strokeRect(x - 70, y, 140, 60);

                // Wall shadow (bottom)
                ctx.fillStyle = 'rgba(180, 200, 220, 0.3)';
                ctx.fillRect(x - 70, y + 45, 140, 15);

                // Crenellations (top of wall)
                ctx.fillStyle = snowGrad;
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(x - 65 + i * 38, y - 18, 24, 18);
                    ctx.strokeRect(x - 65 + i * 38, y - 18, 24, 18);
                }

                // Snow accumulation on tower top
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(x - 45, y - 115, 22, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Snow accumulation on crenellations
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(x - 53 + i * 38, y - 18, 13, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Icicles hanging from tower ledge
                ctx.fillStyle = '#d0e8f8';
                const iciclePositions = [x - 72, x - 55, x - 40, x - 25];
                iciclePositions.forEach((ix, idx) => {
                    const len = 8 + (idx % 2) * 6;
                    ctx.beginPath();
                    ctx.moveTo(ix, y - 80);
                    ctx.lineTo(ix + 3, y - 80);
                    ctx.lineTo(ix + 1.5, y - 80 + len);
                    ctx.closePath();
                    ctx.fill();
                });

                // Icicles hanging from main wall crenellations
                for (let i = 0; i < 4; i++) {
                    const ix = x - 62 + i * 38;
                    ctx.beginPath();
                    ctx.moveTo(ix, y);
                    ctx.lineTo(ix + 2, y);
                    ctx.lineTo(ix + 1, y + 10);
                    ctx.closePath();
                    ctx.fill();
                }

                // Block lines on wall
                ctx.strokeStyle = 'rgba(200, 215, 230, 0.6)';
                ctx.lineWidth = 1;
                for (let by = y + 15; by < y + 55; by += 18) {
                    ctx.beginPath();
                    ctx.moveTo(x - 68, by);
                    ctx.lineTo(x + 68, by);
                    ctx.stroke();
                }
            },

            drawIgloo(ctx, x, y) {
                // Main dome with gradient shading
                const domeGrad = ctx.createRadialGradient(x - 20, y - 40, 10, x, y, 70);
                domeGrad.addColorStop(0, '#ffffff');
                domeGrad.addColorStop(0.4, '#f0f8ff');
                domeGrad.addColorStop(0.8, '#dce8f4');
                domeGrad.addColorStop(1, '#c8d8e8');

                ctx.fillStyle = domeGrad;
                ctx.beginPath();
                ctx.arc(x, y, 70, Math.PI, 0);
                ctx.fill();

                // Dome outline
                ctx.strokeStyle = '#b0c8d8';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Shadow on right side of dome
                ctx.fillStyle = 'rgba(180, 200, 220, 0.25)';
                ctx.beginPath();
                ctx.arc(x, y, 70, -0.3, 0);
                ctx.lineTo(x + 70, y);
                ctx.arc(x, y, 50, 0, -0.4, true);
                ctx.closePath();
                ctx.fill();

                // Ice block pattern (staggered bricks)
                ctx.strokeStyle = 'rgba(200, 220, 235, 0.7)';
                ctx.lineWidth = 1;

                // Horizontal block lines (curved)
                for (let i = 1; i < 4; i++) {
                    const radius = 70 - i * 17;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, Math.PI, 0);
                    ctx.stroke();
                }

                // Vertical block divisions (adjusted for each row)
                for (let row = 0; row < 3; row++) {
                    const innerR = 70 - (row + 1) * 17;
                    const outerR = 70 - row * 17;
                    const numBlocks = 6 + row * 2;
                    const offset = row % 2 === 0 ? 0 : Math.PI / numBlocks;

                    for (let b = 1; b < numBlocks; b++) {
                        const angle = Math.PI + (b * Math.PI / numBlocks) + offset;
                        if (angle > 0) continue;
                        ctx.beginPath();
                        ctx.moveTo(x + Math.cos(angle) * innerR, y + Math.sin(angle) * innerR);
                        ctx.lineTo(x + Math.cos(angle) * outerR, y + Math.sin(angle) * outerR);
                        ctx.stroke();
                    }
                }

                // Warm entrance glow (draw before entrance)
                const glowGrad = ctx.createRadialGradient(x, y - 5, 5, x, y - 5, 35);
                glowGrad.addColorStop(0, 'rgba(255, 200, 100, 0.6)');
                glowGrad.addColorStop(0.5, 'rgba(255, 180, 80, 0.3)');
                glowGrad.addColorStop(1, 'rgba(255, 150, 50, 0)');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.ellipse(x, y - 5, 30, 35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Entrance (dark opening)
                const entranceGrad = ctx.createLinearGradient(x, y - 30, x, y);
                entranceGrad.addColorStop(0, '#3a5a6a');
                entranceGrad.addColorStop(0.5, '#4a6a7a');
                entranceGrad.addColorStop(1, '#2a4a5a');
                ctx.fillStyle = entranceGrad;
                ctx.beginPath();
                ctx.ellipse(x, y, 22, 30, 0, Math.PI, 0);
                ctx.fill();

                // Entrance rim highlight
                ctx.strokeStyle = '#a0b8c8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(x, y, 22, 30, 0, Math.PI, 0);
                ctx.stroke();

                // Snow on top of igloo
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(x, y - 68, 30, 10, 0, 0, Math.PI * 2);
                ctx.fill();
            },

            drawPineTree(ctx, x, y) {
                // Very short trunk - just a small square
                ctx.fillStyle = '#654321';
                ctx.fillRect(x - 12, y + 50, 24, 30);

                // Trunk highlight (left side)
                ctx.fillStyle = '#8B5A2B';
                ctx.fillRect(x - 12, y + 50, 8, 30);

                // Larger snow-covered branches (4 layers instead of 3)
                for (let i = 0; i < 4; i++) {
                    const layerY = y + 40 - i * 40;  // Start lower, space them more
                    const width = 70 - i * 15;  // Wider base

                    // Branch shadow
                    ctx.fillStyle = '#1B6B1B';
                    ctx.beginPath();
                    ctx.moveTo(x, layerY - 48);
                    ctx.lineTo(x - width + 5, layerY + 3);
                    ctx.lineTo(x + width - 5, layerY + 3);
                    ctx.closePath();
                    ctx.fill();

                    // Main green branches
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.moveTo(x, layerY - 50);
                    ctx.lineTo(x - width, layerY);
                    ctx.lineTo(x + width, layerY);
                    ctx.closePath();
                    ctx.fill();

                    // Snow on top - thicker coverage
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(x, layerY - 50);
                    ctx.lineTo(x - width * 0.6, layerY - 20);
                    ctx.lineTo(x + width * 0.6, layerY - 20);
                    ctx.closePath();
                    ctx.fill();

                    // Snow drips/edges
                    ctx.fillStyle = '#E8F4F8';
                    ctx.beginPath();
                    ctx.arc(x - width * 0.4, layerY - 17, 4, 0, Math.PI * 2);
                    ctx.arc(x + width * 0.3, layerY - 14, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawFallingSnowRender(ctx) {
                ctx.fillStyle = '#fff';
                for (const flake of this.fallingSnow) {
                    ctx.beginPath();
                    ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawSplatMarks(ctx) {
                for (const splat of this.splatMarks) {
                    if (splat.alpha <= 0) continue;
                    ctx.fillStyle = `rgba(255, 255, 255, ${splat.alpha})`;
                    ctx.beginPath();
                    ctx.ellipse(splat.x, splat.y, 15, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawSnowmen(ctx) {
                const state = gameManager.gameStates.snowball;
                const scarfColor = state.teamColor === 'blue' ? '#3498db' : '#e74c3c';

                // Sort snowmen by Y position (back to front) for proper depth
                const sortedSnowmen = [...this.snowmen].sort((a, b) => a.y - b.y);

                for (const snowman of sortedSnowmen) {
                    if (!this.difficulty.availableTargets.includes(snowman.id)) continue;
                    if (snowman.hit || !snowman.visible) continue;
                    this.drawSnowman(ctx, snowman.x, snowman.y, scarfColor, snowman.scale, snowman.hideShadow);
                }
            },

            drawSnowman(ctx, x, y, scarfColor, scale = 1.0, hideShadow = false) {
                const s = scale;  // Shorthand for scaling

                // Shadow (ellipse under snowman) - only if not hidden
                if (!hideShadow) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.beginPath();
                    ctx.ellipse(x, y + 40 * s, 25 * s, 8 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Bottom ball
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y + 22 * s, 18 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2 * s;
                ctx.stroke();

                // Middle ball
                ctx.beginPath();
                ctx.arc(x, y, 13 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Head
                ctx.beginPath();
                ctx.arc(x, y - 18 * s, 10 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Top hat
                ctx.fillStyle = '#222';
                ctx.fillRect(x - 8 * s, y - 34 * s, 16 * s, 5 * s);
                ctx.fillRect(x - 5 * s, y - 48 * s, 10 * s, 16 * s);

                // Carrot nose
                ctx.fillStyle = '#e67e22';
                ctx.beginPath();
                ctx.moveTo(x, y - 18 * s);
                ctx.lineTo(x + 10 * s, y - 17 * s);
                ctx.lineTo(x, y - 16 * s);
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(x - 3 * s, y - 21 * s, 2 * s, 0, Math.PI * 2);
                ctx.arc(x + 3 * s, y - 21 * s, 2 * s, 0, Math.PI * 2);
                ctx.fill();

                // Scarf
                ctx.fillStyle = scarfColor;
                ctx.fillRect(x - 10 * s, y - 8 * s, 20 * s, 5 * s);
                ctx.fillRect(x + 6 * s, y - 8 * s, 5 * s, 15 * s);

                // Stick arms
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2 * s;
                ctx.beginPath();
                ctx.moveTo(x - 13 * s, y);
                ctx.lineTo(x - 28 * s, y - 8 * s);
                ctx.moveTo(x + 13 * s, y);
                ctx.lineTo(x + 28 * s, y - 6 * s);
                ctx.stroke();
            },

            drawSlingshot(ctx) {
                const x = this.slingshot.x;
                const y = this.slingshot.y;

                // Handle (fixed, doesn't rotate)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.moveTo(x - 4, y);
                ctx.lineTo(x + 4, y);
                ctx.lineTo(x + 3, y + 45);
                ctx.lineTo(x - 3, y + 45);
                ctx.closePath();
                ctx.fill();

                // Fork prongs (fixed, don't rotate)
                ctx.beginPath();
                ctx.moveTo(x - 4, y);
                ctx.lineTo(x - 18, y - 35);
                ctx.lineTo(x - 13, y - 40);
                ctx.lineTo(x, y - 5);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(x + 4, y);
                ctx.lineTo(x + 18, y - 35);
                ctx.lineTo(x + 13, y - 40);
                ctx.lineTo(x, y - 5);
                ctx.fill();

                // Elastic band (angles toward target direction)
                ctx.strokeStyle = '#5D3A1A';
                ctx.lineWidth = 3;

                // Fork tip positions (where bands attach)
                const leftForkX = x - 15;
                const leftForkY = y - 37;
                const rightForkX = x + 15;
                const rightForkY = y - 37;

                // When snowball is flying, show relaxed band
                if (this.snowball.active) {
                    ctx.beginPath();
                    ctx.moveTo(leftForkX, leftForkY);
                    ctx.quadraticCurveTo(x, y - 30, rightForkX, rightForkY);
                    ctx.stroke();
                } else {
                    // Calculate band pullback position based on aim direction and power
                    const aimAngle = this.getAimAngle();
                    // Power affects pullback distance (10 to 35 pixels behind slingshot)
                    const displayPower = this.slingshot.charging ? this.slingshot.power : 0.2;
                    const pullDistance = 10 + displayPower * 25;

                    // Pullback position: opposite direction of aim (behind slingshot)
                    const pullX = x - Math.cos(aimAngle) * pullDistance;
                    const pullY = (y - 25) - Math.sin(aimAngle) * pullDistance;

                    // Draw bands from fork tips to pullback point
                    ctx.beginPath();
                    ctx.moveTo(leftForkX, leftForkY);
                    ctx.lineTo(pullX, pullY);
                    ctx.lineTo(rightForkX, rightForkY);
                    ctx.stroke();

                    // Snowball in sling at pullback position
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(pullX, pullY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw aim direction indicator (small line toward target)
                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y - 30);
                    const indicatorLen = 30;
                    ctx.lineTo(x + Math.cos(aimAngle) * indicatorLen, (y - 30) + Math.sin(aimAngle) * indicatorLen);
                    ctx.stroke();
                }
            },

            drawTrajectory(ctx) {
                // Always show trajectory when not actively throwing
                if (this.snowball.active) return;

                // Get the bezier trajectory arc
                const trajectory = this.calculateTrajectoryArc();
                const points = trajectory.points;

                // Draw dotted arc line
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);

                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(points[i].x, points[i].y);
                    } else {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Crosshair at exact target position (where snowball WILL land)
                const target = trajectory.end;
                ctx.strokeStyle = 'rgba(200, 50, 50, 0.8)';
                ctx.lineWidth = 2;

                // Crosshair lines
                ctx.beginPath();
                ctx.moveTo(target.x - 15, target.y);
                ctx.lineTo(target.x + 15, target.y);
                ctx.moveTo(target.x, target.y - 15);
                ctx.lineTo(target.x, target.y + 15);
                ctx.stroke();

                // Circle around target
                ctx.beginPath();
                ctx.arc(target.x, target.y, 10, 0, Math.PI * 2);
                ctx.stroke();

                // Inner dot
                ctx.fillStyle = 'rgba(200, 50, 50, 0.6)';
                ctx.beginPath();
                ctx.arc(target.x, target.y, 3, 0, Math.PI * 2);
                ctx.fill();
            },

            drawSnowball(ctx) {
                if (!this.snowball.active) return;

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.snowball.x, this.snowball.y, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.stroke();
            },

            drawParticles(ctx) {
                ctx.fillStyle = '#fff';
                for (const p of this.particles) {
                    const alpha = p.life / 800;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            drawHUD(ctx) {
                const state = gameManager.gameStates.snowball;

                // Top bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, 800, 50);

                // Timer
                const seconds = Math.ceil(this.timeRemaining / 1000);
                ctx.fillStyle = seconds <= 10 ? '#e74c3c' : '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`‚è±Ô∏è ${seconds}s`, 20, 35);

                // Snowmen hit progress
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(`‚õÑ ${this.snowmenHitThisRound} / ${this.requiredHits}`, 400, 35);

                // Snowballs remaining
                ctx.fillStyle = '#74b9ff';
                ctx.textAlign = 'right';
                ctx.fillText(`‚ùÑÔ∏è ${state.resources}`, 780, 35);

                // Control hints
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üê ‚Üí aim  |  ‚Üë ‚Üì loft  |  SPACE power', 400, 590);
            },

            drawPowerMeter(ctx) {
                const x = 730;
                const y = 420;
                const width = 25;
                const height = 120;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(x - 5, y - 5, width + 10, height + 30);

                // Meter background
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, width, height);

                // Power fill
                const fillHeight = this.slingshot.power * height;
                const gradient = ctx.createLinearGradient(x, y + height, x, y);
                gradient.addColorStop(0, '#27ae60');
                gradient.addColorStop(0.5, '#f1c40f');
                gradient.addColorStop(1, '#e74c3c');
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y + height - fillHeight, width, fillHeight);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('POWER', x + width/2, y + height + 18);
            },

            cleanup() {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        };

        // Add keyboard listener for fieldgoal game
        document.addEventListener('keydown', (e) => {
            if (currentGameType === 'fieldgoal') {
                fieldgoalGame.handleKeyPress(e);
            }
        });

        // Add keyboard listeners for minigolf game
        document.addEventListener('keydown', (e) => {
            if (currentGameType === 'minigolf') {
                minigolfGame.handleKeyDown(e);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentGameType === 'minigolf') {
                minigolfGame.handleKeyUp(e);
            }
        });

        // Add keyboard listeners for motorcycle game
        document.addEventListener('keydown', (e) => {
            if (currentGameType === 'motorcycle') {
                motorcycleGame.handleKeyDown(e);
            }
            if (currentGameType === 'snowball') {
                snowballGame.handleKeyDown(e);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentGameType === 'motorcycle') {
                motorcycleGame.handleKeyUp(e);
            }
            if (currentGameType === 'snowball') {
                snowballGame.handleKeyUp(e);
            }
        });

        // Initialize the hub as active when page loads
        document.getElementById('gameHub').classList.add('active');

        // Initialize profile display
        updateProfileDisplay();
    </script>

    <!-- Profile Manager Modal -->
    <div id="profileManagerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üë• Manage Players</h3>
                <button class="modal-close" onclick="hideProfileManager()">‚úï</button>
            </div>
            <div id="profileList" class="profile-list">
                <!-- Populated dynamically -->
            </div>
            <button class="modal-action-button" onclick="showCreateProfile()">+ Create New Player</button>
        </div>
    </div>

    <!-- Create Profile Modal -->
    <div id="createProfileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="profileModalTitle">‚ú® New Player</h3>
                <button class="modal-close" onclick="hideCreateProfile()">‚úï</button>
            </div>
            <div class="profile-form">
                <label for="profileNameInput">Name:</label>
                <input type="text" id="profileNameInput" placeholder="Enter name..." maxlength="20">
                <label>Choose Avatar:</label>
                <div class="avatar-grid" id="avatarGrid">
                    <!-- Populated dynamically -->
                </div>
            </div>
            <button id="profileSubmitBtn" class="modal-action-button" onclick="submitProfile()">Create Player</button>
        </div>
    </div>

    <!-- Delete Confirm Modal -->
    <div id="deleteConfirmModal" class="modal">
        <div class="modal-content modal-content-small">
            <p>Delete <strong><span id="deleteProfileName"></span></strong>?</p>
            <p class="delete-warning">This cannot be undone.</p>
            <div class="modal-buttons">
                <button class="modal-button-danger" onclick="confirmDeleteProfile()">Delete</button>
                <button class="modal-button-cancel" onclick="hideDeleteConfirm()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Avatar Modal -->
    <div id="editAvatarModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üé® Change Avatar</h3>
                <button class="modal-close" onclick="hideEditAvatar()">‚úï</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px;">Choose a new avatar:</p>
                <div class="avatar-grid" id="editAvatarGrid"></div>
            </div>
            <button class="modal-button-primary" onclick="saveEditedAvatar()">Save Avatar</button>
        </div>
    </div>
</body>
</html>